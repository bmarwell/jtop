/*
 * Copyright (C) 2024.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.bmarwell.jtop.lib.osx.ffm; // Generated by jextract

import static java.lang.foreign.ValueLayout.*;

import java.lang.foreign.AddressLayout;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.GroupLayout;
import java.lang.foreign.Linker;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.SequenceLayout;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;

public class sysctl_h extends sysctl_h_1 {

    sysctl_h() {
        // Should not be called directly
    }

    private static final int USER_POSIX2_C_BIND = (int) 11L;
    /**
     * {@snippet lang=c :
     * #define USER_POSIX2_C_BIND 11
     * }
     */
    public static int USER_POSIX2_C_BIND() {
        return USER_POSIX2_C_BIND;
    }

    private static final int USER_POSIX2_C_DEV = (int) 12L;
    /**
     * {@snippet lang=c :
     * #define USER_POSIX2_C_DEV 12
     * }
     */
    public static int USER_POSIX2_C_DEV() {
        return USER_POSIX2_C_DEV;
    }

    private static final int USER_POSIX2_CHAR_TERM = (int) 13L;
    /**
     * {@snippet lang=c :
     * #define USER_POSIX2_CHAR_TERM 13
     * }
     */
    public static int USER_POSIX2_CHAR_TERM() {
        return USER_POSIX2_CHAR_TERM;
    }

    private static final int USER_POSIX2_FORT_DEV = (int) 14L;
    /**
     * {@snippet lang=c :
     * #define USER_POSIX2_FORT_DEV 14
     * }
     */
    public static int USER_POSIX2_FORT_DEV() {
        return USER_POSIX2_FORT_DEV;
    }

    private static final int USER_POSIX2_FORT_RUN = (int) 15L;
    /**
     * {@snippet lang=c :
     * #define USER_POSIX2_FORT_RUN 15
     * }
     */
    public static int USER_POSIX2_FORT_RUN() {
        return USER_POSIX2_FORT_RUN;
    }

    private static final int USER_POSIX2_LOCALEDEF = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define USER_POSIX2_LOCALEDEF 16
     * }
     */
    public static int USER_POSIX2_LOCALEDEF() {
        return USER_POSIX2_LOCALEDEF;
    }

    private static final int USER_POSIX2_SW_DEV = (int) 17L;
    /**
     * {@snippet lang=c :
     * #define USER_POSIX2_SW_DEV 17
     * }
     */
    public static int USER_POSIX2_SW_DEV() {
        return USER_POSIX2_SW_DEV;
    }

    private static final int USER_POSIX2_UPE = (int) 18L;
    /**
     * {@snippet lang=c :
     * #define USER_POSIX2_UPE 18
     * }
     */
    public static int USER_POSIX2_UPE() {
        return USER_POSIX2_UPE;
    }

    private static final int USER_STREAM_MAX = (int) 19L;
    /**
     * {@snippet lang=c :
     * #define USER_STREAM_MAX 19
     * }
     */
    public static int USER_STREAM_MAX() {
        return USER_STREAM_MAX;
    }

    private static final int USER_TZNAME_MAX = (int) 20L;
    /**
     * {@snippet lang=c :
     * #define USER_TZNAME_MAX 20
     * }
     */
    public static int USER_TZNAME_MAX() {
        return USER_TZNAME_MAX;
    }

    private static final int USER_MAXID = (int) 21L;
    /**
     * {@snippet lang=c :
     * #define USER_MAXID 21
     * }
     */
    public static int USER_MAXID() {
        return USER_MAXID;
    }

    private static final int CTL_DEBUG_NAME = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CTL_DEBUG_NAME 0
     * }
     */
    public static int CTL_DEBUG_NAME() {
        return CTL_DEBUG_NAME;
    }

    private static final int CTL_DEBUG_VALUE = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CTL_DEBUG_VALUE 1
     * }
     */
    public static int CTL_DEBUG_VALUE() {
        return CTL_DEBUG_VALUE;
    }

    private static final int CTL_DEBUG_MAXID = (int) 20L;
    /**
     * {@snippet lang=c :
     * #define CTL_DEBUG_MAXID 20
     * }
     */
    public static int CTL_DEBUG_MAXID() {
        return CTL_DEBUG_MAXID;
    }
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = sysctl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = sysctl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __int64_t
     * }
     */
    public static final OfLong __int64_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_intptr_t
     * }
     */
    public static final OfLong __darwin_intptr_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_natural_t
     * }
     */
    public static final OfInt __darwin_natural_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_ct_rune_t
     * }
     */
    public static final OfInt __darwin_ct_rune_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ptrdiff_t
     * }
     */
    public static final OfLong __darwin_ptrdiff_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_size_t
     * }
     */
    public static final OfLong __darwin_size_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __darwin_va_list
     * }
     */
    public static final AddressLayout __darwin_va_list = sysctl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wchar_t
     * }
     */
    public static final OfInt __darwin_wchar_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t __darwin_rune_t
     * }
     */
    public static final OfInt __darwin_rune_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wint_t
     * }
     */
    public static final OfInt __darwin_wint_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_clock_t
     * }
     */
    public static final OfLong __darwin_clock_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_socklen_t
     * }
     */
    public static final OfInt __darwin_socklen_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ssize_t
     * }
     */
    public static final OfLong __darwin_ssize_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_time_t
     * }
     */
    public static final OfLong __darwin_time_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = sysctl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = sysctl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = sysctl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t register_t
     * }
     */
    public static final OfLong register_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_addr_t
     * }
     */
    public static final OfLong user_addr_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_size_t
     * }
     */
    public static final OfLong user_size_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_ssize_t
     * }
     */
    public static final OfLong user_ssize_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_long_t
     * }
     */
    public static final OfLong user_long_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_ulong_t
     * }
     */
    public static final OfLong user_ulong_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_time_t
     * }
     */
    public static final OfLong user_time_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_off_t
     * }
     */
    public static final OfLong user_off_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t syscall_arg_t
     * }
     */
    public static final OfLong syscall_arg_t = sysctl_h.C_LONG_LONG;

    private static class __darwin_check_fd_set_overflow {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_INT, sysctl_h.C_POINTER, sysctl_h.C_INT);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("__darwin_check_fd_set_overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static FunctionDescriptor __darwin_check_fd_set_overflow$descriptor() {
        return __darwin_check_fd_set_overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MethodHandle __darwin_check_fd_set_overflow$handle() {
        return __darwin_check_fd_set_overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MemorySegment __darwin_check_fd_set_overflow$address() {
        return __darwin_check_fd_set_overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static int __darwin_check_fd_set_overflow(int x0, MemorySegment x1, int x2) {
        var mh$ = __darwin_check_fd_set_overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__darwin_check_fd_set_overflow", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_time_t time_t
     * }
     */
    public static final OfLong time_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_suseconds_t suseconds_t
     * }
     */
    public static final OfInt suseconds_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_nl_item
     * }
     */
    public static final OfInt __darwin_nl_item = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wctrans_t
     * }
     */
    public static final OfInt __darwin_wctrans_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_wctype_t
     * }
     */
    public static final OfInt __darwin_wctype_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_clock_t clock_t
     * }
     */
    public static final OfLong clock_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t size_t
     * }
     */
    public static final OfLong size_t = sysctl_h.C_LONG;

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, sysctl_h.C_POINTER);
        public static final MemorySegment SEGMENT =
                sysctl_h.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {};
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    private static class getdate_err$constants {
        public static final OfInt LAYOUT = sysctl_h.C_INT;
        public static final MemorySegment SEGMENT =
                sysctl_h.findOrThrow("getdate_err").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static OfInt getdate_err$layout() {
        return getdate_err$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static MemorySegment getdate_err$segment() {
        return getdate_err$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static int getdate_err() {
        return getdate_err$constants.SEGMENT.get(getdate_err$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static void getdate_err(int varValue) {
        getdate_err$constants.SEGMENT.set(getdate_err$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = sysctl_h.C_LONG;
        public static final MemorySegment SEGMENT =
                sysctl_h.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = sysctl_h.C_INT;
        public static final MemorySegment SEGMENT =
                sysctl_h.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MemorySegment asctime(MemorySegment x0) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", x0);
            }
            return (MemorySegment) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_LONG);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long) mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MemorySegment ctime(MemorySegment x0) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", x0);
            }
            return (MemorySegment) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_DOUBLE, sysctl_h.C_LONG, sysctl_h.C_LONG);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static double difftime(long x0, long x1) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", x0, x1);
            }
            return (double) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("getdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static FunctionDescriptor getdate$descriptor() {
        return getdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MethodHandle getdate$handle() {
        return getdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MemorySegment getdate$address() {
        return getdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MemorySegment getdate(MemorySegment x0) {
        var mh$ = getdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdate", x0);
            }
            return (MemorySegment) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MemorySegment gmtime(MemorySegment x0) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", x0);
            }
            return (MemorySegment) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MemorySegment localtime(MemorySegment x0) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", x0);
            }
            return (MemorySegment) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_LONG, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static long mktime(MemorySegment x0) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                sysctl_h.C_LONG, sysctl_h.C_POINTER, sysctl_h.C_LONG, sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static long strftime(MemorySegment x0, long x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", x0, x1, x2, x3);
            }
            return (long) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strptime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_POINTER, sysctl_h.C_POINTER, sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("strptime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor strptime$descriptor() {
        return strptime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle strptime$handle() {
        return strptime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment strptime$address() {
        return strptime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment strptime(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = strptime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strptime", x0, x1, x2);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_LONG, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static long time(MemorySegment x0) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid();

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_POINTER, sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_POINTER, sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_POINTER, sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_POINTER, sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix2time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_LONG, sysctl_h.C_LONG);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("posix2time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static FunctionDescriptor posix2time$descriptor() {
        return posix2time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static MethodHandle posix2time$handle() {
        return posix2time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static MemorySegment posix2time$address() {
        return posix2time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static long posix2time(long x0) {
        var mh$ = posix2time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix2time", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tzsetwall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid();

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("tzsetwall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static FunctionDescriptor tzsetwall$descriptor() {
        return tzsetwall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static MethodHandle tzsetwall$handle() {
        return tzsetwall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static MemorySegment tzsetwall$address() {
        return tzsetwall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static void tzsetwall() {
        var mh$ = tzsetwall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzsetwall");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time2posix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_LONG, sysctl_h.C_LONG);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("time2posix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static FunctionDescriptor time2posix$descriptor() {
        return time2posix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static MethodHandle time2posix$handle() {
        return time2posix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static MemorySegment time2posix$address() {
        return time2posix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static long time2posix(long x0) {
        var mh$ = time2posix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time2posix", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_LONG, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static long timelocal(MemorySegment x0) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_LONG, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static long timegm(MemorySegment x0) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static int nanosleep(MemorySegment __rqtp, MemorySegment __rmtp) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __rqtp, __rmtp);
            }
            return (int) mh$.invokeExact(__rqtp, __rmtp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static final int _CLOCK_REALTIME = (int) 0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_REALTIME = 0
     * }
     */
    public static int _CLOCK_REALTIME() {
        return _CLOCK_REALTIME;
    }

    private static final int _CLOCK_MONOTONIC = (int) 6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC = 6
     * }
     */
    public static int _CLOCK_MONOTONIC() {
        return _CLOCK_MONOTONIC;
    }

    private static final int _CLOCK_MONOTONIC_RAW = (int) 4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC_RAW = 4
     * }
     */
    public static int _CLOCK_MONOTONIC_RAW() {
        return _CLOCK_MONOTONIC_RAW;
    }

    private static final int _CLOCK_MONOTONIC_RAW_APPROX = (int) 5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC_RAW_APPROX = 5
     * }
     */
    public static int _CLOCK_MONOTONIC_RAW_APPROX() {
        return _CLOCK_MONOTONIC_RAW_APPROX;
    }

    private static final int _CLOCK_UPTIME_RAW = (int) 8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_UPTIME_RAW = 8
     * }
     */
    public static int _CLOCK_UPTIME_RAW() {
        return _CLOCK_UPTIME_RAW;
    }

    private static final int _CLOCK_UPTIME_RAW_APPROX = (int) 9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_UPTIME_RAW_APPROX = 9
     * }
     */
    public static int _CLOCK_UPTIME_RAW_APPROX() {
        return _CLOCK_UPTIME_RAW_APPROX;
    }

    private static final int _CLOCK_PROCESS_CPUTIME_ID = (int) 12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_PROCESS_CPUTIME_ID = 12
     * }
     */
    public static int _CLOCK_PROCESS_CPUTIME_ID() {
        return _CLOCK_PROCESS_CPUTIME_ID;
    }

    private static final int _CLOCK_THREAD_CPUTIME_ID = (int) 16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_THREAD_CPUTIME_ID = 16
     * }
     */
    public static int _CLOCK_THREAD_CPUTIME_ID() {
        return _CLOCK_THREAD_CPUTIME_ID;
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_INT, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int) mh$.invokeExact(__clock_id, __res);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_INT, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int) mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime_nsec_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_LONG_LONG, sysctl_h.C_INT);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("clock_gettime_nsec_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static FunctionDescriptor clock_gettime_nsec_np$descriptor() {
        return clock_gettime_nsec_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static MethodHandle clock_gettime_nsec_np$handle() {
        return clock_gettime_nsec_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static MemorySegment clock_gettime_nsec_np$address() {
        return clock_gettime_nsec_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static long clock_gettime_nsec_np(int __clock_id) {
        var mh$ = clock_gettime_nsec_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime_nsec_np", __clock_id);
            }
            return (long) mh$.invokeExact(__clock_id);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_INT, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int) mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER, sysctl_h.C_INT);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static int timespec_get(MemorySegment ts, int base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", ts, base);
            }
            return (int) mh$.invokeExact(ts, base);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class adjtime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("adjtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static FunctionDescriptor adjtime$descriptor() {
        return adjtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static MethodHandle adjtime$handle() {
        return adjtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static MemorySegment adjtime$address() {
        return adjtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static int adjtime(MemorySegment x0, MemorySegment x1) {
        var mh$ = adjtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("adjtime", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class futimes {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_INT, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("futimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static FunctionDescriptor futimes$descriptor() {
        return futimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static MethodHandle futimes$handle() {
        return futimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static MemorySegment futimes$address() {
        return futimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static int futimes(int x0, MemorySegment x1) {
        var mh$ = futimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("futimes", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lutimes {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("lutimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static FunctionDescriptor lutimes$descriptor() {
        return lutimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static MethodHandle lutimes$handle() {
        return lutimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static MemorySegment lutimes$address() {
        return lutimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static int lutimes(MemorySegment x0, MemorySegment x1) {
        var mh$ = lutimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lutimes", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class settimeofday {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("settimeofday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static FunctionDescriptor settimeofday$descriptor() {
        return settimeofday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static MethodHandle settimeofday$handle() {
        return settimeofday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static MemorySegment settimeofday$address() {
        return settimeofday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static int settimeofday(MemorySegment x0, MemorySegment x1) {
        var mh$ = settimeofday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("settimeofday", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getitimer {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_INT, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("getitimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static FunctionDescriptor getitimer$descriptor() {
        return getitimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static MethodHandle getitimer$handle() {
        return getitimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static MemorySegment getitimer$address() {
        return getitimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static int getitimer(int x0, MemorySegment x1) {
        var mh$ = getitimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getitimer", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gettimeofday {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("gettimeofday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static FunctionDescriptor gettimeofday$descriptor() {
        return gettimeofday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static MethodHandle gettimeofday$handle() {
        return gettimeofday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static MemorySegment gettimeofday$address() {
        return gettimeofday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static int gettimeofday(MemorySegment x0, MemorySegment x1) {
        var mh$ = gettimeofday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gettimeofday", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                sysctl_h.C_INT,
                sysctl_h.C_INT,
                sysctl_h.C_POINTER,
                sysctl_h.C_POINTER,
                sysctl_h.C_POINTER,
                sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static int select(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", x0, x1, x2, x3, x4);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setitimer {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_INT, sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("setitimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static FunctionDescriptor setitimer$descriptor() {
        return setitimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static MethodHandle setitimer$handle() {
        return setitimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static MemorySegment setitimer$address() {
        return setitimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static int setitimer(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = setitimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setitimer", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class utimes {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("utimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static FunctionDescriptor utimes$descriptor() {
        return utimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static MethodHandle utimes$handle() {
        return utimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static MemorySegment utimes$address() {
        return utimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static int utimes(MemorySegment x0, MemorySegment x1) {
        var mh$ = utimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("utimes", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = sysctl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = sysctl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = sysctl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = sysctl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = sysctl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_char
     * }
     */
    public static final OfByte u_char = sysctl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_short
     * }
     */
    public static final OfShort u_short = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int
     * }
     */
    public static final OfInt u_int = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long u_long
     * }
     */
    public static final OfLong u_long = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t quad_t
     * }
     */
    public static final OfLong quad_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef quad_t *qaddr_t
     * }
     */
    public static final AddressLayout qaddr_t = sysctl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef char *caddr_t
     * }
     */
    public static final AddressLayout caddr_t = sysctl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int32_t daddr_t
     * }
     */
    public static final OfInt daddr_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_dev_t dev_t
     * }
     */
    public static final OfInt dev_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fixpt_t
     * }
     */
    public static final OfInt fixpt_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blksize_t blksize_t
     * }
     */
    public static final OfInt blksize_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_gid_t gid_t
     * }
     */
    public static final OfInt gid_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t in_addr_t
     * }
     */
    public static final OfInt in_addr_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t in_port_t
     * }
     */
    public static final OfShort in_port_t = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino_t ino_t
     * }
     */
    public static final OfLong ino_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t ino64_t
     * }
     */
    public static final OfLong ino64_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t key_t
     * }
     */
    public static final OfInt key_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mode_t mode_t
     * }
     */
    public static final OfShort mode_t = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t nlink_t
     * }
     */
    public static final OfShort nlink_t = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_id_t id_t
     * }
     */
    public static final OfInt id_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pid_t pid_t
     * }
     */
    public static final OfInt pid_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t off_t
     * }
     */
    public static final OfLong off_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int32_t segsz_t
     * }
     */
    public static final OfInt segsz_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t swblk_t
     * }
     */
    public static final OfInt swblk_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_uid_t uid_t
     * }
     */
    public static final OfInt uid_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_useconds_t useconds_t
     * }
     */
    public static final OfInt useconds_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t fd_mask
     * }
     */
    public static final OfInt fd_mask = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_t pthread_t
     * }
     */
    public static final AddressLayout pthread_t = sysctl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_key_t pthread_key_t
     * }
     */
    public static final OfLong pthread_key_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfInt fsblkcnt_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfInt fsfilcnt_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int sig_atomic_t
     * }
     */
    public static final OfInt sig_atomic_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct __darwin_mcontext64 {
     *     struct __darwin_arm_exception_state64 __es;
     *     struct __darwin_arm_thread_state64 __ss;
     *     struct __darwin_arm_neon_state64 __ns;
     * } *mcontext_t
     * }
     */
    public static final AddressLayout mcontext_t = sysctl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_sigset_t sigset_t
     * }
     */
    public static final OfInt sigset_t = sysctl_h.C_INT;

    private static class signal {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_POINTER, sysctl_h.C_INT, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal(int x0, MemorySegment x1) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uid_t au_id_t
     * }
     */
    public static final OfInt au_id_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef pid_t au_asid_t
     * }
     */
    public static final OfInt au_asid_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int16_t au_event_t
     * }
     */
    public static final OfShort au_event_t = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef u_int16_t au_emod_t
     * }
     */
    public static final OfShort au_emod_t = sysctl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t au_class_t
     * }
     */
    public static final OfInt au_class_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t au_asflgs_t
     * }
     */
    public static final OfLong au_asflgs_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char au_ctlmode_t
     * }
     */
    public static final OfByte au_ctlmode_t = sysctl_h.C_CHAR;

    private static final int AU_SESSION_FLAG_IS_INITIAL = (int) 1L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_IS_INITIAL = 1
     * }
     */
    public static int AU_SESSION_FLAG_IS_INITIAL() {
        return AU_SESSION_FLAG_IS_INITIAL;
    }

    private static final int AU_SESSION_FLAG_HAS_GRAPHIC_ACCESS = (int) 16L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_HAS_GRAPHIC_ACCESS = 16
     * }
     */
    public static int AU_SESSION_FLAG_HAS_GRAPHIC_ACCESS() {
        return AU_SESSION_FLAG_HAS_GRAPHIC_ACCESS;
    }

    private static final int AU_SESSION_FLAG_HAS_TTY = (int) 32L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_HAS_TTY = 32
     * }
     */
    public static int AU_SESSION_FLAG_HAS_TTY() {
        return AU_SESSION_FLAG_HAS_TTY;
    }

    private static final int AU_SESSION_FLAG_IS_REMOTE = (int) 4096L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_IS_REMOTE = 4096
     * }
     */
    public static int AU_SESSION_FLAG_IS_REMOTE() {
        return AU_SESSION_FLAG_IS_REMOTE;
    }

    private static final int AU_SESSION_FLAG_HAS_CONSOLE_ACCESS = (int) 8192L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_HAS_CONSOLE_ACCESS = 8192
     * }
     */
    public static int AU_SESSION_FLAG_HAS_CONSOLE_ACCESS() {
        return AU_SESSION_FLAG_HAS_CONSOLE_ACCESS;
    }

    private static final int AU_SESSION_FLAG_HAS_AUTHENTICATED = (int) 16384L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_HAS_AUTHENTICATED = 16384
     * }
     */
    public static int AU_SESSION_FLAG_HAS_AUTHENTICATED() {
        return AU_SESSION_FLAG_HAS_AUTHENTICATED;
    }

    private static class audit {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER, sysctl_h.C_INT);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("audit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int audit(const void *, int)
     * }
     */
    public static FunctionDescriptor audit$descriptor() {
        return audit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int audit(const void *, int)
     * }
     */
    public static MethodHandle audit$handle() {
        return audit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int audit(const void *, int)
     * }
     */
    public static MemorySegment audit$address() {
        return audit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int audit(const void *, int)
     * }
     */
    public static int audit(MemorySegment x0, int x1) {
        var mh$ = audit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("audit", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class auditon {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_INT, sysctl_h.C_POINTER, sysctl_h.C_INT);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("auditon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int auditon(int, void *, int)
     * }
     */
    public static FunctionDescriptor auditon$descriptor() {
        return auditon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int auditon(int, void *, int)
     * }
     */
    public static MethodHandle auditon$handle() {
        return auditon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int auditon(int, void *, int)
     * }
     */
    public static MemorySegment auditon$address() {
        return auditon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int auditon(int, void *, int)
     * }
     */
    public static int auditon(int x0, MemorySegment x1, int x2) {
        var mh$ = auditon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("auditon", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class auditctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("auditctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int auditctl(const char *)
     * }
     */
    public static FunctionDescriptor auditctl$descriptor() {
        return auditctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int auditctl(const char *)
     * }
     */
    public static MethodHandle auditctl$handle() {
        return auditctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int auditctl(const char *)
     * }
     */
    public static MemorySegment auditctl$address() {
        return auditctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int auditctl(const char *)
     * }
     */
    public static int auditctl(MemorySegment x0) {
        var mh$ = auditctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("auditctl", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getauid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("getauid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getauid(au_id_t *)
     * }
     */
    public static FunctionDescriptor getauid$descriptor() {
        return getauid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getauid(au_id_t *)
     * }
     */
    public static MethodHandle getauid$handle() {
        return getauid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getauid(au_id_t *)
     * }
     */
    public static MemorySegment getauid$address() {
        return getauid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getauid(au_id_t *)
     * }
     */
    public static int getauid(MemorySegment x0) {
        var mh$ = getauid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getauid", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setauid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("setauid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setauid(const au_id_t *)
     * }
     */
    public static FunctionDescriptor setauid$descriptor() {
        return setauid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setauid(const au_id_t *)
     * }
     */
    public static MethodHandle setauid$handle() {
        return setauid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setauid(const au_id_t *)
     * }
     */
    public static MemorySegment setauid$address() {
        return setauid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setauid(const au_id_t *)
     * }
     */
    public static int setauid(MemorySegment x0) {
        var mh$ = setauid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setauid", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getaudit_addr {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER, sysctl_h.C_INT);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("getaudit_addr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getaudit_addr(struct auditinfo_addr *, int)
     * }
     */
    public static FunctionDescriptor getaudit_addr$descriptor() {
        return getaudit_addr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getaudit_addr(struct auditinfo_addr *, int)
     * }
     */
    public static MethodHandle getaudit_addr$handle() {
        return getaudit_addr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getaudit_addr(struct auditinfo_addr *, int)
     * }
     */
    public static MemorySegment getaudit_addr$address() {
        return getaudit_addr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getaudit_addr(struct auditinfo_addr *, int)
     * }
     */
    public static int getaudit_addr(MemorySegment x0, int x1) {
        var mh$ = getaudit_addr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getaudit_addr", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setaudit_addr {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER, sysctl_h.C_INT);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("setaudit_addr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setaudit_addr(const struct auditinfo_addr *, int)
     * }
     */
    public static FunctionDescriptor setaudit_addr$descriptor() {
        return setaudit_addr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setaudit_addr(const struct auditinfo_addr *, int)
     * }
     */
    public static MethodHandle setaudit_addr$handle() {
        return setaudit_addr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setaudit_addr(const struct auditinfo_addr *, int)
     * }
     */
    public static MemorySegment setaudit_addr$address() {
        return setaudit_addr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setaudit_addr(const struct auditinfo_addr *, int)
     * }
     */
    public static int setaudit_addr(MemorySegment x0, int x1) {
        var mh$ = setaudit_addr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setaudit_addr", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getaudit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("getaudit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getaudit(struct auditinfo *)
     * }
     */
    public static FunctionDescriptor getaudit$descriptor() {
        return getaudit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getaudit(struct auditinfo *)
     * }
     */
    public static MethodHandle getaudit$handle() {
        return getaudit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getaudit(struct auditinfo *)
     * }
     */
    public static MemorySegment getaudit$address() {
        return getaudit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getaudit(struct auditinfo *)
     * }
     */
    public static int getaudit(MemorySegment x0) {
        var mh$ = getaudit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getaudit", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setaudit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("setaudit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setaudit(const struct auditinfo *)
     * }
     */
    public static FunctionDescriptor setaudit$descriptor() {
        return setaudit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setaudit(const struct auditinfo *)
     * }
     */
    public static MethodHandle setaudit$handle() {
        return setaudit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setaudit(const struct auditinfo *)
     * }
     */
    public static MemorySegment setaudit$address() {
        return setaudit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setaudit(const struct auditinfo *)
     * }
     */
    public static int setaudit(MemorySegment x0) {
        var mh$ = setaudit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setaudit", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int boolean_t
     * }
     */
    public static final OfInt boolean_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t natural_t
     * }
     */
    public static final OfInt natural_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int integer_t
     * }
     */
    public static final OfInt integer_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t vm_offset_t
     * }
     */
    public static final OfLong vm_offset_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t vm_size_t
     * }
     */
    public static final OfLong vm_size_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t mach_vm_address_t
     * }
     */
    public static final OfLong mach_vm_address_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t mach_vm_offset_t
     * }
     */
    public static final OfLong mach_vm_offset_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t mach_vm_size_t
     * }
     */
    public static final OfLong mach_vm_size_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_map_offset_t
     * }
     */
    public static final OfLong vm_map_offset_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_map_address_t
     * }
     */
    public static final OfLong vm_map_address_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_map_size_t
     * }
     */
    public static final OfLong vm_map_size_t = sysctl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_offset_t
     * }
     */
    public static final OfInt vm32_offset_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_address_t
     * }
     */
    public static final OfInt vm32_address_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_size_t
     * }
     */
    public static final OfInt vm32_size_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef vm_offset_t mach_port_context_t
     * }
     */
    public static final OfLong mach_port_context_t = sysctl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_name_t
     * }
     */
    public static final OfInt mach_port_name_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_name_t *mach_port_name_array_t
     * }
     */
    public static final AddressLayout mach_port_name_array_t = sysctl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_t mach_port_t
     * }
     */
    public static final OfInt mach_port_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t *mach_port_array_t
     * }
     */
    public static final AddressLayout mach_port_array_t = sysctl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_right_t
     * }
     */
    public static final OfInt mach_port_right_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_type_t
     * }
     */
    public static final OfInt mach_port_type_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_type_t *mach_port_type_array_t
     * }
     */
    public static final AddressLayout mach_port_type_array_t = sysctl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_urefs_t
     * }
     */
    public static final OfInt mach_port_urefs_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_port_delta_t
     * }
     */
    public static final OfInt mach_port_delta_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_seqno_t
     * }
     */
    public static final OfInt mach_port_seqno_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_mscount_t
     * }
     */
    public static final OfInt mach_port_mscount_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_msgcount_t
     * }
     */
    public static final OfInt mach_port_msgcount_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_rights_t
     * }
     */
    public static final OfInt mach_port_rights_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_port_srights_t
     * }
     */
    public static final OfInt mach_port_srights_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *mach_port_info_t
     * }
     */
    public static final AddressLayout mach_port_info_t = sysctl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int mach_port_flavor_t
     * }
     */
    public static final OfInt mach_port_flavor_t = sysctl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct mach_service_port_info {
     *     char mspi_string_name[255];
     *     uint8_t mspi_domain_type;
     * } *mach_service_port_info_t
     * }
     */
    public static final AddressLayout mach_service_port_info_t = sysctl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef mach_port_options_t *mach_port_options_ptr_t
     * }
     */
    public static final AddressLayout mach_port_options_ptr_t = sysctl_h.C_POINTER;

    private static final int kGUARD_EXC_DESTROY = (int) 1L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_DESTROY = 1
     * }
     */
    public static int kGUARD_EXC_DESTROY() {
        return kGUARD_EXC_DESTROY;
    }

    private static final int kGUARD_EXC_MOD_REFS = (int) 2L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MOD_REFS = 2
     * }
     */
    public static int kGUARD_EXC_MOD_REFS() {
        return kGUARD_EXC_MOD_REFS;
    }

    private static final int kGUARD_EXC_INVALID_OPTIONS = (int) 3L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_OPTIONS = 3
     * }
     */
    public static int kGUARD_EXC_INVALID_OPTIONS() {
        return kGUARD_EXC_INVALID_OPTIONS;
    }

    private static final int kGUARD_EXC_SET_CONTEXT = (int) 4L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SET_CONTEXT = 4
     * }
     */
    public static int kGUARD_EXC_SET_CONTEXT() {
        return kGUARD_EXC_SET_CONTEXT;
    }

    private static final int kGUARD_EXC_THREAD_SET_STATE = (int) 5L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_THREAD_SET_STATE = 5
     * }
     */
    public static int kGUARD_EXC_THREAD_SET_STATE() {
        return kGUARD_EXC_THREAD_SET_STATE;
    }

    private static final int kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE = (int) 6L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE = 6
     * }
     */
    public static int kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE() {
        return kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE;
    }

    private static final int kGUARD_EXC_UNGUARDED = (int) 8L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_UNGUARDED = 8
     * }
     */
    public static int kGUARD_EXC_UNGUARDED() {
        return kGUARD_EXC_UNGUARDED;
    }

    private static final int kGUARD_EXC_INCORRECT_GUARD = (int) 16L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INCORRECT_GUARD = 16
     * }
     */
    public static int kGUARD_EXC_INCORRECT_GUARD() {
        return kGUARD_EXC_INCORRECT_GUARD;
    }

    private static final int kGUARD_EXC_IMMOVABLE = (int) 32L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_IMMOVABLE = 32
     * }
     */
    public static int kGUARD_EXC_IMMOVABLE() {
        return kGUARD_EXC_IMMOVABLE;
    }

    private static final int kGUARD_EXC_STRICT_REPLY = (int) 64L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_STRICT_REPLY = 64
     * }
     */
    public static int kGUARD_EXC_STRICT_REPLY() {
        return kGUARD_EXC_STRICT_REPLY;
    }

    private static final int kGUARD_EXC_MSG_FILTERED = (int) 128L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MSG_FILTERED = 128
     * }
     */
    public static int kGUARD_EXC_MSG_FILTERED() {
        return kGUARD_EXC_MSG_FILTERED;
    }

    private static final int kGUARD_EXC_INVALID_RIGHT = (int) 256L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_RIGHT = 256
     * }
     */
    public static int kGUARD_EXC_INVALID_RIGHT() {
        return kGUARD_EXC_INVALID_RIGHT;
    }

    private static final int kGUARD_EXC_INVALID_NAME = (int) 512L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_NAME = 512
     * }
     */
    public static int kGUARD_EXC_INVALID_NAME() {
        return kGUARD_EXC_INVALID_NAME;
    }

    private static final int kGUARD_EXC_INVALID_VALUE = (int) 1024L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_VALUE = 1024
     * }
     */
    public static int kGUARD_EXC_INVALID_VALUE() {
        return kGUARD_EXC_INVALID_VALUE;
    }

    private static final int kGUARD_EXC_INVALID_ARGUMENT = (int) 2048L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_ARGUMENT = 2048
     * }
     */
    public static int kGUARD_EXC_INVALID_ARGUMENT() {
        return kGUARD_EXC_INVALID_ARGUMENT;
    }

    private static final int kGUARD_EXC_RIGHT_EXISTS = (int) 4096L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RIGHT_EXISTS = 4096
     * }
     */
    public static int kGUARD_EXC_RIGHT_EXISTS() {
        return kGUARD_EXC_RIGHT_EXISTS;
    }

    private static final int kGUARD_EXC_KERN_NO_SPACE = (int) 8192L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_NO_SPACE = 8192
     * }
     */
    public static int kGUARD_EXC_KERN_NO_SPACE() {
        return kGUARD_EXC_KERN_NO_SPACE;
    }

    private static final int kGUARD_EXC_KERN_FAILURE = (int) 16384L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_FAILURE = 16384
     * }
     */
    public static int kGUARD_EXC_KERN_FAILURE() {
        return kGUARD_EXC_KERN_FAILURE;
    }

    private static final int kGUARD_EXC_KERN_RESOURCE = (int) 32768L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_RESOURCE = 32768
     * }
     */
    public static int kGUARD_EXC_KERN_RESOURCE() {
        return kGUARD_EXC_KERN_RESOURCE;
    }

    private static final int kGUARD_EXC_SEND_INVALID_REPLY = (int) 65536L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_REPLY = 65536
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_REPLY() {
        return kGUARD_EXC_SEND_INVALID_REPLY;
    }

    private static final int kGUARD_EXC_SEND_INVALID_VOUCHER = (int) 131072L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_VOUCHER = 131072
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_VOUCHER() {
        return kGUARD_EXC_SEND_INVALID_VOUCHER;
    }

    private static final int kGUARD_EXC_SEND_INVALID_RIGHT = (int) 262144L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_RIGHT = 262144
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_RIGHT() {
        return kGUARD_EXC_SEND_INVALID_RIGHT;
    }

    private static final int kGUARD_EXC_RCV_INVALID_NAME = (int) 524288L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RCV_INVALID_NAME = 524288
     * }
     */
    public static int kGUARD_EXC_RCV_INVALID_NAME() {
        return kGUARD_EXC_RCV_INVALID_NAME;
    }

    private static final int kGUARD_EXC_RCV_GUARDED_DESC = (int) 1048576L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RCV_GUARDED_DESC = 1048576
     * }
     */
    public static int kGUARD_EXC_RCV_GUARDED_DESC() {
        return kGUARD_EXC_RCV_GUARDED_DESC;
    }

    private static final int kGUARD_EXC_MOD_REFS_NON_FATAL = (int) 2097152L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MOD_REFS_NON_FATAL = 2097152
     * }
     */
    public static int kGUARD_EXC_MOD_REFS_NON_FATAL() {
        return kGUARD_EXC_MOD_REFS_NON_FATAL;
    }

    private static final int kGUARD_EXC_IMMOVABLE_NON_FATAL = (int) 4194304L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_IMMOVABLE_NON_FATAL = 4194304
     * }
     */
    public static int kGUARD_EXC_IMMOVABLE_NON_FATAL() {
        return kGUARD_EXC_IMMOVABLE_NON_FATAL;
    }

    private static final int kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS = (int) 8388608L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS = 8388608
     * }
     */
    public static int kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS() {
        return kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS;
    }

    private static class audit_session_self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_INT);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("audit_session_self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mach_port_name_t audit_session_self()
     * }
     */
    public static FunctionDescriptor audit_session_self$descriptor() {
        return audit_session_self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mach_port_name_t audit_session_self()
     * }
     */
    public static MethodHandle audit_session_self$handle() {
        return audit_session_self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mach_port_name_t audit_session_self()
     * }
     */
    public static MemorySegment audit_session_self$address() {
        return audit_session_self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mach_port_name_t audit_session_self()
     * }
     */
    public static int audit_session_self() {
        var mh$ = audit_session_self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("audit_session_self");
            }
            return (int) mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class audit_session_join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_INT);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("audit_session_join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * au_asid_t audit_session_join(mach_port_name_t port)
     * }
     */
    public static FunctionDescriptor audit_session_join$descriptor() {
        return audit_session_join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * au_asid_t audit_session_join(mach_port_name_t port)
     * }
     */
    public static MethodHandle audit_session_join$handle() {
        return audit_session_join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * au_asid_t audit_session_join(mach_port_name_t port)
     * }
     */
    public static MemorySegment audit_session_join$address() {
        return audit_session_join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * au_asid_t audit_session_join(mach_port_name_t port)
     * }
     */
    public static int audit_session_join(int port) {
        var mh$ = audit_session_join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("audit_session_join", port);
            }
            return (int) mh$.invokeExact(port);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class audit_session_port {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_INT, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("audit_session_port");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int audit_session_port(au_asid_t asid, mach_port_name_t *portname)
     * }
     */
    public static FunctionDescriptor audit_session_port$descriptor() {
        return audit_session_port.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int audit_session_port(au_asid_t asid, mach_port_name_t *portname)
     * }
     */
    public static MethodHandle audit_session_port$handle() {
        return audit_session_port.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int audit_session_port(au_asid_t asid, mach_port_name_t *portname)
     * }
     */
    public static MemorySegment audit_session_port$address() {
        return audit_session_port.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int audit_session_port(au_asid_t asid, mach_port_name_t *portname)
     * }
     */
    public static int audit_session_port(int asid, MemorySegment portname) {
        var mh$ = audit_session_port.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("audit_session_port", asid, portname);
            }
            return (int) mh$.invokeExact(asid, portname);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ucred *kauth_cred_t
     * }
     */
    public static final AddressLayout kauth_cred_t = sysctl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct posix_cred *posix_cred_t
     * }
     */
    public static final AddressLayout posix_cred_t = sysctl_h.C_POINTER;

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                sysctl_h.C_INT,
                sysctl_h.C_INT,
                sysctl_h.C_POINTER,
                sysctl_h.C_POINTER,
                sysctl_h.C_POINTER,
                sysctl_h.C_POINTER,
                sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static int pselect(
            int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", x0, x1, x2, x3, x4, x5);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static final int eNoteReapDeprecated = (int) 268435456L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.eNoteReapDeprecated = 268435456
     * }
     */
    public static int eNoteReapDeprecated() {
        return eNoteReapDeprecated;
    }

    private static final int eNoteExitReparentedDeprecated = (int) 524288L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.eNoteExitReparentedDeprecated = 524288
     * }
     */
    public static int eNoteExitReparentedDeprecated() {
        return eNoteExitReparentedDeprecated;
    }

    private static class kqueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(sysctl_h.C_INT);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("kqueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int kqueue()
     * }
     */
    public static FunctionDescriptor kqueue$descriptor() {
        return kqueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int kqueue()
     * }
     */
    public static MethodHandle kqueue$handle() {
        return kqueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int kqueue()
     * }
     */
    public static MemorySegment kqueue$address() {
        return kqueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int kqueue()
     * }
     */
    public static int kqueue() {
        var mh$ = kqueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("kqueue");
            }
            return (int) mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class kevent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                sysctl_h.C_INT,
                sysctl_h.C_INT,
                sysctl_h.C_POINTER,
                sysctl_h.C_INT,
                sysctl_h.C_POINTER,
                sysctl_h.C_INT,
                sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("kevent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)
     * }
     */
    public static FunctionDescriptor kevent$descriptor() {
        return kevent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)
     * }
     */
    public static MethodHandle kevent$handle() {
        return kevent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)
     * }
     */
    public static MemorySegment kevent$address() {
        return kevent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)
     * }
     */
    public static int kevent(
            int kq,
            MemorySegment changelist,
            int nchanges,
            MemorySegment eventlist,
            int nevents,
            MemorySegment timeout) {
        var mh$ = kevent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("kevent", kq, changelist, nchanges, eventlist, nevents, timeout);
            }
            return (int) mh$.invokeExact(kq, changelist, nchanges, eventlist, nevents, timeout);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class kevent64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                sysctl_h.C_INT,
                sysctl_h.C_INT,
                sysctl_h.C_POINTER,
                sysctl_h.C_INT,
                sysctl_h.C_POINTER,
                sysctl_h.C_INT,
                sysctl_h.C_INT,
                sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("kevent64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int kevent64(int kq, const struct kevent64_s *changelist, int nchanges, struct kevent64_s *eventlist, int nevents, unsigned int flags, const struct timespec *timeout)
     * }
     */
    public static FunctionDescriptor kevent64$descriptor() {
        return kevent64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int kevent64(int kq, const struct kevent64_s *changelist, int nchanges, struct kevent64_s *eventlist, int nevents, unsigned int flags, const struct timespec *timeout)
     * }
     */
    public static MethodHandle kevent64$handle() {
        return kevent64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int kevent64(int kq, const struct kevent64_s *changelist, int nchanges, struct kevent64_s *eventlist, int nevents, unsigned int flags, const struct timespec *timeout)
     * }
     */
    public static MemorySegment kevent64$address() {
        return kevent64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int kevent64(int kq, const struct kevent64_s *changelist, int nchanges, struct kevent64_s *eventlist, int nevents, unsigned int flags, const struct timespec *timeout)
     * }
     */
    public static int kevent64(
            int kq,
            MemorySegment changelist,
            int nchanges,
            MemorySegment eventlist,
            int nevents,
            int flags,
            MemorySegment timeout) {
        var mh$ = kevent64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("kevent64", kq, changelist, nchanges, eventlist, nevents, flags, timeout);
            }
            return (int) mh$.invokeExact(kq, changelist, nchanges, eventlist, nevents, flags, timeout);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class averunnable$constants {
        public static final GroupLayout LAYOUT = loadavg.layout();
        public static final MemorySegment SEGMENT =
                sysctl_h.findOrThrow("averunnable").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern struct loadavg averunnable
     * }
     */
    public static GroupLayout averunnable$layout() {
        return averunnable$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern struct loadavg averunnable
     * }
     */
    public static MemorySegment averunnable() {
        return averunnable$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern struct loadavg averunnable
     * }
     */
    public static void averunnable(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, averunnable$constants.SEGMENT, 0L, averunnable$constants.LAYOUT.byteSize());
    }

    private static class sysctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                sysctl_h.C_INT,
                sysctl_h.C_POINTER,
                sysctl_h.C_INT,
                sysctl_h.C_POINTER,
                sysctl_h.C_POINTER,
                sysctl_h.C_POINTER,
                sysctl_h.C_LONG);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("sysctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sysctl(int *, u_int, void *, size_t *, void *, size_t)
     * }
     */
    public static FunctionDescriptor sysctl$descriptor() {
        return sysctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sysctl(int *, u_int, void *, size_t *, void *, size_t)
     * }
     */
    public static MethodHandle sysctl$handle() {
        return sysctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sysctl(int *, u_int, void *, size_t *, void *, size_t)
     * }
     */
    public static MemorySegment sysctl$address() {
        return sysctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sysctl(int *, u_int, void *, size_t *, void *, size_t)
     * }
     */
    public static int sysctl(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = sysctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sysctl", x0, x1, x2, x3, x4, x5);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sysctlbyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                sysctl_h.C_INT,
                sysctl_h.C_POINTER,
                sysctl_h.C_POINTER,
                sysctl_h.C_POINTER,
                sysctl_h.C_POINTER,
                sysctl_h.C_LONG);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("sysctlbyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sysctlbyname(const char *, void *, size_t *, void *, size_t)
     * }
     */
    public static FunctionDescriptor sysctlbyname$descriptor() {
        return sysctlbyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sysctlbyname(const char *, void *, size_t *, void *, size_t)
     * }
     */
    public static MethodHandle sysctlbyname$handle() {
        return sysctlbyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sysctlbyname(const char *, void *, size_t *, void *, size_t)
     * }
     */
    public static MemorySegment sysctlbyname$address() {
        return sysctlbyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sysctlbyname(const char *, void *, size_t *, void *, size_t)
     * }
     */
    public static int sysctlbyname(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4) {
        var mh$ = sysctlbyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sysctlbyname", x0, x1, x2, x3, x4);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sysctlnametomib {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(sysctl_h.C_INT, sysctl_h.C_POINTER, sysctl_h.C_POINTER, sysctl_h.C_POINTER);

        public static final MemorySegment ADDR = sysctl_h.findOrThrow("sysctlnametomib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sysctlnametomib(const char *, int *, size_t *)
     * }
     */
    public static FunctionDescriptor sysctlnametomib$descriptor() {
        return sysctlnametomib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sysctlnametomib(const char *, int *, size_t *)
     * }
     */
    public static MethodHandle sysctlnametomib$handle() {
        return sysctlnametomib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sysctlnametomib(const char *, int *, size_t *)
     * }
     */
    public static MemorySegment sysctlnametomib$address() {
        return sysctlnametomib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sysctlnametomib(const char *, int *, size_t *)
     * }
     */
    public static int sysctlnametomib(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = sysctlnametomib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sysctlnametomib", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN = sysctl_h.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }

    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }

    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }

    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }

    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }

    private static final int MAC_OS_X_VERSION_10_0 = (int) 1000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_0 1000
     * }
     */
    public static int MAC_OS_X_VERSION_10_0() {
        return MAC_OS_X_VERSION_10_0;
    }

    private static final int MAC_OS_X_VERSION_10_1 = (int) 1010L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_1 1010
     * }
     */
    public static int MAC_OS_X_VERSION_10_1() {
        return MAC_OS_X_VERSION_10_1;
    }

    private static final int MAC_OS_X_VERSION_10_2 = (int) 1020L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_2 1020
     * }
     */
    public static int MAC_OS_X_VERSION_10_2() {
        return MAC_OS_X_VERSION_10_2;
    }

    private static final int MAC_OS_X_VERSION_10_3 = (int) 1030L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_3 1030
     * }
     */
    public static int MAC_OS_X_VERSION_10_3() {
        return MAC_OS_X_VERSION_10_3;
    }

    private static final int MAC_OS_X_VERSION_10_4 = (int) 1040L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_4 1040
     * }
     */
    public static int MAC_OS_X_VERSION_10_4() {
        return MAC_OS_X_VERSION_10_4;
    }

    private static final int MAC_OS_X_VERSION_10_5 = (int) 1050L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_5 1050
     * }
     */
    public static int MAC_OS_X_VERSION_10_5() {
        return MAC_OS_X_VERSION_10_5;
    }

    private static final int MAC_OS_X_VERSION_10_6 = (int) 1060L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_6 1060
     * }
     */
    public static int MAC_OS_X_VERSION_10_6() {
        return MAC_OS_X_VERSION_10_6;
    }

    private static final int MAC_OS_X_VERSION_10_7 = (int) 1070L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_7 1070
     * }
     */
    public static int MAC_OS_X_VERSION_10_7() {
        return MAC_OS_X_VERSION_10_7;
    }

    private static final int MAC_OS_X_VERSION_10_8 = (int) 1080L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_8 1080
     * }
     */
    public static int MAC_OS_X_VERSION_10_8() {
        return MAC_OS_X_VERSION_10_8;
    }

    private static final int MAC_OS_X_VERSION_10_9 = (int) 1090L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_9 1090
     * }
     */
    public static int MAC_OS_X_VERSION_10_9() {
        return MAC_OS_X_VERSION_10_9;
    }

    private static final int MAC_OS_X_VERSION_10_10 = (int) 101000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10 101000
     * }
     */
    public static int MAC_OS_X_VERSION_10_10() {
        return MAC_OS_X_VERSION_10_10;
    }

    private static final int MAC_OS_X_VERSION_10_10_2 = (int) 101002L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_2 101002
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_2() {
        return MAC_OS_X_VERSION_10_10_2;
    }

    private static final int MAC_OS_X_VERSION_10_10_3 = (int) 101003L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_3 101003
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_3() {
        return MAC_OS_X_VERSION_10_10_3;
    }

    private static final int MAC_OS_X_VERSION_10_11 = (int) 101100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11 101100
     * }
     */
    public static int MAC_OS_X_VERSION_10_11() {
        return MAC_OS_X_VERSION_10_11;
    }

    private static final int MAC_OS_X_VERSION_10_11_2 = (int) 101102L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_2 101102
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_2() {
        return MAC_OS_X_VERSION_10_11_2;
    }

    private static final int MAC_OS_X_VERSION_10_11_3 = (int) 101103L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_3 101103
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_3() {
        return MAC_OS_X_VERSION_10_11_3;
    }

    private static final int MAC_OS_X_VERSION_10_11_4 = (int) 101104L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_4 101104
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_4() {
        return MAC_OS_X_VERSION_10_11_4;
    }

    private static final int MAC_OS_X_VERSION_10_12 = (int) 101200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12 101200
     * }
     */
    public static int MAC_OS_X_VERSION_10_12() {
        return MAC_OS_X_VERSION_10_12;
    }

    private static final int MAC_OS_X_VERSION_10_12_1 = (int) 101201L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_1 101201
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_1() {
        return MAC_OS_X_VERSION_10_12_1;
    }

    private static final int MAC_OS_X_VERSION_10_12_2 = (int) 101202L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_2 101202
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_2() {
        return MAC_OS_X_VERSION_10_12_2;
    }

    private static final int MAC_OS_X_VERSION_10_12_4 = (int) 101204L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_4 101204
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_4() {
        return MAC_OS_X_VERSION_10_12_4;
    }

    private static final int MAC_OS_X_VERSION_10_13 = (int) 101300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13 101300
     * }
     */
    public static int MAC_OS_X_VERSION_10_13() {
        return MAC_OS_X_VERSION_10_13;
    }

    private static final int MAC_OS_X_VERSION_10_13_1 = (int) 101301L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_1 101301
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_1() {
        return MAC_OS_X_VERSION_10_13_1;
    }

    private static final int MAC_OS_X_VERSION_10_13_2 = (int) 101302L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_2 101302
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_2() {
        return MAC_OS_X_VERSION_10_13_2;
    }

    private static final int MAC_OS_X_VERSION_10_13_4 = (int) 101304L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_4 101304
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_4() {
        return MAC_OS_X_VERSION_10_13_4;
    }

    private static final int MAC_OS_X_VERSION_10_14 = (int) 101400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14 101400
     * }
     */
    public static int MAC_OS_X_VERSION_10_14() {
        return MAC_OS_X_VERSION_10_14;
    }

    private static final int MAC_OS_X_VERSION_10_14_1 = (int) 101401L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_1 101401
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_1() {
        return MAC_OS_X_VERSION_10_14_1;
    }

    private static final int MAC_OS_X_VERSION_10_14_4 = (int) 101404L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_4 101404
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_4() {
        return MAC_OS_X_VERSION_10_14_4;
    }

    private static final int MAC_OS_X_VERSION_10_14_5 = (int) 101405L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_5 101405
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_5() {
        return MAC_OS_X_VERSION_10_14_5;
    }

    private static final int MAC_OS_X_VERSION_10_14_6 = (int) 101406L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_6 101406
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_6() {
        return MAC_OS_X_VERSION_10_14_6;
    }

    private static final int MAC_OS_X_VERSION_10_15 = (int) 101500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15 101500
     * }
     */
    public static int MAC_OS_X_VERSION_10_15() {
        return MAC_OS_X_VERSION_10_15;
    }

    private static final int MAC_OS_X_VERSION_10_15_1 = (int) 101501L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_1 101501
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_1() {
        return MAC_OS_X_VERSION_10_15_1;
    }

    private static final int MAC_OS_X_VERSION_10_15_4 = (int) 101504L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_4 101504
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_4() {
        return MAC_OS_X_VERSION_10_15_4;
    }

    private static final int MAC_OS_X_VERSION_10_16 = (int) 101600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_16 101600
     * }
     */
    public static int MAC_OS_X_VERSION_10_16() {
        return MAC_OS_X_VERSION_10_16;
    }

    private static final int MAC_OS_VERSION_11_0 = (int) 110000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_0 110000
     * }
     */
    public static int MAC_OS_VERSION_11_0() {
        return MAC_OS_VERSION_11_0;
    }

    private static final int MAC_OS_VERSION_11_1 = (int) 110100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_1 110100
     * }
     */
    public static int MAC_OS_VERSION_11_1() {
        return MAC_OS_VERSION_11_1;
    }

    private static final int MAC_OS_VERSION_11_3 = (int) 110300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_3 110300
     * }
     */
    public static int MAC_OS_VERSION_11_3() {
        return MAC_OS_VERSION_11_3;
    }

    private static final int MAC_OS_VERSION_11_4 = (int) 110400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_4 110400
     * }
     */
    public static int MAC_OS_VERSION_11_4() {
        return MAC_OS_VERSION_11_4;
    }

    private static final int MAC_OS_VERSION_11_5 = (int) 110500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_5 110500
     * }
     */
    public static int MAC_OS_VERSION_11_5() {
        return MAC_OS_VERSION_11_5;
    }

    private static final int MAC_OS_VERSION_11_6 = (int) 110600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_6 110600
     * }
     */
    public static int MAC_OS_VERSION_11_6() {
        return MAC_OS_VERSION_11_6;
    }

    private static final int MAC_OS_VERSION_12_0 = (int) 120000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_0 120000
     * }
     */
    public static int MAC_OS_VERSION_12_0() {
        return MAC_OS_VERSION_12_0;
    }

    private static final int MAC_OS_VERSION_12_1 = (int) 120100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_1 120100
     * }
     */
    public static int MAC_OS_VERSION_12_1() {
        return MAC_OS_VERSION_12_1;
    }

    private static final int MAC_OS_VERSION_12_2 = (int) 120200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_2 120200
     * }
     */
    public static int MAC_OS_VERSION_12_2() {
        return MAC_OS_VERSION_12_2;
    }

    private static final int MAC_OS_VERSION_12_3 = (int) 120300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_3 120300
     * }
     */
    public static int MAC_OS_VERSION_12_3() {
        return MAC_OS_VERSION_12_3;
    }

    private static final int MAC_OS_VERSION_12_4 = (int) 120400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_4 120400
     * }
     */
    public static int MAC_OS_VERSION_12_4() {
        return MAC_OS_VERSION_12_4;
    }

    private static final int MAC_OS_VERSION_12_5 = (int) 120500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_5 120500
     * }
     */
    public static int MAC_OS_VERSION_12_5() {
        return MAC_OS_VERSION_12_5;
    }

    private static final int MAC_OS_VERSION_12_6 = (int) 120600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_6 120600
     * }
     */
    public static int MAC_OS_VERSION_12_6() {
        return MAC_OS_VERSION_12_6;
    }

    private static final int MAC_OS_VERSION_12_7 = (int) 120700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_7 120700
     * }
     */
    public static int MAC_OS_VERSION_12_7() {
        return MAC_OS_VERSION_12_7;
    }

    private static final int MAC_OS_VERSION_13_0 = (int) 130000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_0 130000
     * }
     */
    public static int MAC_OS_VERSION_13_0() {
        return MAC_OS_VERSION_13_0;
    }

    private static final int MAC_OS_VERSION_13_1 = (int) 130100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_1 130100
     * }
     */
    public static int MAC_OS_VERSION_13_1() {
        return MAC_OS_VERSION_13_1;
    }

    private static final int MAC_OS_VERSION_13_2 = (int) 130200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_2 130200
     * }
     */
    public static int MAC_OS_VERSION_13_2() {
        return MAC_OS_VERSION_13_2;
    }

    private static final int MAC_OS_VERSION_13_3 = (int) 130300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_3 130300
     * }
     */
    public static int MAC_OS_VERSION_13_3() {
        return MAC_OS_VERSION_13_3;
    }

    private static final int MAC_OS_VERSION_13_4 = (int) 130400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_4 130400
     * }
     */
    public static int MAC_OS_VERSION_13_4() {
        return MAC_OS_VERSION_13_4;
    }

    private static final int MAC_OS_VERSION_13_5 = (int) 130500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_5 130500
     * }
     */
    public static int MAC_OS_VERSION_13_5() {
        return MAC_OS_VERSION_13_5;
    }

    private static final int MAC_OS_VERSION_13_6 = (int) 130600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_6 130600
     * }
     */
    public static int MAC_OS_VERSION_13_6() {
        return MAC_OS_VERSION_13_6;
    }

    private static final int MAC_OS_VERSION_14_0 = (int) 140000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_0 140000
     * }
     */
    public static int MAC_OS_VERSION_14_0() {
        return MAC_OS_VERSION_14_0;
    }

    private static final int MAC_OS_VERSION_14_1 = (int) 140100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_1 140100
     * }
     */
    public static int MAC_OS_VERSION_14_1() {
        return MAC_OS_VERSION_14_1;
    }

    private static final int MAC_OS_VERSION_14_2 = (int) 140200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_2 140200
     * }
     */
    public static int MAC_OS_VERSION_14_2() {
        return MAC_OS_VERSION_14_2;
    }

    private static final int MAC_OS_VERSION_14_3 = (int) 140300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_3 140300
     * }
     */
    public static int MAC_OS_VERSION_14_3() {
        return MAC_OS_VERSION_14_3;
    }

    private static final int MAC_OS_VERSION_14_4 = (int) 140400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_4 140400
     * }
     */
    public static int MAC_OS_VERSION_14_4() {
        return MAC_OS_VERSION_14_4;
    }

    private static final int __MAC_OS_X_VERSION_MAX_ALLOWED = (int) 140400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_OS_X_VERSION_MAX_ALLOWED 140400
     * }
     */
    public static int __MAC_OS_X_VERSION_MAX_ALLOWED() {
        return __MAC_OS_X_VERSION_MAX_ALLOWED;
    }

    private static final long USER_ADDR_NULL = 0L;
    /**
     * {@snippet lang=c :
     * #define USER_ADDR_NULL 0
     * }
     */
    public static long USER_ADDR_NULL() {
        return USER_ADDR_NULL;
    }

    private static final long __DARWIN_NFDBITS = 32L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NFDBITS 32
     * }
     */
    public static long __DARWIN_NFDBITS() {
        return __DARWIN_NFDBITS;
    }

    private static final int FD_SETSIZE = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define FD_SETSIZE 1024
     * }
     */
    public static int FD_SETSIZE() {
        return FD_SETSIZE;
    }

    private static final int __DARWIN_WCHAR_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MAX 2147483647
     * }
     */
    public static int __DARWIN_WCHAR_MAX() {
        return __DARWIN_WCHAR_MAX;
    }

    private static final int __DARWIN_WCHAR_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MIN -2147483648
     * }
     */
    public static int __DARWIN_WCHAR_MIN() {
        return __DARWIN_WCHAR_MIN;
    }

    private static final int __DARWIN_WEOF = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WEOF -1
     * }
     */
    public static int __DARWIN_WEOF() {
        return __DARWIN_WEOF;
    }

    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }

    private static final long CLOCKS_PER_SEC = 1000000L;
    /**
     * {@snippet lang=c :
     * #define CLOCKS_PER_SEC 1000000
     * }
     */
    public static long CLOCKS_PER_SEC() {
        return CLOCKS_PER_SEC;
    }

    private static final int CLOCK_REALTIME = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME 0
     * }
     */
    public static int CLOCK_REALTIME() {
        return CLOCK_REALTIME;
    }

    private static final int CLOCK_MONOTONIC = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC 6
     * }
     */
    public static int CLOCK_MONOTONIC() {
        return CLOCK_MONOTONIC;
    }

    private static final int CLOCK_MONOTONIC_RAW = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_RAW 4
     * }
     */
    public static int CLOCK_MONOTONIC_RAW() {
        return CLOCK_MONOTONIC_RAW;
    }

    private static final int CLOCK_MONOTONIC_RAW_APPROX = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_RAW_APPROX 5
     * }
     */
    public static int CLOCK_MONOTONIC_RAW_APPROX() {
        return CLOCK_MONOTONIC_RAW_APPROX;
    }

    private static final int CLOCK_UPTIME_RAW = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_UPTIME_RAW 8
     * }
     */
    public static int CLOCK_UPTIME_RAW() {
        return CLOCK_UPTIME_RAW;
    }

    private static final int CLOCK_UPTIME_RAW_APPROX = (int) 9L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_UPTIME_RAW_APPROX 9
     * }
     */
    public static int CLOCK_UPTIME_RAW_APPROX() {
        return CLOCK_UPTIME_RAW_APPROX;
    }

    private static final int CLOCK_PROCESS_CPUTIME_ID = (int) 12L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_PROCESS_CPUTIME_ID 12
     * }
     */
    public static int CLOCK_PROCESS_CPUTIME_ID() {
        return CLOCK_PROCESS_CPUTIME_ID;
    }

    private static final int CLOCK_THREAD_CPUTIME_ID = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_THREAD_CPUTIME_ID 16
     * }
     */
    public static int CLOCK_THREAD_CPUTIME_ID() {
        return CLOCK_THREAD_CPUTIME_ID;
    }

    private static final int __DARWIN_BYTE_ORDER = (int) 1234L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_BYTE_ORDER 1234
     * }
     */
    public static int __DARWIN_BYTE_ORDER() {
        return __DARWIN_BYTE_ORDER;
    }

    private static final int LITTLE_ENDIAN = (int) 1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }

    private static final int BIG_ENDIAN = (int) 4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }

    private static final int PDP_ENDIAN = (int) 3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }

    private static final int BYTE_ORDER = (int) 1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }

    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }

    private static final int INT8_MIN = (int) -128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }

    private static final int INT16_MIN = (int) -32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }

    private static final int INT32_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }

    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }

    private static final int UINT32_MAX = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }

    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }

    private static final int INT_LEAST8_MIN = (int) -128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }

    private static final int INT_LEAST16_MIN = (int) -32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }

    private static final int INT_LEAST32_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }

    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }

    private static final int INT_LEAST8_MAX = (int) 127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }

    private static final int INT_LEAST16_MAX = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }

    private static final int INT_LEAST32_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }

    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }

    private static final int UINT_LEAST8_MAX = (int) 255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }

    private static final int UINT_LEAST16_MAX = (int) 65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }

    private static final int UINT_LEAST32_MAX = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }

    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }

    private static final int INT_FAST8_MIN = (int) -128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }

    private static final int INT_FAST16_MIN = (int) -32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }

    private static final int INT_FAST32_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }

    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }

    private static final int INT_FAST8_MAX = (int) 127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }

    private static final int INT_FAST16_MAX = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }

    private static final int INT_FAST32_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }

    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }

    private static final int UINT_FAST8_MAX = (int) 255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }

    private static final int UINT_FAST16_MAX = (int) 65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }

    private static final int UINT_FAST32_MAX = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }

    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }

    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }

    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }

    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }

    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }

    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }

    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }

    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }

    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }

    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }

    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }

    private static final int WCHAR_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }

    private static final int WCHAR_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }

    private static final int WINT_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }

    private static final int WINT_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }

    private static final int SIG_ATOMIC_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }

    private static final int SIG_ATOMIC_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }

    private static final int NBBY = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define NBBY 8
     * }
     */
    public static int NBBY() {
        return NBBY;
    }

    private static final long NFDBITS = 32L;
    /**
     * {@snippet lang=c :
     * #define NFDBITS 32
     * }
     */
    public static long NFDBITS() {
        return NFDBITS;
    }

    private static final int ARG_MAX = (int) 1048576L;
    /**
     * {@snippet lang=c :
     * #define ARG_MAX 1048576
     * }
     */
    public static int ARG_MAX() {
        return ARG_MAX;
    }

    private static final int GID_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define GID_MAX 2147483647
     * }
     */
    public static int GID_MAX() {
        return GID_MAX;
    }

    private static final int UID_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define UID_MAX 2147483647
     * }
     */
    public static int UID_MAX() {
        return UID_MAX;
    }

    private static final int MAXUPRC = (int) 266L;
    /**
     * {@snippet lang=c :
     * #define MAXUPRC 266
     * }
     */
    public static int MAXUPRC() {
        return MAXUPRC;
    }

    private static final int NCARGS = (int) 1048576L;
    /**
     * {@snippet lang=c :
     * #define NCARGS 1048576
     * }
     */
    public static int NCARGS() {
        return NCARGS;
    }

    private static final int NGROUPS = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define NGROUPS 16
     * }
     */
    public static int NGROUPS() {
        return NGROUPS;
    }

    private static final long __DARWIN_ALIGNBYTES = 7L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ALIGNBYTES 7
     * }
     */
    public static long __DARWIN_ALIGNBYTES() {
        return __DARWIN_ALIGNBYTES;
    }

    private static final long __DARWIN_ALIGNBYTES32 = 3L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ALIGNBYTES32 3
     * }
     */
    public static long __DARWIN_ALIGNBYTES32() {
        return __DARWIN_ALIGNBYTES32;
    }

    private static final long ALIGNBYTES = 7L;
    /**
     * {@snippet lang=c :
     * #define ALIGNBYTES 7
     * }
     */
    public static long ALIGNBYTES() {
        return ALIGNBYTES;
    }

    private static final int PGOFSET = (int) 4095L;
    /**
     * {@snippet lang=c :
     * #define PGOFSET 4095
     * }
     */
    public static int PGOFSET() {
        return PGOFSET;
    }

    private static final int MAXPHYS = (int) 65536L;
    /**
     * {@snippet lang=c :
     * #define MAXPHYS 65536
     * }
     */
    public static int MAXPHYS() {
        return MAXPHYS;
    }

    private static final int MSIZE = (int) 256L;
    /**
     * {@snippet lang=c :
     * #define MSIZE 256
     * }
     */
    public static int MSIZE() {
        return MSIZE;
    }

    private static final int MCLBYTES = (int) 2048L;
    /**
     * {@snippet lang=c :
     * #define MCLBYTES 2048
     * }
     */
    public static int MCLBYTES() {
        return MCLBYTES;
    }

    private static final int MBIGCLBYTES = (int) 4096L;
    /**
     * {@snippet lang=c :
     * #define MBIGCLBYTES 4096
     * }
     */
    public static int MBIGCLBYTES() {
        return MBIGCLBYTES;
    }

    private static final int M16KCLBYTES = (int) 16384L;
    /**
     * {@snippet lang=c :
     * #define M16KCLBYTES 16384
     * }
     */
    public static int M16KCLBYTES() {
        return M16KCLBYTES;
    }

    private static final int MCLOFSET = (int) 2047L;
    /**
     * {@snippet lang=c :
     * #define MCLOFSET 2047
     * }
     */
    public static int MCLOFSET() {
        return MCLOFSET;
    }

    private static final int CLK_TCK = (int) 100L;
    /**
     * {@snippet lang=c :
     * #define CLK_TCK 100
     * }
     */
    public static int CLK_TCK() {
        return CLK_TCK;
    }

    private static final int SCHAR_MIN = (int) -128L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MIN -128
     * }
     */
    public static int SCHAR_MIN() {
        return SCHAR_MIN;
    }

    private static final int CHAR_MIN = (int) -128L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MIN -128
     * }
     */
    public static int CHAR_MIN() {
        return CHAR_MIN;
    }

    private static final int SHRT_MIN = (int) -32768L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MIN -32768
     * }
     */
    public static int SHRT_MIN() {
        return SHRT_MIN;
    }

    private static final int UINT_MAX = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_MAX 4294967295
     * }
     */
    public static int UINT_MAX() {
        return UINT_MAX;
    }

    private static final int INT_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_MIN -2147483648
     * }
     */
    public static int INT_MIN() {
        return INT_MIN;
    }

    private static final long ULONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_MAX -1
     * }
     */
    public static long ULONG_MAX() {
        return ULONG_MAX;
    }

    private static final long LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_MAX() {
        return LONG_MAX;
    }

    private static final long LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_MIN() {
        return LONG_MIN;
    }

    private static final long ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULLONG_MAX -1
     * }
     */
    public static long ULLONG_MAX() {
        return ULLONG_MAX;
    }

    private static final long LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MAX 9223372036854775807
     * }
     */
    public static long LLONG_MAX() {
        return LLONG_MAX;
    }

    private static final long LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MIN -9223372036854775808
     * }
     */
    public static long LLONG_MIN() {
        return LLONG_MIN;
    }

    private static final long SSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define SSIZE_MAX 9223372036854775807
     * }
     */
    public static long SSIZE_MAX() {
        return SSIZE_MAX;
    }

    private static final long SIZE_T_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_T_MAX -1
     * }
     */
    public static long SIZE_T_MAX() {
        return SIZE_T_MAX;
    }

    private static final long UQUAD_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UQUAD_MAX -1
     * }
     */
    public static long UQUAD_MAX() {
        return UQUAD_MAX;
    }

    private static final long QUAD_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define QUAD_MAX 9223372036854775807
     * }
     */
    public static long QUAD_MAX() {
        return QUAD_MAX;
    }

    private static final long QUAD_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define QUAD_MIN -9223372036854775808
     * }
     */
    public static long QUAD_MIN() {
        return QUAD_MIN;
    }

    private static final int _POSIX_RE_DUP_MAX = (int) 255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX_RE_DUP_MAX() {
        return _POSIX_RE_DUP_MAX;
    }

    private static final long OFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define OFF_MIN -9223372036854775808
     * }
     */
    public static long OFF_MIN() {
        return OFF_MIN;
    }

    private static final long OFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define OFF_MAX 9223372036854775807
     * }
     */
    public static long OFF_MAX() {
        return OFF_MAX;
    }

    private static final int NSIG = (int) 32L;
    /**
     * {@snippet lang=c :
     * #define NSIG 32
     * }
     */
    public static int NSIG() {
        return NSIG;
    }

    private static final int SIGIOT = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define SIGIOT 6
     * }
     */
    public static int SIGIOT() {
        return SIGIOT;
    }

    private static final MemorySegment SIG_DFL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define SIG_DFL (void*) 0
     * }
     */
    public static MemorySegment SIG_DFL() {
        return SIG_DFL;
    }

    private static final MemorySegment SIG_IGN = MemorySegment.ofAddress(1L);
    /**
     * {@snippet lang=c :
     * #define SIG_IGN (void*) 1
     * }
     */
    public static MemorySegment SIG_IGN() {
        return SIG_IGN;
    }

    private static final MemorySegment SIG_HOLD = MemorySegment.ofAddress(5L);
    /**
     * {@snippet lang=c :
     * #define SIG_HOLD (void*) 5
     * }
     */
    public static MemorySegment SIG_HOLD() {
        return SIG_HOLD;
    }

    private static final MemorySegment SIG_ERR = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define SIG_ERR (void*) -1
     * }
     */
    public static MemorySegment SIG_ERR() {
        return SIG_ERR;
    }

    private static final int SA_USERSPACE_MASK = (int) 127L;
    /**
     * {@snippet lang=c :
     * #define SA_USERSPACE_MASK 127
     * }
     */
    public static int SA_USERSPACE_MASK() {
        return SA_USERSPACE_MASK;
    }

    private static final int SV_ONSTACK = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define SV_ONSTACK 1
     * }
     */
    public static int SV_ONSTACK() {
        return SV_ONSTACK;
    }

    private static final int SV_INTERRUPT = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define SV_INTERRUPT 2
     * }
     */
    public static int SV_INTERRUPT() {
        return SV_INTERRUPT;
    }

    private static final int SV_RESETHAND = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define SV_RESETHAND 4
     * }
     */
    public static int SV_RESETHAND() {
        return SV_RESETHAND;
    }

    private static final int SV_NODEFER = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define SV_NODEFER 16
     * }
     */
    public static int SV_NODEFER() {
        return SV_NODEFER;
    }

    private static final int SV_NOCLDSTOP = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define SV_NOCLDSTOP 8
     * }
     */
    public static int SV_NOCLDSTOP() {
        return SV_NOCLDSTOP;
    }

    private static final int SV_SIGINFO = (int) 64L;
    /**
     * {@snippet lang=c :
     * #define SV_SIGINFO 64
     * }
     */
    public static int SV_SIGINFO() {
        return SV_SIGINFO;
    }

    private static final MemorySegment BADSIG = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define BADSIG (void*) -1
     * }
     */
    public static MemorySegment BADSIG() {
        return BADSIG;
    }

    private static final long NBPW = 4L;
    /**
     * {@snippet lang=c :
     * #define NBPW 4
     * }
     */
    public static long NBPW() {
        return NBPW;
    }

    private static final int NODEV = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define NODEV -1
     * }
     */
    public static int NODEV() {
        return NODEV;
    }

    private static final int CLBYTES = (int) 4096L;
    /**
     * {@snippet lang=c :
     * #define CLBYTES 4096
     * }
     */
    public static int CLBYTES() {
        return CLBYTES;
    }

    private static final int CLOFSET = (int) 4095L;
    /**
     * {@snippet lang=c :
     * #define CLOFSET 4095
     * }
     */
    public static int CLOFSET() {
        return CLOFSET;
    }

    private static final int CLOFF = (int) 4095L;
    /**
     * {@snippet lang=c :
     * #define CLOFF 4095
     * }
     */
    public static int CLOFF() {
        return CLOFF;
    }

    private static final int CLSHIFT = (int) 12L;
    /**
     * {@snippet lang=c :
     * #define CLSHIFT 12
     * }
     */
    public static int CLSHIFT() {
        return CLSHIFT;
    }

    private static final int CBQSIZE = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define CBQSIZE 8
     * }
     */
    public static int CBQSIZE() {
        return CBQSIZE;
    }

    private static final long CBSIZE = 48L;
    /**
     * {@snippet lang=c :
     * #define CBSIZE 48
     * }
     */
    public static long CBSIZE() {
        return CBSIZE;
    }

    private static final int CROUND = (int) 63L;
    /**
     * {@snippet lang=c :
     * #define CROUND 63
     * }
     */
    public static int CROUND() {
        return CROUND;
    }

    private static final int MAXBSIZE = (int) 1048576L;
    /**
     * {@snippet lang=c :
     * #define MAXBSIZE 1048576
     * }
     */
    public static int MAXBSIZE() {
        return MAXBSIZE;
    }

    private static final int MAXPHYSIO = (int) 65536L;
    /**
     * {@snippet lang=c :
     * #define MAXPHYSIO 65536
     * }
     */
    public static int MAXPHYSIO() {
        return MAXPHYSIO;
    }

    private static final int MAXPHYSIO_WIRED = (int) 16777216L;
    /**
     * {@snippet lang=c :
     * #define MAXPHYSIO_WIRED 16777216
     * }
     */
    public static int MAXPHYSIO_WIRED() {
        return MAXPHYSIO_WIRED;
    }

    private static final int MAXPATHLEN = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define MAXPATHLEN 1024
     * }
     */
    public static int MAXPATHLEN() {
        return MAXPATHLEN;
    }

    private static final int FSCALE = (int) 2048L;
    /**
     * {@snippet lang=c :
     * #define FSCALE 2048
     * }
     */
    public static int FSCALE() {
        return FSCALE;
    }

    private static final int AUDIT_RECORD_MAGIC = (int) 2190085915L;
    /**
     * {@snippet lang=c :
     * #define AUDIT_RECORD_MAGIC 2190085915
     * }
     */
    public static int AUDIT_RECORD_MAGIC() {
        return AUDIT_RECORD_MAGIC;
    }

    private static final int MAXAUDITDATA = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define MAXAUDITDATA 32767
     * }
     */
    public static int MAXAUDITDATA() {
        return MAXAUDITDATA;
    }

    private static final int MAX_AUDIT_RECORD_SIZE = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define MAX_AUDIT_RECORD_SIZE 32767
     * }
     */
    public static int MAX_AUDIT_RECORD_SIZE() {
        return MAX_AUDIT_RECORD_SIZE;
    }

    private static final int MIN_AUDIT_FILE_SIZE = (int) 524288L;
    /**
     * {@snippet lang=c :
     * #define MIN_AUDIT_FILE_SIZE 524288
     * }
     */
    public static int MIN_AUDIT_FILE_SIZE() {
        return MIN_AUDIT_FILE_SIZE;
    }
    /**
     * {@snippet lang=c :
     * #define AUDITDEV_FILENAME "audit"
     * }
     */
    public static MemorySegment AUDITDEV_FILENAME() {
        class Holder {
            static final MemorySegment AUDITDEV_FILENAME = sysctl_h.LIBRARY_ARENA.allocateFrom("audit");
        }
        return Holder.AUDITDEV_FILENAME;
    }

    private static final int AU_DEFAUDITID = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define AU_DEFAUDITID 4294967295
     * }
     */
    public static int AU_DEFAUDITID() {
        return AU_DEFAUDITID;
    }

    private static final int AU_ASSIGN_ASID = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define AU_ASSIGN_ASID -1
     * }
     */
    public static int AU_ASSIGN_ASID() {
        return AU_ASSIGN_ASID;
    }

    private static final byte AT_IPC_MSG = (byte) 1L;
    /**
     * {@snippet lang=c :
     * #define AT_IPC_MSG 1
     * }
     */
    public static byte AT_IPC_MSG() {
        return AT_IPC_MSG;
    }

    private static final byte AT_IPC_SEM = (byte) 2L;
    /**
     * {@snippet lang=c :
     * #define AT_IPC_SEM 2
     * }
     */
    public static byte AT_IPC_SEM() {
        return AT_IPC_SEM;
    }

    private static final byte AT_IPC_SHM = (byte) 3L;
    /**
     * {@snippet lang=c :
     * #define AT_IPC_SHM 3
     * }
     */
    public static byte AT_IPC_SHM() {
        return AT_IPC_SHM;
    }

    private static final int AUC_DISABLED = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define AUC_DISABLED -1
     * }
     */
    public static int AUC_DISABLED() {
        return AUC_DISABLED;
    }

    private static final int AQ_BUFSZ = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define AQ_BUFSZ 32767
     * }
     */
    public static int AQ_BUFSZ() {
        return AQ_BUFSZ;
    }

    private static final byte AUDIT_CTLMODE_NORMAL = (byte) 1L;
    /**
     * {@snippet lang=c :
     * #define AUDIT_CTLMODE_NORMAL 1
     * }
     */
    public static byte AUDIT_CTLMODE_NORMAL() {
        return AUDIT_CTLMODE_NORMAL;
    }

    private static final byte AUDIT_CTLMODE_EXTERNAL = (byte) 2L;
    /**
     * {@snippet lang=c :
     * #define AUDIT_CTLMODE_EXTERNAL 2
     * }
     */
    public static byte AUDIT_CTLMODE_EXTERNAL() {
        return AUDIT_CTLMODE_EXTERNAL;
    }

    private static final byte AUDIT_EXPIRE_OP_AND = (byte) 0L;
    /**
     * {@snippet lang=c :
     * #define AUDIT_EXPIRE_OP_AND 0
     * }
     */
    public static byte AUDIT_EXPIRE_OP_AND() {
        return AUDIT_EXPIRE_OP_AND;
    }

    private static final byte AUDIT_EXPIRE_OP_OR = (byte) 1L;
    /**
     * {@snippet lang=c :
     * #define AUDIT_EXPIRE_OP_OR 1
     * }
     */
    public static byte AUDIT_EXPIRE_OP_OR() {
        return AUDIT_EXPIRE_OP_OR;
    }

    private static final int MACH_PORT_DEAD = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_DEAD 4294967295
     * }
     */
    public static int MACH_PORT_DEAD() {
        return MACH_PORT_DEAD;
    }

    private static final int MACH_PORT_RIGHT_SEND = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_SEND 0
     * }
     */
    public static int MACH_PORT_RIGHT_SEND() {
        return MACH_PORT_RIGHT_SEND;
    }

    private static final int MACH_PORT_RIGHT_RECEIVE = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_RECEIVE 1
     * }
     */
    public static int MACH_PORT_RIGHT_RECEIVE() {
        return MACH_PORT_RIGHT_RECEIVE;
    }

    private static final int MACH_PORT_RIGHT_SEND_ONCE = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_SEND_ONCE 2
     * }
     */
    public static int MACH_PORT_RIGHT_SEND_ONCE() {
        return MACH_PORT_RIGHT_SEND_ONCE;
    }

    private static final int MACH_PORT_RIGHT_PORT_SET = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_PORT_SET 3
     * }
     */
    public static int MACH_PORT_RIGHT_PORT_SET() {
        return MACH_PORT_RIGHT_PORT_SET;
    }

    private static final int MACH_PORT_RIGHT_DEAD_NAME = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_DEAD_NAME 4
     * }
     */
    public static int MACH_PORT_RIGHT_DEAD_NAME() {
        return MACH_PORT_RIGHT_DEAD_NAME;
    }

    private static final int MACH_PORT_RIGHT_LABELH = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_LABELH 5
     * }
     */
    public static int MACH_PORT_RIGHT_LABELH() {
        return MACH_PORT_RIGHT_LABELH;
    }

    private static final int MACH_PORT_RIGHT_NUMBER = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_NUMBER 6
     * }
     */
    public static int MACH_PORT_RIGHT_NUMBER() {
        return MACH_PORT_RIGHT_NUMBER;
    }

    private static final int MACH_PORT_TYPE_NONE = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_NONE 0
     * }
     */
    public static int MACH_PORT_TYPE_NONE() {
        return MACH_PORT_TYPE_NONE;
    }

    private static final int MACH_PORT_TYPE_SEND = (int) 65536L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND 65536
     * }
     */
    public static int MACH_PORT_TYPE_SEND() {
        return MACH_PORT_TYPE_SEND;
    }

    private static final int MACH_PORT_TYPE_RECEIVE = (int) 131072L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_RECEIVE 131072
     * }
     */
    public static int MACH_PORT_TYPE_RECEIVE() {
        return MACH_PORT_TYPE_RECEIVE;
    }

    private static final int MACH_PORT_TYPE_SEND_ONCE = (int) 262144L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND_ONCE 262144
     * }
     */
    public static int MACH_PORT_TYPE_SEND_ONCE() {
        return MACH_PORT_TYPE_SEND_ONCE;
    }

    private static final int MACH_PORT_TYPE_PORT_SET = (int) 524288L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_PORT_SET 524288
     * }
     */
    public static int MACH_PORT_TYPE_PORT_SET() {
        return MACH_PORT_TYPE_PORT_SET;
    }

    private static final int MACH_PORT_TYPE_DEAD_NAME = (int) 1048576L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_DEAD_NAME 1048576
     * }
     */
    public static int MACH_PORT_TYPE_DEAD_NAME() {
        return MACH_PORT_TYPE_DEAD_NAME;
    }

    private static final int MACH_PORT_TYPE_LABELH = (int) 2097152L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_LABELH 2097152
     * }
     */
    public static int MACH_PORT_TYPE_LABELH() {
        return MACH_PORT_TYPE_LABELH;
    }

    private static final int MACH_PORT_TYPE_SEND_RECEIVE = (int) 196608L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND_RECEIVE 196608
     * }
     */
    public static int MACH_PORT_TYPE_SEND_RECEIVE() {
        return MACH_PORT_TYPE_SEND_RECEIVE;
    }

    private static final int MACH_PORT_TYPE_SEND_RIGHTS = (int) 327680L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND_RIGHTS 327680
     * }
     */
    public static int MACH_PORT_TYPE_SEND_RIGHTS() {
        return MACH_PORT_TYPE_SEND_RIGHTS;
    }

    private static final int MACH_PORT_TYPE_PORT_RIGHTS = (int) 458752L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_PORT_RIGHTS 458752
     * }
     */
    public static int MACH_PORT_TYPE_PORT_RIGHTS() {
        return MACH_PORT_TYPE_PORT_RIGHTS;
    }

    private static final int MACH_PORT_TYPE_PORT_OR_DEAD = (int) 1507328L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_PORT_OR_DEAD 1507328
     * }
     */
    public static int MACH_PORT_TYPE_PORT_OR_DEAD() {
        return MACH_PORT_TYPE_PORT_OR_DEAD;
    }

    private static final int MACH_PORT_TYPE_ALL_RIGHTS = (int) 2031616L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_ALL_RIGHTS 2031616
     * }
     */
    public static int MACH_PORT_TYPE_ALL_RIGHTS() {
        return MACH_PORT_TYPE_ALL_RIGHTS;
    }

    private static final int MACH_PORT_TYPE_DNREQUEST = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_DNREQUEST 2147483648
     * }
     */
    public static int MACH_PORT_TYPE_DNREQUEST() {
        return MACH_PORT_TYPE_DNREQUEST;
    }

    private static final int MACH_PORT_QLIMIT_ZERO = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_ZERO 0
     * }
     */
    public static int MACH_PORT_QLIMIT_ZERO() {
        return MACH_PORT_QLIMIT_ZERO;
    }

    private static final int MACH_PORT_QLIMIT_BASIC = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_BASIC 5
     * }
     */
    public static int MACH_PORT_QLIMIT_BASIC() {
        return MACH_PORT_QLIMIT_BASIC;
    }

    private static final int MACH_PORT_QLIMIT_SMALL = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_SMALL 16
     * }
     */
    public static int MACH_PORT_QLIMIT_SMALL() {
        return MACH_PORT_QLIMIT_SMALL;
    }

    private static final int MACH_PORT_QLIMIT_LARGE = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_LARGE 1024
     * }
     */
    public static int MACH_PORT_QLIMIT_LARGE() {
        return MACH_PORT_QLIMIT_LARGE;
    }

    private static final int MACH_PORT_QLIMIT_KERNEL = (int) 65534L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_KERNEL 65534
     * }
     */
    public static int MACH_PORT_QLIMIT_KERNEL() {
        return MACH_PORT_QLIMIT_KERNEL;
    }

    private static final int MACH_PORT_QLIMIT_MIN = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_MIN 0
     * }
     */
    public static int MACH_PORT_QLIMIT_MIN() {
        return MACH_PORT_QLIMIT_MIN;
    }

    private static final int MACH_PORT_QLIMIT_DEFAULT = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_DEFAULT 5
     * }
     */
    public static int MACH_PORT_QLIMIT_DEFAULT() {
        return MACH_PORT_QLIMIT_DEFAULT;
    }

    private static final int MACH_PORT_QLIMIT_MAX = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_MAX 1024
     * }
     */
    public static int MACH_PORT_QLIMIT_MAX() {
        return MACH_PORT_QLIMIT_MAX;
    }

    private static final int MACH_PORT_LIMITS_INFO_COUNT = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_LIMITS_INFO_COUNT 1
     * }
     */
    public static int MACH_PORT_LIMITS_INFO_COUNT() {
        return MACH_PORT_LIMITS_INFO_COUNT;
    }

    private static final int MACH_PORT_RECEIVE_STATUS_COUNT = (int) 10L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RECEIVE_STATUS_COUNT 10
     * }
     */
    public static int MACH_PORT_RECEIVE_STATUS_COUNT() {
        return MACH_PORT_RECEIVE_STATUS_COUNT;
    }

    private static final int MACH_PORT_INFO_EXT_COUNT = (int) 17L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_INFO_EXT_COUNT 17
     * }
     */
    public static int MACH_PORT_INFO_EXT_COUNT() {
        return MACH_PORT_INFO_EXT_COUNT;
    }

    private static final int MACH_PORT_GUARD_INFO_COUNT = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_GUARD_INFO_COUNT 2
     * }
     */
    public static int MACH_PORT_GUARD_INFO_COUNT() {
        return MACH_PORT_GUARD_INFO_COUNT;
    }

    private static final byte MACH_SERVICE_PORT_INFO_COUNT = (byte) 0L;
    /**
     * {@snippet lang=c :
     * #define MACH_SERVICE_PORT_INFO_COUNT 0
     * }
     */
    public static byte MACH_SERVICE_PORT_INFO_COUNT() {
        return MACH_SERVICE_PORT_INFO_COUNT;
    }

    private static final int MAX_FATAL_kGUARD_EXC_CODE = (int) 128L;
    /**
     * {@snippet lang=c :
     * #define MAX_FATAL_kGUARD_EXC_CODE 128
     * }
     */
    public static int MAX_FATAL_kGUARD_EXC_CODE() {
        return MAX_FATAL_kGUARD_EXC_CODE;
    }

    private static final long MPG_FLAGS_NONE = 0L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_NONE 0
     * }
     */
    public static long MPG_FLAGS_NONE() {
        return MPG_FLAGS_NONE;
    }

    private static final int MAX_OPTIONAL_kGUARD_EXC_CODE = (int) 524288L;
    /**
     * {@snippet lang=c :
     * #define MAX_OPTIONAL_kGUARD_EXC_CODE 524288
     * }
     */
    public static int MAX_OPTIONAL_kGUARD_EXC_CODE() {
        return MAX_OPTIONAL_kGUARD_EXC_CODE;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP = 72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP 72057594037927936
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP() {
        return MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT = 144115188075855872L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT 144115188075855872
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT() {
        return MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER = 288230376151711744L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER 288230376151711744
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER() {
        return MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR = 576460752303423488L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR 576460752303423488
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR() {
        return MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA = 1152921504606846976L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA 1152921504606846976
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA() {
        return MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_MASK = -72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_MASK -72057594037927936
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_MASK() {
        return MPG_FLAGS_STRICT_REPLY_MASK;
    }

    private static final long MPG_FLAGS_MOD_REFS_PINNED_DEALLOC = 72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_MOD_REFS_PINNED_DEALLOC 72057594037927936
     * }
     */
    public static long MPG_FLAGS_MOD_REFS_PINNED_DEALLOC() {
        return MPG_FLAGS_MOD_REFS_PINNED_DEALLOC;
    }

    private static final long MPG_FLAGS_MOD_REFS_PINNED_DESTROY = 144115188075855872L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_MOD_REFS_PINNED_DESTROY 144115188075855872
     * }
     */
    public static long MPG_FLAGS_MOD_REFS_PINNED_DESTROY() {
        return MPG_FLAGS_MOD_REFS_PINNED_DESTROY;
    }

    private static final long MPG_FLAGS_MOD_REFS_PINNED_COPYIN = 288230376151711744L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_MOD_REFS_PINNED_COPYIN 288230376151711744
     * }
     */
    public static long MPG_FLAGS_MOD_REFS_PINNED_COPYIN() {
        return MPG_FLAGS_MOD_REFS_PINNED_COPYIN;
    }

    private static final long MPG_FLAGS_IMMOVABLE_PINNED = 72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_IMMOVABLE_PINNED 72057594037927936
     * }
     */
    public static long MPG_FLAGS_IMMOVABLE_PINNED() {
        return MPG_FLAGS_IMMOVABLE_PINNED;
    }

    private static final MemorySegment NOCRED = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NOCRED (void*) 0
     * }
     */
    public static MemorySegment NOCRED() {
        return NOCRED;
    }

    private static final MemorySegment FSCRED = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define FSCRED (void*) -1
     * }
     */
    public static MemorySegment FSCRED() {
        return FSCRED;
    }

    private static final int EVFILT_READ = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_READ -1
     * }
     */
    public static int EVFILT_READ() {
        return EVFILT_READ;
    }

    private static final int EVFILT_WRITE = (int) -2L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_WRITE -2
     * }
     */
    public static int EVFILT_WRITE() {
        return EVFILT_WRITE;
    }

    private static final int EVFILT_AIO = (int) -3L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_AIO -3
     * }
     */
    public static int EVFILT_AIO() {
        return EVFILT_AIO;
    }

    private static final int EVFILT_VNODE = (int) -4L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_VNODE -4
     * }
     */
    public static int EVFILT_VNODE() {
        return EVFILT_VNODE;
    }

    private static final int EVFILT_PROC = (int) -5L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_PROC -5
     * }
     */
    public static int EVFILT_PROC() {
        return EVFILT_PROC;
    }

    private static final int EVFILT_SIGNAL = (int) -6L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_SIGNAL -6
     * }
     */
    public static int EVFILT_SIGNAL() {
        return EVFILT_SIGNAL;
    }

    private static final int EVFILT_TIMER = (int) -7L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_TIMER -7
     * }
     */
    public static int EVFILT_TIMER() {
        return EVFILT_TIMER;
    }

    private static final int EVFILT_MACHPORT = (int) -8L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_MACHPORT -8
     * }
     */
    public static int EVFILT_MACHPORT() {
        return EVFILT_MACHPORT;
    }

    private static final int EVFILT_FS = (int) -9L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_FS -9
     * }
     */
    public static int EVFILT_FS() {
        return EVFILT_FS;
    }

    private static final int EVFILT_USER = (int) -10L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_USER -10
     * }
     */
    public static int EVFILT_USER() {
        return EVFILT_USER;
    }

    private static final int EVFILT_VM = (int) -12L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_VM -12
     * }
     */
    public static int EVFILT_VM() {
        return EVFILT_VM;
    }

    private static final int EVFILT_EXCEPT = (int) -15L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_EXCEPT -15
     * }
     */
    public static int EVFILT_EXCEPT() {
        return EVFILT_EXCEPT;
    }

    private static final int EVFILT_THREADMARKER = (int) 18L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_THREADMARKER 18
     * }
     */
    public static int EVFILT_THREADMARKER() {
        return EVFILT_THREADMARKER;
    }

    private static final int EV_DISPATCH2 = (int) 384L;
    /**
     * {@snippet lang=c :
     * #define EV_DISPATCH2 384
     * }
     */
    public static int EV_DISPATCH2() {
        return EV_DISPATCH2;
    }

    private static final int EV_POLL = (int) 4096L;
    /**
     * {@snippet lang=c :
     * #define EV_POLL 4096
     * }
     */
    public static int EV_POLL() {
        return EV_POLL;
    }

    private static final int EV_OOBAND = (int) 8192L;
    /**
     * {@snippet lang=c :
     * #define EV_OOBAND 8192
     * }
     */
    public static int EV_OOBAND() {
        return EV_OOBAND;
    }

    private static final int NOTE_FFOR = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define NOTE_FFOR 2147483648
     * }
     */
    public static int NOTE_FFOR() {
        return NOTE_FFOR;
    }

    private static final int NOTE_FFCOPY = (int) 3221225472L;
    /**
     * {@snippet lang=c :
     * #define NOTE_FFCOPY 3221225472
     * }
     */
    public static int NOTE_FFCOPY() {
        return NOTE_FFCOPY;
    }

    private static final int NOTE_FFCTRLMASK = (int) 3221225472L;
    /**
     * {@snippet lang=c :
     * #define NOTE_FFCTRLMASK 3221225472
     * }
     */
    public static int NOTE_FFCTRLMASK() {
        return NOTE_FFCTRLMASK;
    }

    private static final int NOTE_EXIT = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define NOTE_EXIT 2147483648
     * }
     */
    public static int NOTE_EXIT() {
        return NOTE_EXIT;
    }

    private static final int NOTE_REAP = (int) 268435456L;
    /**
     * {@snippet lang=c :
     * #define NOTE_REAP 268435456
     * }
     */
    public static int NOTE_REAP() {
        return NOTE_REAP;
    }

    private static final int NOTE_PCTRLMASK = (int) -1048576L;
    /**
     * {@snippet lang=c :
     * #define NOTE_PCTRLMASK -1048576
     * }
     */
    public static int NOTE_PCTRLMASK() {
        return NOTE_PCTRLMASK;
    }

    private static final int NOTE_EXIT_REPARENTED = (int) 524288L;
    /**
     * {@snippet lang=c :
     * #define NOTE_EXIT_REPARENTED 524288
     * }
     */
    public static int NOTE_EXIT_REPARENTED() {
        return NOTE_EXIT_REPARENTED;
    }

    private static final int NOTE_VM_PRESSURE = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define NOTE_VM_PRESSURE 2147483648
     * }
     */
    public static int NOTE_VM_PRESSURE() {
        return NOTE_VM_PRESSURE;
    }

    private static final int P_CLASSIC = (int) 131072L;
    /**
     * {@snippet lang=c :
     * #define P_CLASSIC 131072
     * }
     */
    public static int P_CLASSIC() {
        return P_CLASSIC;
    }

    private static final int P_NOREMOTEHANG = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define P_NOREMOTEHANG 2147483648
     * }
     */
    public static int P_NOREMOTEHANG() {
        return P_NOREMOTEHANG;
    }

    private static final int P_DIRTY_IS_DIRTY = (int) 24L;
    /**
     * {@snippet lang=c :
     * #define P_DIRTY_IS_DIRTY 24
     * }
     */
    public static int P_DIRTY_IS_DIRTY() {
        return P_DIRTY_IS_DIRTY;
    }

    private static final int P_DIRTY_IDLE_EXIT_ENABLED = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define P_DIRTY_IDLE_EXIT_ENABLED 3
     * }
     */
    public static int P_DIRTY_IDLE_EXIT_ENABLED() {
        return P_DIRTY_IDLE_EXIT_ENABLED;
    }

    private static final int CTLTYPE_STRUCT = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define CTLTYPE_STRUCT 5
     * }
     */
    public static int CTLTYPE_STRUCT() {
        return CTLTYPE_STRUCT;
    }

    private static final int CTLFLAG_RD = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define CTLFLAG_RD 2147483648
     * }
     */
    public static int CTLFLAG_RD() {
        return CTLFLAG_RD;
    }

    private static final int CTLFLAG_RW = (int) 3221225472L;
    /**
     * {@snippet lang=c :
     * #define CTLFLAG_RW 3221225472
     * }
     */
    public static int CTLFLAG_RW() {
        return CTLFLAG_RW;
    }

    private static final int OID_AUTO = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define OID_AUTO -1
     * }
     */
    public static int OID_AUTO() {
        return OID_AUTO;
    }

    private static final int KERN_DOMAINNAME = (int) 22L;
    /**
     * {@snippet lang=c :
     * #define KERN_DOMAINNAME 22
     * }
     */
    public static int KERN_DOMAINNAME() {
        return KERN_DOMAINNAME;
    }

    private static final int KERN_CLASSIC = (int) 44L;
    /**
     * {@snippet lang=c :
     * #define KERN_CLASSIC 44
     * }
     */
    public static int KERN_CLASSIC() {
        return KERN_CLASSIC;
    }

    private static final int KERN_CLASSICHANDLER = (int) 45L;
    /**
     * {@snippet lang=c :
     * #define KERN_CLASSICHANDLER 45
     * }
     */
    public static int KERN_CLASSICHANDLER() {
        return KERN_CLASSICHANDLER;
    }

    private static final int KERN_USRSTACK = (int) 59L;
    /**
     * {@snippet lang=c :
     * #define KERN_USRSTACK 59
     * }
     */
    public static int KERN_USRSTACK() {
        return KERN_USRSTACK;
    }
}
