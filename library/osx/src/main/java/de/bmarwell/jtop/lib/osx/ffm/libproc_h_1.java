/*
 * Copyright (C) 2024.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.bmarwell.jtop.lib.osx.ffm; // Generated by jextract

import static java.lang.foreign.ValueLayout.*;

import java.lang.foreign.AddressLayout;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.GroupLayout;
import java.lang.foreign.Linker;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.SequenceLayout;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;

public class libproc_h_1 extends libproc_h_2 {

    libproc_h_1() {
        // Should not be called directly
    }

    private static final int TCP_MAX_WINSHIFT = (int) 14L;
    /**
     * {@snippet lang=c :
     * #define TCP_MAX_WINSHIFT 14
     * }
     */
    public static int TCP_MAX_WINSHIFT() {
        return TCP_MAX_WINSHIFT;
    }

    private static final int TCP_NODELAY = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define TCP_NODELAY 1
     * }
     */
    public static int TCP_NODELAY() {
        return TCP_NODELAY;
    }

    private static final int TCP_MAXSEG = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define TCP_MAXSEG 2
     * }
     */
    public static int TCP_MAXSEG() {
        return TCP_MAXSEG;
    }

    private static final int TCP_NOPUSH = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define TCP_NOPUSH 4
     * }
     */
    public static int TCP_NOPUSH() {
        return TCP_NOPUSH;
    }

    private static final int TCP_NOOPT = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define TCP_NOOPT 8
     * }
     */
    public static int TCP_NOOPT() {
        return TCP_NOOPT;
    }

    private static final int TCP_KEEPALIVE = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define TCP_KEEPALIVE 16
     * }
     */
    public static int TCP_KEEPALIVE() {
        return TCP_KEEPALIVE;
    }

    private static final int TCP_CONNECTIONTIMEOUT = (int) 32L;
    /**
     * {@snippet lang=c :
     * #define TCP_CONNECTIONTIMEOUT 32
     * }
     */
    public static int TCP_CONNECTIONTIMEOUT() {
        return TCP_CONNECTIONTIMEOUT;
    }

    private static final int PERSIST_TIMEOUT = (int) 64L;
    /**
     * {@snippet lang=c :
     * #define PERSIST_TIMEOUT 64
     * }
     */
    public static int PERSIST_TIMEOUT() {
        return PERSIST_TIMEOUT;
    }

    private static final int TCP_RXT_CONNDROPTIME = (int) 128L;
    /**
     * {@snippet lang=c :
     * #define TCP_RXT_CONNDROPTIME 128
     * }
     */
    public static int TCP_RXT_CONNDROPTIME() {
        return TCP_RXT_CONNDROPTIME;
    }

    private static final int TCP_RXT_FINDROP = (int) 256L;
    /**
     * {@snippet lang=c :
     * #define TCP_RXT_FINDROP 256
     * }
     */
    public static int TCP_RXT_FINDROP() {
        return TCP_RXT_FINDROP;
    }

    private static final int TCP_KEEPINTVL = (int) 257L;
    /**
     * {@snippet lang=c :
     * #define TCP_KEEPINTVL 257
     * }
     */
    public static int TCP_KEEPINTVL() {
        return TCP_KEEPINTVL;
    }

    private static final int TCP_KEEPCNT = (int) 258L;
    /**
     * {@snippet lang=c :
     * #define TCP_KEEPCNT 258
     * }
     */
    public static int TCP_KEEPCNT() {
        return TCP_KEEPCNT;
    }

    private static final int TCP_SENDMOREACKS = (int) 259L;
    /**
     * {@snippet lang=c :
     * #define TCP_SENDMOREACKS 259
     * }
     */
    public static int TCP_SENDMOREACKS() {
        return TCP_SENDMOREACKS;
    }

    private static final int TCP_ENABLE_ECN = (int) 260L;
    /**
     * {@snippet lang=c :
     * #define TCP_ENABLE_ECN 260
     * }
     */
    public static int TCP_ENABLE_ECN() {
        return TCP_ENABLE_ECN;
    }

    private static final int TCP_FASTOPEN = (int) 261L;
    /**
     * {@snippet lang=c :
     * #define TCP_FASTOPEN 261
     * }
     */
    public static int TCP_FASTOPEN() {
        return TCP_FASTOPEN;
    }

    private static final int TCP_CONNECTION_INFO = (int) 262L;
    /**
     * {@snippet lang=c :
     * #define TCP_CONNECTION_INFO 262
     * }
     */
    public static int TCP_CONNECTION_INFO() {
        return TCP_CONNECTION_INFO;
    }

    private static final int TCP_NOTSENT_LOWAT = (int) 513L;
    /**
     * {@snippet lang=c :
     * #define TCP_NOTSENT_LOWAT 513
     * }
     */
    public static int TCP_NOTSENT_LOWAT() {
        return TCP_NOTSENT_LOWAT;
    }

    private static final int TCPCI_OPT_TIMESTAMPS = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define TCPCI_OPT_TIMESTAMPS 1
     * }
     */
    public static int TCPCI_OPT_TIMESTAMPS() {
        return TCPCI_OPT_TIMESTAMPS;
    }

    private static final int TCPCI_OPT_SACK = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define TCPCI_OPT_SACK 2
     * }
     */
    public static int TCPCI_OPT_SACK() {
        return TCPCI_OPT_SACK;
    }

    private static final int TCPCI_OPT_WSCALE = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define TCPCI_OPT_WSCALE 4
     * }
     */
    public static int TCPCI_OPT_WSCALE() {
        return TCPCI_OPT_WSCALE;
    }

    private static final int TCPCI_OPT_ECN = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define TCPCI_OPT_ECN 8
     * }
     */
    public static int TCPCI_OPT_ECN() {
        return TCPCI_OPT_ECN;
    }

    private static final int TCPCI_FLAG_LOSSRECOVERY = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define TCPCI_FLAG_LOSSRECOVERY 1
     * }
     */
    public static int TCPCI_FLAG_LOSSRECOVERY() {
        return TCPCI_FLAG_LOSSRECOVERY;
    }

    private static final int TCPCI_FLAG_REORDERING_DETECTED = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define TCPCI_FLAG_REORDERING_DETECTED 2
     * }
     */
    public static int TCPCI_FLAG_REORDERING_DETECTED() {
        return TCPCI_FLAG_REORDERING_DETECTED;
    }

    private static final int CPU_STATE_MAX = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define CPU_STATE_MAX 4
     * }
     */
    public static int CPU_STATE_MAX() {
        return CPU_STATE_MAX;
    }

    private static final int CPU_STATE_USER = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_STATE_USER 0
     * }
     */
    public static int CPU_STATE_USER() {
        return CPU_STATE_USER;
    }

    private static final int CPU_STATE_SYSTEM = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPU_STATE_SYSTEM 1
     * }
     */
    public static int CPU_STATE_SYSTEM() {
        return CPU_STATE_SYSTEM;
    }

    private static final int CPU_STATE_IDLE = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define CPU_STATE_IDLE 2
     * }
     */
    public static int CPU_STATE_IDLE() {
        return CPU_STATE_IDLE;
    }

    private static final int CPU_STATE_NICE = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define CPU_STATE_NICE 3
     * }
     */
    public static int CPU_STATE_NICE() {
        return CPU_STATE_NICE;
    }

    private static final int CPU_ARCH_ABI64 = (int) 16777216L;
    /**
     * {@snippet lang=c :
     * #define CPU_ARCH_ABI64 16777216
     * }
     */
    public static int CPU_ARCH_ABI64() {
        return CPU_ARCH_ABI64;
    }

    private static final int CPU_ARCH_ABI64_32 = (int) 33554432L;
    /**
     * {@snippet lang=c :
     * #define CPU_ARCH_ABI64_32 33554432
     * }
     */
    public static int CPU_ARCH_ABI64_32() {
        return CPU_ARCH_ABI64_32;
    }

    private static final int CPU_SUBTYPE_INTEL_FAMILY_MAX = (int) 15L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_INTEL_FAMILY_MAX 15
     * }
     */
    public static int CPU_SUBTYPE_INTEL_FAMILY_MAX() {
        return CPU_SUBTYPE_INTEL_FAMILY_MAX;
    }

    private static final int CPU_SUBTYPE_INTEL_MODEL_ALL = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_INTEL_MODEL_ALL 0
     * }
     */
    public static int CPU_SUBTYPE_INTEL_MODEL_ALL() {
        return CPU_SUBTYPE_INTEL_MODEL_ALL;
    }

    private static final int CPU_SUBTYPE_ARM64_PTR_AUTH_MASK = (int) 251658240L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM64_PTR_AUTH_MASK 251658240
     * }
     */
    public static int CPU_SUBTYPE_ARM64_PTR_AUTH_MASK() {
        return CPU_SUBTYPE_ARM64_PTR_AUTH_MASK;
    }

    private static final int CPUFAMILY_UNKNOWN = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_UNKNOWN 0
     * }
     */
    public static int CPUFAMILY_UNKNOWN() {
        return CPUFAMILY_UNKNOWN;
    }

    private static final int CPUFAMILY_POWERPC_G4 = (int) 2009171118L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_POWERPC_G4 2009171118
     * }
     */
    public static int CPUFAMILY_POWERPC_G4() {
        return CPUFAMILY_POWERPC_G4;
    }

    private static final int CPUFAMILY_INTEL_PENRYN = (int) 2028621756L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_INTEL_PENRYN 2028621756
     * }
     */
    public static int CPUFAMILY_INTEL_PENRYN() {
        return CPUFAMILY_INTEL_PENRYN;
    }

    private static final int CPUFAMILY_INTEL_NEHALEM = (int) 1801080018L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_INTEL_NEHALEM 1801080018
     * }
     */
    public static int CPUFAMILY_INTEL_NEHALEM() {
        return CPUFAMILY_INTEL_NEHALEM;
    }

    private static final int CPUFAMILY_INTEL_WESTMERE = (int) 1463508716L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_INTEL_WESTMERE 1463508716
     * }
     */
    public static int CPUFAMILY_INTEL_WESTMERE() {
        return CPUFAMILY_INTEL_WESTMERE;
    }

    private static final int CPUFAMILY_INTEL_SANDYBRIDGE = (int) 1418770316L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_INTEL_SANDYBRIDGE 1418770316
     * }
     */
    public static int CPUFAMILY_INTEL_SANDYBRIDGE() {
        return CPUFAMILY_INTEL_SANDYBRIDGE;
    }

    private static final int CPUFAMILY_INTEL_IVYBRIDGE = (int) 526772277L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_INTEL_IVYBRIDGE 526772277
     * }
     */
    public static int CPUFAMILY_INTEL_IVYBRIDGE() {
        return CPUFAMILY_INTEL_IVYBRIDGE;
    }

    private static final int CPUFAMILY_INTEL_HASWELL = (int) 280134364L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_INTEL_HASWELL 280134364
     * }
     */
    public static int CPUFAMILY_INTEL_HASWELL() {
        return CPUFAMILY_INTEL_HASWELL;
    }

    private static final int CPUFAMILY_INTEL_BROADWELL = (int) 1479463068L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_INTEL_BROADWELL 1479463068
     * }
     */
    public static int CPUFAMILY_INTEL_BROADWELL() {
        return CPUFAMILY_INTEL_BROADWELL;
    }

    private static final int CPUFAMILY_INTEL_SKYLAKE = (int) 939270559L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_INTEL_SKYLAKE 939270559
     * }
     */
    public static int CPUFAMILY_INTEL_SKYLAKE() {
        return CPUFAMILY_INTEL_SKYLAKE;
    }

    private static final int CPUFAMILY_INTEL_KABYLAKE = (int) 260141638L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_INTEL_KABYLAKE 260141638
     * }
     */
    public static int CPUFAMILY_INTEL_KABYLAKE() {
        return CPUFAMILY_INTEL_KABYLAKE;
    }

    private static final int CPUFAMILY_INTEL_ICELAKE = (int) 943936839L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_INTEL_ICELAKE 943936839
     * }
     */
    public static int CPUFAMILY_INTEL_ICELAKE() {
        return CPUFAMILY_INTEL_ICELAKE;
    }

    private static final int CPUFAMILY_INTEL_COMETLAKE = (int) 486055998L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_INTEL_COMETLAKE 486055998
     * }
     */
    public static int CPUFAMILY_INTEL_COMETLAKE() {
        return CPUFAMILY_INTEL_COMETLAKE;
    }

    private static final int CPUFAMILY_ARM_XSCALE = (int) 1404044789L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_XSCALE 1404044789
     * }
     */
    public static int CPUFAMILY_ARM_XSCALE() {
        return CPUFAMILY_ARM_XSCALE;
    }

    private static final int CPUFAMILY_ARM_13 = (int) 214503012L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_13 214503012
     * }
     */
    public static int CPUFAMILY_ARM_13() {
        return CPUFAMILY_ARM_13;
    }

    private static final int CPUFAMILY_ARM_SWIFT = (int) 506291073L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_SWIFT 506291073
     * }
     */
    public static int CPUFAMILY_ARM_SWIFT() {
        return CPUFAMILY_ARM_SWIFT;
    }

    private static final int CPUFAMILY_ARM_CYCLONE = (int) 933271106L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_CYCLONE 933271106
     * }
     */
    public static int CPUFAMILY_ARM_CYCLONE() {
        return CPUFAMILY_ARM_CYCLONE;
    }

    private static final int CPUFAMILY_ARM_TYPHOON = (int) 747742334L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_TYPHOON 747742334
     * }
     */
    public static int CPUFAMILY_ARM_TYPHOON() {
        return CPUFAMILY_ARM_TYPHOON;
    }

    private static final int CPUFAMILY_ARM_HURRICANE = (int) 1741614739L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_HURRICANE 1741614739
     * }
     */
    public static int CPUFAMILY_ARM_HURRICANE() {
        return CPUFAMILY_ARM_HURRICANE;
    }

    private static final int CPUFAMILY_ARM_VORTEX_TEMPEST = (int) 131287967L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_VORTEX_TEMPEST 131287967
     * }
     */
    public static int CPUFAMILY_ARM_VORTEX_TEMPEST() {
        return CPUFAMILY_ARM_VORTEX_TEMPEST;
    }

    private static final int CPUFAMILY_ARM_LIGHTNING_THUNDER = (int) 1176831186L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_LIGHTNING_THUNDER 1176831186
     * }
     */
    public static int CPUFAMILY_ARM_LIGHTNING_THUNDER() {
        return CPUFAMILY_ARM_LIGHTNING_THUNDER;
    }

    private static final int CPUFAMILY_ARM_FIRESTORM_ICESTORM = (int) 458787763L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_FIRESTORM_ICESTORM 458787763
     * }
     */
    public static int CPUFAMILY_ARM_FIRESTORM_ICESTORM() {
        return CPUFAMILY_ARM_FIRESTORM_ICESTORM;
    }

    private static final int CPUFAMILY_ARM_PALMA = (int) 1912690738L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_PALMA 1912690738
     * }
     */
    public static int CPUFAMILY_ARM_PALMA() {
        return CPUFAMILY_ARM_PALMA;
    }

    private static final int CPUFAMILY_ARM_COLL = (int) 678884789L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_COLL 678884789
     * }
     */
    public static int CPUFAMILY_ARM_COLL() {
        return CPUFAMILY_ARM_COLL;
    }

    private static final int CPUFAMILY_ARM_LOBOS = (int) 1598941843L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_LOBOS 1598941843
     * }
     */
    public static int CPUFAMILY_ARM_LOBOS() {
        return CPUFAMILY_ARM_LOBOS;
    }

    private static final int CPUSUBFAMILY_UNKNOWN = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPUSUBFAMILY_UNKNOWN 0
     * }
     */
    public static int CPUSUBFAMILY_UNKNOWN() {
        return CPUSUBFAMILY_UNKNOWN;
    }

    private static final int CPUSUBFAMILY_ARM_HP = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPUSUBFAMILY_ARM_HP 1
     * }
     */
    public static int CPUSUBFAMILY_ARM_HP() {
        return CPUSUBFAMILY_ARM_HP;
    }

    private static final int CPUSUBFAMILY_ARM_HG = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define CPUSUBFAMILY_ARM_HG 2
     * }
     */
    public static int CPUSUBFAMILY_ARM_HG() {
        return CPUSUBFAMILY_ARM_HG;
    }

    private static final int CPUSUBFAMILY_ARM_M = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define CPUSUBFAMILY_ARM_M 3
     * }
     */
    public static int CPUSUBFAMILY_ARM_M() {
        return CPUSUBFAMILY_ARM_M;
    }

    private static final int CPUSUBFAMILY_ARM_HS = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define CPUSUBFAMILY_ARM_HS 4
     * }
     */
    public static int CPUSUBFAMILY_ARM_HS() {
        return CPUSUBFAMILY_ARM_HS;
    }

    private static final int CPUSUBFAMILY_ARM_HC_HD = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define CPUSUBFAMILY_ARM_HC_HD 5
     * }
     */
    public static int CPUSUBFAMILY_ARM_HC_HD() {
        return CPUSUBFAMILY_ARM_HC_HD;
    }

    private static final int CPUSUBFAMILY_ARM_HA = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define CPUSUBFAMILY_ARM_HA 6
     * }
     */
    public static int CPUSUBFAMILY_ARM_HA() {
        return CPUSUBFAMILY_ARM_HA;
    }

    private static final int PROC_ALL_PIDS = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_ALL_PIDS 1
     * }
     */
    public static int PROC_ALL_PIDS() {
        return PROC_ALL_PIDS;
    }

    private static final int PROC_PGRP_ONLY = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_PGRP_ONLY 2
     * }
     */
    public static int PROC_PGRP_ONLY() {
        return PROC_PGRP_ONLY;
    }

    private static final int PROC_TTY_ONLY = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define PROC_TTY_ONLY 3
     * }
     */
    public static int PROC_TTY_ONLY() {
        return PROC_TTY_ONLY;
    }

    private static final int PROC_UID_ONLY = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define PROC_UID_ONLY 4
     * }
     */
    public static int PROC_UID_ONLY() {
        return PROC_UID_ONLY;
    }

    private static final int PROC_RUID_ONLY = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define PROC_RUID_ONLY 5
     * }
     */
    public static int PROC_RUID_ONLY() {
        return PROC_RUID_ONLY;
    }

    private static final int PROC_PPID_ONLY = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define PROC_PPID_ONLY 6
     * }
     */
    public static int PROC_PPID_ONLY() {
        return PROC_PPID_ONLY;
    }

    private static final int PROC_KDBG_ONLY = (int) 7L;
    /**
     * {@snippet lang=c :
     * #define PROC_KDBG_ONLY 7
     * }
     */
    public static int PROC_KDBG_ONLY() {
        return PROC_KDBG_ONLY;
    }

    private static final int PROC_FLAG_SYSTEM = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_SYSTEM 1
     * }
     */
    public static int PROC_FLAG_SYSTEM() {
        return PROC_FLAG_SYSTEM;
    }

    private static final int PROC_FLAG_TRACED = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_TRACED 2
     * }
     */
    public static int PROC_FLAG_TRACED() {
        return PROC_FLAG_TRACED;
    }

    private static final int PROC_FLAG_INEXIT = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_INEXIT 4
     * }
     */
    public static int PROC_FLAG_INEXIT() {
        return PROC_FLAG_INEXIT;
    }

    private static final int PROC_FLAG_PPWAIT = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_PPWAIT 8
     * }
     */
    public static int PROC_FLAG_PPWAIT() {
        return PROC_FLAG_PPWAIT;
    }

    private static final int PROC_FLAG_LP64 = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_LP64 16
     * }
     */
    public static int PROC_FLAG_LP64() {
        return PROC_FLAG_LP64;
    }

    private static final int PROC_FLAG_SLEADER = (int) 32L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_SLEADER 32
     * }
     */
    public static int PROC_FLAG_SLEADER() {
        return PROC_FLAG_SLEADER;
    }

    private static final int PROC_FLAG_CTTY = (int) 64L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_CTTY 64
     * }
     */
    public static int PROC_FLAG_CTTY() {
        return PROC_FLAG_CTTY;
    }

    private static final int PROC_FLAG_CONTROLT = (int) 128L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_CONTROLT 128
     * }
     */
    public static int PROC_FLAG_CONTROLT() {
        return PROC_FLAG_CONTROLT;
    }

    private static final int PROC_FLAG_THCWD = (int) 256L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_THCWD 256
     * }
     */
    public static int PROC_FLAG_THCWD() {
        return PROC_FLAG_THCWD;
    }

    private static final int PROC_FLAG_PC_THROTTLE = (int) 512L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_PC_THROTTLE 512
     * }
     */
    public static int PROC_FLAG_PC_THROTTLE() {
        return PROC_FLAG_PC_THROTTLE;
    }

    private static final int PROC_FLAG_PC_SUSP = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_PC_SUSP 1024
     * }
     */
    public static int PROC_FLAG_PC_SUSP() {
        return PROC_FLAG_PC_SUSP;
    }

    private static final int PROC_FLAG_PC_KILL = (int) 1536L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_PC_KILL 1536
     * }
     */
    public static int PROC_FLAG_PC_KILL() {
        return PROC_FLAG_PC_KILL;
    }

    private static final int PROC_FLAG_PC_MASK = (int) 1536L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_PC_MASK 1536
     * }
     */
    public static int PROC_FLAG_PC_MASK() {
        return PROC_FLAG_PC_MASK;
    }

    private static final int PROC_FLAG_PA_THROTTLE = (int) 2048L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_PA_THROTTLE 2048
     * }
     */
    public static int PROC_FLAG_PA_THROTTLE() {
        return PROC_FLAG_PA_THROTTLE;
    }

    private static final int PROC_FLAG_PA_SUSP = (int) 4096L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_PA_SUSP 4096
     * }
     */
    public static int PROC_FLAG_PA_SUSP() {
        return PROC_FLAG_PA_SUSP;
    }

    private static final int PROC_FLAG_PSUGID = (int) 8192L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_PSUGID 8192
     * }
     */
    public static int PROC_FLAG_PSUGID() {
        return PROC_FLAG_PSUGID;
    }

    private static final int PROC_FLAG_EXEC = (int) 16384L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_EXEC 16384
     * }
     */
    public static int PROC_FLAG_EXEC() {
        return PROC_FLAG_EXEC;
    }

    private static final int MAXTHREADNAMESIZE = (int) 64L;
    /**
     * {@snippet lang=c :
     * #define MAXTHREADNAMESIZE 64
     * }
     */
    public static int MAXTHREADNAMESIZE() {
        return MAXTHREADNAMESIZE;
    }

    private static final int PROC_REGION_SUBMAP = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_REGION_SUBMAP 1
     * }
     */
    public static int PROC_REGION_SUBMAP() {
        return PROC_REGION_SUBMAP;
    }

    private static final int PROC_REGION_SHARED = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_REGION_SHARED 2
     * }
     */
    public static int PROC_REGION_SHARED() {
        return PROC_REGION_SHARED;
    }

    private static final int SM_COW = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define SM_COW 1
     * }
     */
    public static int SM_COW() {
        return SM_COW;
    }

    private static final int SM_PRIVATE = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define SM_PRIVATE 2
     * }
     */
    public static int SM_PRIVATE() {
        return SM_PRIVATE;
    }

    private static final int SM_EMPTY = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define SM_EMPTY 3
     * }
     */
    public static int SM_EMPTY() {
        return SM_EMPTY;
    }

    private static final int SM_SHARED = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define SM_SHARED 4
     * }
     */
    public static int SM_SHARED() {
        return SM_SHARED;
    }

    private static final int SM_TRUESHARED = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define SM_TRUESHARED 5
     * }
     */
    public static int SM_TRUESHARED() {
        return SM_TRUESHARED;
    }

    private static final int SM_PRIVATE_ALIASED = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define SM_PRIVATE_ALIASED 6
     * }
     */
    public static int SM_PRIVATE_ALIASED() {
        return SM_PRIVATE_ALIASED;
    }

    private static final int SM_SHARED_ALIASED = (int) 7L;
    /**
     * {@snippet lang=c :
     * #define SM_SHARED_ALIASED 7
     * }
     */
    public static int SM_SHARED_ALIASED() {
        return SM_SHARED_ALIASED;
    }

    private static final int SM_LARGE_PAGE = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define SM_LARGE_PAGE 8
     * }
     */
    public static int SM_LARGE_PAGE() {
        return SM_LARGE_PAGE;
    }

    private static final int TH_STATE_RUNNING = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define TH_STATE_RUNNING 1
     * }
     */
    public static int TH_STATE_RUNNING() {
        return TH_STATE_RUNNING;
    }

    private static final int TH_STATE_STOPPED = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define TH_STATE_STOPPED 2
     * }
     */
    public static int TH_STATE_STOPPED() {
        return TH_STATE_STOPPED;
    }

    private static final int TH_STATE_WAITING = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define TH_STATE_WAITING 3
     * }
     */
    public static int TH_STATE_WAITING() {
        return TH_STATE_WAITING;
    }

    private static final int TH_STATE_UNINTERRUPTIBLE = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define TH_STATE_UNINTERRUPTIBLE 4
     * }
     */
    public static int TH_STATE_UNINTERRUPTIBLE() {
        return TH_STATE_UNINTERRUPTIBLE;
    }

    private static final int TH_STATE_HALTED = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define TH_STATE_HALTED 5
     * }
     */
    public static int TH_STATE_HALTED() {
        return TH_STATE_HALTED;
    }

    private static final int TH_FLAGS_SWAPPED = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define TH_FLAGS_SWAPPED 1
     * }
     */
    public static int TH_FLAGS_SWAPPED() {
        return TH_FLAGS_SWAPPED;
    }

    private static final int TH_FLAGS_IDLE = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define TH_FLAGS_IDLE 2
     * }
     */
    public static int TH_FLAGS_IDLE() {
        return TH_FLAGS_IDLE;
    }

    private static final int WQ_EXCEEDED_CONSTRAINED_THREAD_LIMIT = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define WQ_EXCEEDED_CONSTRAINED_THREAD_LIMIT 1
     * }
     */
    public static int WQ_EXCEEDED_CONSTRAINED_THREAD_LIMIT() {
        return WQ_EXCEEDED_CONSTRAINED_THREAD_LIMIT;
    }

    private static final int WQ_EXCEEDED_TOTAL_THREAD_LIMIT = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define WQ_EXCEEDED_TOTAL_THREAD_LIMIT 2
     * }
     */
    public static int WQ_EXCEEDED_TOTAL_THREAD_LIMIT() {
        return WQ_EXCEEDED_TOTAL_THREAD_LIMIT;
    }

    private static final int WQ_FLAGS_AVAILABLE = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define WQ_FLAGS_AVAILABLE 4
     * }
     */
    public static int WQ_FLAGS_AVAILABLE() {
        return WQ_FLAGS_AVAILABLE;
    }

    private static final int PROC_FP_SHARED = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_FP_SHARED 1
     * }
     */
    public static int PROC_FP_SHARED() {
        return PROC_FP_SHARED;
    }

    private static final int PROC_FP_CLEXEC = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_FP_CLEXEC 2
     * }
     */
    public static int PROC_FP_CLEXEC() {
        return PROC_FP_CLEXEC;
    }

    private static final int PROC_FP_GUARDED = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define PROC_FP_GUARDED 4
     * }
     */
    public static int PROC_FP_GUARDED() {
        return PROC_FP_GUARDED;
    }

    private static final int PROC_FP_CLFORK = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define PROC_FP_CLFORK 8
     * }
     */
    public static int PROC_FP_CLFORK() {
        return PROC_FP_CLFORK;
    }

    private static final int INI_IPV4 = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define INI_IPV4 1
     * }
     */
    public static int INI_IPV4() {
        return INI_IPV4;
    }

    private static final int INI_IPV6 = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define INI_IPV6 2
     * }
     */
    public static int INI_IPV6() {
        return INI_IPV6;
    }

    private static final int TSI_T_REXMT = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define TSI_T_REXMT 0
     * }
     */
    public static int TSI_T_REXMT() {
        return TSI_T_REXMT;
    }

    private static final int TSI_T_PERSIST = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define TSI_T_PERSIST 1
     * }
     */
    public static int TSI_T_PERSIST() {
        return TSI_T_PERSIST;
    }

    private static final int TSI_T_KEEP = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define TSI_T_KEEP 2
     * }
     */
    public static int TSI_T_KEEP() {
        return TSI_T_KEEP;
    }

    private static final int TSI_T_2MSL = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define TSI_T_2MSL 3
     * }
     */
    public static int TSI_T_2MSL() {
        return TSI_T_2MSL;
    }

    private static final int TSI_T_NTIMERS = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define TSI_T_NTIMERS 4
     * }
     */
    public static int TSI_T_NTIMERS() {
        return TSI_T_NTIMERS;
    }

    private static final int TSI_S_CLOSED = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define TSI_S_CLOSED 0
     * }
     */
    public static int TSI_S_CLOSED() {
        return TSI_S_CLOSED;
    }

    private static final int TSI_S_LISTEN = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define TSI_S_LISTEN 1
     * }
     */
    public static int TSI_S_LISTEN() {
        return TSI_S_LISTEN;
    }

    private static final int TSI_S_SYN_SENT = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define TSI_S_SYN_SENT 2
     * }
     */
    public static int TSI_S_SYN_SENT() {
        return TSI_S_SYN_SENT;
    }

    private static final int TSI_S_SYN_RECEIVED = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define TSI_S_SYN_RECEIVED 3
     * }
     */
    public static int TSI_S_SYN_RECEIVED() {
        return TSI_S_SYN_RECEIVED;
    }

    private static final int TSI_S_ESTABLISHED = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define TSI_S_ESTABLISHED 4
     * }
     */
    public static int TSI_S_ESTABLISHED() {
        return TSI_S_ESTABLISHED;
    }

    private static final int TSI_S__CLOSE_WAIT = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define TSI_S__CLOSE_WAIT 5
     * }
     */
    public static int TSI_S__CLOSE_WAIT() {
        return TSI_S__CLOSE_WAIT;
    }

    private static final int TSI_S_FIN_WAIT_1 = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define TSI_S_FIN_WAIT_1 6
     * }
     */
    public static int TSI_S_FIN_WAIT_1() {
        return TSI_S_FIN_WAIT_1;
    }

    private static final int TSI_S_CLOSING = (int) 7L;
    /**
     * {@snippet lang=c :
     * #define TSI_S_CLOSING 7
     * }
     */
    public static int TSI_S_CLOSING() {
        return TSI_S_CLOSING;
    }

    private static final int TSI_S_LAST_ACK = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define TSI_S_LAST_ACK 8
     * }
     */
    public static int TSI_S_LAST_ACK() {
        return TSI_S_LAST_ACK;
    }

    private static final int TSI_S_FIN_WAIT_2 = (int) 9L;
    /**
     * {@snippet lang=c :
     * #define TSI_S_FIN_WAIT_2 9
     * }
     */
    public static int TSI_S_FIN_WAIT_2() {
        return TSI_S_FIN_WAIT_2;
    }

    private static final int TSI_S_TIME_WAIT = (int) 10L;
    /**
     * {@snippet lang=c :
     * #define TSI_S_TIME_WAIT 10
     * }
     */
    public static int TSI_S_TIME_WAIT() {
        return TSI_S_TIME_WAIT;
    }

    private static final int TSI_S_RESERVED = (int) 11L;
    /**
     * {@snippet lang=c :
     * #define TSI_S_RESERVED 11
     * }
     */
    public static int TSI_S_RESERVED() {
        return TSI_S_RESERVED;
    }

    private static final int SOI_S_NOFDREF = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define SOI_S_NOFDREF 1
     * }
     */
    public static int SOI_S_NOFDREF() {
        return SOI_S_NOFDREF;
    }

    private static final int SOI_S_ISCONNECTED = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define SOI_S_ISCONNECTED 2
     * }
     */
    public static int SOI_S_ISCONNECTED() {
        return SOI_S_ISCONNECTED;
    }

    private static final int SOI_S_ISCONNECTING = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define SOI_S_ISCONNECTING 4
     * }
     */
    public static int SOI_S_ISCONNECTING() {
        return SOI_S_ISCONNECTING;
    }

    private static final int SOI_S_ISDISCONNECTING = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define SOI_S_ISDISCONNECTING 8
     * }
     */
    public static int SOI_S_ISDISCONNECTING() {
        return SOI_S_ISDISCONNECTING;
    }

    private static final int SOI_S_CANTSENDMORE = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define SOI_S_CANTSENDMORE 16
     * }
     */
    public static int SOI_S_CANTSENDMORE() {
        return SOI_S_CANTSENDMORE;
    }

    private static final int SOI_S_CANTRCVMORE = (int) 32L;
    /**
     * {@snippet lang=c :
     * #define SOI_S_CANTRCVMORE 32
     * }
     */
    public static int SOI_S_CANTRCVMORE() {
        return SOI_S_CANTRCVMORE;
    }

    private static final int SOI_S_RCVATMARK = (int) 64L;
    /**
     * {@snippet lang=c :
     * #define SOI_S_RCVATMARK 64
     * }
     */
    public static int SOI_S_RCVATMARK() {
        return SOI_S_RCVATMARK;
    }

    private static final int SOI_S_PRIV = (int) 128L;
    /**
     * {@snippet lang=c :
     * #define SOI_S_PRIV 128
     * }
     */
    public static int SOI_S_PRIV() {
        return SOI_S_PRIV;
    }

    private static final int SOI_S_NBIO = (int) 256L;
    /**
     * {@snippet lang=c :
     * #define SOI_S_NBIO 256
     * }
     */
    public static int SOI_S_NBIO() {
        return SOI_S_NBIO;
    }

    private static final int SOI_S_ASYNC = (int) 512L;
    /**
     * {@snippet lang=c :
     * #define SOI_S_ASYNC 512
     * }
     */
    public static int SOI_S_ASYNC() {
        return SOI_S_ASYNC;
    }

    private static final int SOI_S_INCOMP = (int) 2048L;
    /**
     * {@snippet lang=c :
     * #define SOI_S_INCOMP 2048
     * }
     */
    public static int SOI_S_INCOMP() {
        return SOI_S_INCOMP;
    }

    private static final int SOI_S_COMP = (int) 4096L;
    /**
     * {@snippet lang=c :
     * #define SOI_S_COMP 4096
     * }
     */
    public static int SOI_S_COMP() {
        return SOI_S_COMP;
    }

    private static final int SOI_S_ISDISCONNECTED = (int) 8192L;
    /**
     * {@snippet lang=c :
     * #define SOI_S_ISDISCONNECTED 8192
     * }
     */
    public static int SOI_S_ISDISCONNECTED() {
        return SOI_S_ISDISCONNECTED;
    }

    private static final int SOI_S_DRAINING = (int) 16384L;
    /**
     * {@snippet lang=c :
     * #define SOI_S_DRAINING 16384
     * }
     */
    public static int SOI_S_DRAINING() {
        return SOI_S_DRAINING;
    }

    private static final int PROC_KQUEUE_SELECT = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_KQUEUE_SELECT 1
     * }
     */
    public static int PROC_KQUEUE_SELECT() {
        return PROC_KQUEUE_SELECT;
    }

    private static final int PROC_KQUEUE_SLEEP = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_KQUEUE_SLEEP 2
     * }
     */
    public static int PROC_KQUEUE_SLEEP() {
        return PROC_KQUEUE_SLEEP;
    }

    private static final int PROC_KQUEUE_32 = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define PROC_KQUEUE_32 8
     * }
     */
    public static int PROC_KQUEUE_32() {
        return PROC_KQUEUE_32;
    }

    private static final int PROC_KQUEUE_64 = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define PROC_KQUEUE_64 16
     * }
     */
    public static int PROC_KQUEUE_64() {
        return PROC_KQUEUE_64;
    }

    private static final int PROC_KQUEUE_QOS = (int) 32L;
    /**
     * {@snippet lang=c :
     * #define PROC_KQUEUE_QOS 32
     * }
     */
    public static int PROC_KQUEUE_QOS() {
        return PROC_KQUEUE_QOS;
    }

    private static final int PROX_FDTYPE_ATALK = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define PROX_FDTYPE_ATALK 0
     * }
     */
    public static int PROX_FDTYPE_ATALK() {
        return PROX_FDTYPE_ATALK;
    }

    private static final int PROX_FDTYPE_VNODE = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROX_FDTYPE_VNODE 1
     * }
     */
    public static int PROX_FDTYPE_VNODE() {
        return PROX_FDTYPE_VNODE;
    }

    private static final int PROX_FDTYPE_SOCKET = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROX_FDTYPE_SOCKET 2
     * }
     */
    public static int PROX_FDTYPE_SOCKET() {
        return PROX_FDTYPE_SOCKET;
    }

    private static final int PROX_FDTYPE_PSHM = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define PROX_FDTYPE_PSHM 3
     * }
     */
    public static int PROX_FDTYPE_PSHM() {
        return PROX_FDTYPE_PSHM;
    }

    private static final int PROX_FDTYPE_PSEM = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define PROX_FDTYPE_PSEM 4
     * }
     */
    public static int PROX_FDTYPE_PSEM() {
        return PROX_FDTYPE_PSEM;
    }

    private static final int PROX_FDTYPE_KQUEUE = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define PROX_FDTYPE_KQUEUE 5
     * }
     */
    public static int PROX_FDTYPE_KQUEUE() {
        return PROX_FDTYPE_KQUEUE;
    }

    private static final int PROX_FDTYPE_PIPE = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define PROX_FDTYPE_PIPE 6
     * }
     */
    public static int PROX_FDTYPE_PIPE() {
        return PROX_FDTYPE_PIPE;
    }

    private static final int PROX_FDTYPE_FSEVENTS = (int) 7L;
    /**
     * {@snippet lang=c :
     * #define PROX_FDTYPE_FSEVENTS 7
     * }
     */
    public static int PROX_FDTYPE_FSEVENTS() {
        return PROX_FDTYPE_FSEVENTS;
    }

    private static final int PROX_FDTYPE_NETPOLICY = (int) 9L;
    /**
     * {@snippet lang=c :
     * #define PROX_FDTYPE_NETPOLICY 9
     * }
     */
    public static int PROX_FDTYPE_NETPOLICY() {
        return PROX_FDTYPE_NETPOLICY;
    }

    private static final int PROX_FDTYPE_CHANNEL = (int) 10L;
    /**
     * {@snippet lang=c :
     * #define PROX_FDTYPE_CHANNEL 10
     * }
     */
    public static int PROX_FDTYPE_CHANNEL() {
        return PROX_FDTYPE_CHANNEL;
    }

    private static final int PROX_FDTYPE_NEXUS = (int) 11L;
    /**
     * {@snippet lang=c :
     * #define PROX_FDTYPE_NEXUS 11
     * }
     */
    public static int PROX_FDTYPE_NEXUS() {
        return PROX_FDTYPE_NEXUS;
    }

    private static final int PROC_CHANNEL_TYPE_USER_PIPE = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define PROC_CHANNEL_TYPE_USER_PIPE 0
     * }
     */
    public static int PROC_CHANNEL_TYPE_USER_PIPE() {
        return PROC_CHANNEL_TYPE_USER_PIPE;
    }

    private static final int PROC_CHANNEL_TYPE_KERNEL_PIPE = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_CHANNEL_TYPE_KERNEL_PIPE 1
     * }
     */
    public static int PROC_CHANNEL_TYPE_KERNEL_PIPE() {
        return PROC_CHANNEL_TYPE_KERNEL_PIPE;
    }

    private static final int PROC_CHANNEL_TYPE_NET_IF = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_CHANNEL_TYPE_NET_IF 2
     * }
     */
    public static int PROC_CHANNEL_TYPE_NET_IF() {
        return PROC_CHANNEL_TYPE_NET_IF;
    }

    private static final int PROC_CHANNEL_TYPE_FLOW_SWITCH = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define PROC_CHANNEL_TYPE_FLOW_SWITCH 3
     * }
     */
    public static int PROC_CHANNEL_TYPE_FLOW_SWITCH() {
        return PROC_CHANNEL_TYPE_FLOW_SWITCH;
    }

    private static final int PROC_CHANNEL_FLAGS_MONITOR_TX = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_CHANNEL_FLAGS_MONITOR_TX 1
     * }
     */
    public static int PROC_CHANNEL_FLAGS_MONITOR_TX() {
        return PROC_CHANNEL_FLAGS_MONITOR_TX;
    }

    private static final int PROC_CHANNEL_FLAGS_MONITOR_RX = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_CHANNEL_FLAGS_MONITOR_RX 2
     * }
     */
    public static int PROC_CHANNEL_FLAGS_MONITOR_RX() {
        return PROC_CHANNEL_FLAGS_MONITOR_RX;
    }

    private static final int PROC_CHANNEL_FLAGS_MONITOR_NO_COPY = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define PROC_CHANNEL_FLAGS_MONITOR_NO_COPY 4
     * }
     */
    public static int PROC_CHANNEL_FLAGS_MONITOR_NO_COPY() {
        return PROC_CHANNEL_FLAGS_MONITOR_NO_COPY;
    }

    private static final int PROC_CHANNEL_FLAGS_EXCLUSIVE = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define PROC_CHANNEL_FLAGS_EXCLUSIVE 16
     * }
     */
    public static int PROC_CHANNEL_FLAGS_EXCLUSIVE() {
        return PROC_CHANNEL_FLAGS_EXCLUSIVE;
    }

    private static final int PROC_CHANNEL_FLAGS_USER_PACKET_POOL = (int) 32L;
    /**
     * {@snippet lang=c :
     * #define PROC_CHANNEL_FLAGS_USER_PACKET_POOL 32
     * }
     */
    public static int PROC_CHANNEL_FLAGS_USER_PACKET_POOL() {
        return PROC_CHANNEL_FLAGS_USER_PACKET_POOL;
    }

    private static final int PROC_CHANNEL_FLAGS_DEFUNCT_OK = (int) 64L;
    /**
     * {@snippet lang=c :
     * #define PROC_CHANNEL_FLAGS_DEFUNCT_OK 64
     * }
     */
    public static int PROC_CHANNEL_FLAGS_DEFUNCT_OK() {
        return PROC_CHANNEL_FLAGS_DEFUNCT_OK;
    }

    private static final int PROC_CHANNEL_FLAGS_LOW_LATENCY = (int) 128L;
    /**
     * {@snippet lang=c :
     * #define PROC_CHANNEL_FLAGS_LOW_LATENCY 128
     * }
     */
    public static int PROC_CHANNEL_FLAGS_LOW_LATENCY() {
        return PROC_CHANNEL_FLAGS_LOW_LATENCY;
    }

    private static final int PROC_PIDLISTFDS = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDLISTFDS 1
     * }
     */
    public static int PROC_PIDLISTFDS() {
        return PROC_PIDLISTFDS;
    }

    private static final int PROC_PIDTASKALLINFO = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDTASKALLINFO 2
     * }
     */
    public static int PROC_PIDTASKALLINFO() {
        return PROC_PIDTASKALLINFO;
    }

    private static final int PROC_PIDTBSDINFO = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDTBSDINFO 3
     * }
     */
    public static int PROC_PIDTBSDINFO() {
        return PROC_PIDTBSDINFO;
    }

    private static final int PROC_PIDTASKINFO = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDTASKINFO 4
     * }
     */
    public static int PROC_PIDTASKINFO() {
        return PROC_PIDTASKINFO;
    }

    private static final int PROC_PIDTHREADINFO = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDTHREADINFO 5
     * }
     */
    public static int PROC_PIDTHREADINFO() {
        return PROC_PIDTHREADINFO;
    }

    private static final int PROC_PIDLISTTHREADS = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDLISTTHREADS 6
     * }
     */
    public static int PROC_PIDLISTTHREADS() {
        return PROC_PIDLISTTHREADS;
    }

    private static final int PROC_PIDREGIONINFO = (int) 7L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDREGIONINFO 7
     * }
     */
    public static int PROC_PIDREGIONINFO() {
        return PROC_PIDREGIONINFO;
    }

    private static final int PROC_PIDREGIONPATHINFO = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDREGIONPATHINFO 8
     * }
     */
    public static int PROC_PIDREGIONPATHINFO() {
        return PROC_PIDREGIONPATHINFO;
    }

    private static final int PROC_PIDVNODEPATHINFO = (int) 9L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDVNODEPATHINFO 9
     * }
     */
    public static int PROC_PIDVNODEPATHINFO() {
        return PROC_PIDVNODEPATHINFO;
    }

    private static final int PROC_PIDTHREADPATHINFO = (int) 10L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDTHREADPATHINFO 10
     * }
     */
    public static int PROC_PIDTHREADPATHINFO() {
        return PROC_PIDTHREADPATHINFO;
    }

    private static final int PROC_PIDPATHINFO = (int) 11L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDPATHINFO 11
     * }
     */
    public static int PROC_PIDPATHINFO() {
        return PROC_PIDPATHINFO;
    }

    private static final int PROC_PIDWORKQUEUEINFO = (int) 12L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDWORKQUEUEINFO 12
     * }
     */
    public static int PROC_PIDWORKQUEUEINFO() {
        return PROC_PIDWORKQUEUEINFO;
    }

    private static final int PROC_PIDT_SHORTBSDINFO = (int) 13L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDT_SHORTBSDINFO 13
     * }
     */
    public static int PROC_PIDT_SHORTBSDINFO() {
        return PROC_PIDT_SHORTBSDINFO;
    }

    private static final int PROC_PIDLISTFILEPORTS = (int) 14L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDLISTFILEPORTS 14
     * }
     */
    public static int PROC_PIDLISTFILEPORTS() {
        return PROC_PIDLISTFILEPORTS;
    }

    private static final int PROC_PIDTHREADID64INFO = (int) 15L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDTHREADID64INFO 15
     * }
     */
    public static int PROC_PIDTHREADID64INFO() {
        return PROC_PIDTHREADID64INFO;
    }

    private static final int PROC_PID_RUSAGE = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define PROC_PID_RUSAGE 16
     * }
     */
    public static int PROC_PID_RUSAGE() {
        return PROC_PID_RUSAGE;
    }

    private static final int PROC_PID_RUSAGE_SIZE = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define PROC_PID_RUSAGE_SIZE 0
     * }
     */
    public static int PROC_PID_RUSAGE_SIZE() {
        return PROC_PID_RUSAGE_SIZE;
    }

    private static final int PROC_PIDFDVNODEINFO = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDVNODEINFO 1
     * }
     */
    public static int PROC_PIDFDVNODEINFO() {
        return PROC_PIDFDVNODEINFO;
    }

    private static final int PROC_PIDFDVNODEPATHINFO = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDVNODEPATHINFO 2
     * }
     */
    public static int PROC_PIDFDVNODEPATHINFO() {
        return PROC_PIDFDVNODEPATHINFO;
    }

    private static final int PROC_PIDFDSOCKETINFO = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDSOCKETINFO 3
     * }
     */
    public static int PROC_PIDFDSOCKETINFO() {
        return PROC_PIDFDSOCKETINFO;
    }

    private static final int PROC_PIDFDPSEMINFO = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDPSEMINFO 4
     * }
     */
    public static int PROC_PIDFDPSEMINFO() {
        return PROC_PIDFDPSEMINFO;
    }

    private static final int PROC_PIDFDPSHMINFO = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDPSHMINFO 5
     * }
     */
    public static int PROC_PIDFDPSHMINFO() {
        return PROC_PIDFDPSHMINFO;
    }

    private static final int PROC_PIDFDPIPEINFO = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDPIPEINFO 6
     * }
     */
    public static int PROC_PIDFDPIPEINFO() {
        return PROC_PIDFDPIPEINFO;
    }

    private static final int PROC_PIDFDKQUEUEINFO = (int) 7L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDKQUEUEINFO 7
     * }
     */
    public static int PROC_PIDFDKQUEUEINFO() {
        return PROC_PIDFDKQUEUEINFO;
    }

    private static final int PROC_PIDFDATALKINFO = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDATALKINFO 8
     * }
     */
    public static int PROC_PIDFDATALKINFO() {
        return PROC_PIDFDATALKINFO;
    }

    private static final int PROC_PIDFDCHANNELINFO = (int) 10L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDCHANNELINFO 10
     * }
     */
    public static int PROC_PIDFDCHANNELINFO() {
        return PROC_PIDFDCHANNELINFO;
    }

    private static final int PROC_PIDFILEPORTVNODEPATHINFO = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFILEPORTVNODEPATHINFO 2
     * }
     */
    public static int PROC_PIDFILEPORTVNODEPATHINFO() {
        return PROC_PIDFILEPORTVNODEPATHINFO;
    }

    private static final int PROC_PIDFILEPORTSOCKETINFO = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFILEPORTSOCKETINFO 3
     * }
     */
    public static int PROC_PIDFILEPORTSOCKETINFO() {
        return PROC_PIDFILEPORTSOCKETINFO;
    }

    private static final int PROC_PIDFILEPORTPSHMINFO = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFILEPORTPSHMINFO 5
     * }
     */
    public static int PROC_PIDFILEPORTPSHMINFO() {
        return PROC_PIDFILEPORTPSHMINFO;
    }

    private static final int PROC_PIDFILEPORTPIPEINFO = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFILEPORTPIPEINFO 6
     * }
     */
    public static int PROC_PIDFILEPORTPIPEINFO() {
        return PROC_PIDFILEPORTPIPEINFO;
    }

    private static final int PROC_SELFSET_PCONTROL = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_SELFSET_PCONTROL 1
     * }
     */
    public static int PROC_SELFSET_PCONTROL() {
        return PROC_SELFSET_PCONTROL;
    }

    private static final int PROC_SELFSET_THREADNAME = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_SELFSET_THREADNAME 2
     * }
     */
    public static int PROC_SELFSET_THREADNAME() {
        return PROC_SELFSET_THREADNAME;
    }

    private static final int PROC_SELFSET_VMRSRCOWNER = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define PROC_SELFSET_VMRSRCOWNER 3
     * }
     */
    public static int PROC_SELFSET_VMRSRCOWNER() {
        return PROC_SELFSET_VMRSRCOWNER;
    }

    private static final int PROC_SELFSET_DELAYIDLESLEEP = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define PROC_SELFSET_DELAYIDLESLEEP 4
     * }
     */
    public static int PROC_SELFSET_DELAYIDLESLEEP() {
        return PROC_SELFSET_DELAYIDLESLEEP;
    }

    private static final int PROC_DIRTYCONTROL_TRACK = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_DIRTYCONTROL_TRACK 1
     * }
     */
    public static int PROC_DIRTYCONTROL_TRACK() {
        return PROC_DIRTYCONTROL_TRACK;
    }

    private static final int PROC_DIRTYCONTROL_SET = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_DIRTYCONTROL_SET 2
     * }
     */
    public static int PROC_DIRTYCONTROL_SET() {
        return PROC_DIRTYCONTROL_SET;
    }

    private static final int PROC_DIRTYCONTROL_GET = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define PROC_DIRTYCONTROL_GET 3
     * }
     */
    public static int PROC_DIRTYCONTROL_GET() {
        return PROC_DIRTYCONTROL_GET;
    }

    private static final int PROC_DIRTYCONTROL_CLEAR = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define PROC_DIRTYCONTROL_CLEAR 4
     * }
     */
    public static int PROC_DIRTYCONTROL_CLEAR() {
        return PROC_DIRTYCONTROL_CLEAR;
    }

    private static final int PROC_DIRTY_TRACK = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_DIRTY_TRACK 1
     * }
     */
    public static int PROC_DIRTY_TRACK() {
        return PROC_DIRTY_TRACK;
    }

    private static final int PROC_DIRTY_ALLOW_IDLE_EXIT = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_DIRTY_ALLOW_IDLE_EXIT 2
     * }
     */
    public static int PROC_DIRTY_ALLOW_IDLE_EXIT() {
        return PROC_DIRTY_ALLOW_IDLE_EXIT;
    }

    private static final int PROC_DIRTY_DEFER = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define PROC_DIRTY_DEFER 4
     * }
     */
    public static int PROC_DIRTY_DEFER() {
        return PROC_DIRTY_DEFER;
    }

    private static final int PROC_DIRTY_LAUNCH_IN_PROGRESS = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define PROC_DIRTY_LAUNCH_IN_PROGRESS 8
     * }
     */
    public static int PROC_DIRTY_LAUNCH_IN_PROGRESS() {
        return PROC_DIRTY_LAUNCH_IN_PROGRESS;
    }

    private static final int PROC_DIRTY_DEFER_ALWAYS = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define PROC_DIRTY_DEFER_ALWAYS 16
     * }
     */
    public static int PROC_DIRTY_DEFER_ALWAYS() {
        return PROC_DIRTY_DEFER_ALWAYS;
    }

    private static final int PROC_DIRTY_TRACKED = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_DIRTY_TRACKED 1
     * }
     */
    public static int PROC_DIRTY_TRACKED() {
        return PROC_DIRTY_TRACKED;
    }

    private static final int PROC_DIRTY_ALLOWS_IDLE_EXIT = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_DIRTY_ALLOWS_IDLE_EXIT 2
     * }
     */
    public static int PROC_DIRTY_ALLOWS_IDLE_EXIT() {
        return PROC_DIRTY_ALLOWS_IDLE_EXIT;
    }

    private static final int PROC_DIRTY_IS_DIRTY = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define PROC_DIRTY_IS_DIRTY 4
     * }
     */
    public static int PROC_DIRTY_IS_DIRTY() {
        return PROC_DIRTY_IS_DIRTY;
    }

    private static final int PROC_DIRTY_LAUNCH_IS_IN_PROGRESS = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define PROC_DIRTY_LAUNCH_IS_IN_PROGRESS 8
     * }
     */
    public static int PROC_DIRTY_LAUNCH_IS_IN_PROGRESS() {
        return PROC_DIRTY_LAUNCH_IS_IN_PROGRESS;
    }

    private static final int PROC_UDATA_INFO_GET = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_UDATA_INFO_GET 1
     * }
     */
    public static int PROC_UDATA_INFO_GET() {
        return PROC_UDATA_INFO_GET;
    }

    private static final int PROC_UDATA_INFO_SET = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_UDATA_INFO_SET 2
     * }
     */
    public static int PROC_UDATA_INFO_SET() {
        return PROC_UDATA_INFO_SET;
    }

    private static final int API_TO_BE_DEPRECATED = (int) 100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED() {
        return API_TO_BE_DEPRECATED;
    }

    private static final int API_TO_BE_DEPRECATED_MACOS = (int) 100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_MACOS 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_MACOS() {
        return API_TO_BE_DEPRECATED_MACOS;
    }

    private static final int API_TO_BE_DEPRECATED_IOS = (int) 100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_IOS 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_IOS() {
        return API_TO_BE_DEPRECATED_IOS;
    }

    private static final int API_TO_BE_DEPRECATED_TVOS = (int) 100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_TVOS 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_TVOS() {
        return API_TO_BE_DEPRECATED_TVOS;
    }

    private static final int API_TO_BE_DEPRECATED_WATCHOS = (int) 100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_WATCHOS 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_WATCHOS() {
        return API_TO_BE_DEPRECATED_WATCHOS;
    }

    private static final int API_TO_BE_DEPRECATED_DRIVERKIT = (int) 100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_DRIVERKIT 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_DRIVERKIT() {
        return API_TO_BE_DEPRECATED_DRIVERKIT;
    }

    private static final int API_TO_BE_DEPRECATED_VISIONOS = (int) 100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_VISIONOS 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_VISIONOS() {
        return API_TO_BE_DEPRECATED_VISIONOS;
    }

    private static final int PROC_LISTPIDSPATH_PATH_IS_VOLUME = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_LISTPIDSPATH_PATH_IS_VOLUME 1
     * }
     */
    public static int PROC_LISTPIDSPATH_PATH_IS_VOLUME() {
        return PROC_LISTPIDSPATH_PATH_IS_VOLUME;
    }

    private static final int PROC_LISTPIDSPATH_EXCLUDE_EVTONLY = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_LISTPIDSPATH_EXCLUDE_EVTONLY 2
     * }
     */
    public static int PROC_LISTPIDSPATH_EXCLUDE_EVTONLY() {
        return PROC_LISTPIDSPATH_EXCLUDE_EVTONLY;
    }

    private static final int PROC_SETPC_NONE = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define PROC_SETPC_NONE 0
     * }
     */
    public static int PROC_SETPC_NONE() {
        return PROC_SETPC_NONE;
    }

    private static final int PROC_SETPC_THROTTLEMEM = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_SETPC_THROTTLEMEM 1
     * }
     */
    public static int PROC_SETPC_THROTTLEMEM() {
        return PROC_SETPC_THROTTLEMEM;
    }

    private static final int PROC_SETPC_SUSPEND = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_SETPC_SUSPEND 2
     * }
     */
    public static int PROC_SETPC_SUSPEND() {
        return PROC_SETPC_SUSPEND;
    }

    private static final int PROC_SETPC_TERMINATE = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define PROC_SETPC_TERMINATE 3
     * }
     */
    public static int PROC_SETPC_TERMINATE() {
        return PROC_SETPC_TERMINATE;
    }

    private static final int PROC_CSM_ALL = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_CSM_ALL 1
     * }
     */
    public static int PROC_CSM_ALL() {
        return PROC_CSM_ALL;
    }

    private static final int PROC_CSM_NOSMT = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_CSM_NOSMT 2
     * }
     */
    public static int PROC_CSM_NOSMT() {
        return PROC_CSM_NOSMT;
    }

    private static final int PROC_CSM_TECS = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define PROC_CSM_TECS 4
     * }
     */
    public static int PROC_CSM_TECS() {
        return PROC_CSM_TECS;
    }
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = libproc_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = libproc_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __int64_t
     * }
     */
    public static final OfLong __int64_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_intptr_t
     * }
     */
    public static final OfLong __darwin_intptr_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_natural_t
     * }
     */
    public static final OfInt __darwin_natural_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_ct_rune_t
     * }
     */
    public static final OfInt __darwin_ct_rune_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ptrdiff_t
     * }
     */
    public static final OfLong __darwin_ptrdiff_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_size_t
     * }
     */
    public static final OfLong __darwin_size_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __darwin_va_list
     * }
     */
    public static final AddressLayout __darwin_va_list = libproc_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wchar_t
     * }
     */
    public static final OfInt __darwin_wchar_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t __darwin_rune_t
     * }
     */
    public static final OfInt __darwin_rune_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wint_t
     * }
     */
    public static final OfInt __darwin_wint_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_clock_t
     * }
     */
    public static final OfLong __darwin_clock_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_socklen_t
     * }
     */
    public static final OfInt __darwin_socklen_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ssize_t
     * }
     */
    public static final OfLong __darwin_ssize_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_time_t
     * }
     */
    public static final OfLong __darwin_time_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = libproc_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = libproc_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = libproc_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t register_t
     * }
     */
    public static final OfLong register_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_addr_t
     * }
     */
    public static final OfLong user_addr_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_size_t
     * }
     */
    public static final OfLong user_size_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_ssize_t
     * }
     */
    public static final OfLong user_ssize_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_long_t
     * }
     */
    public static final OfLong user_long_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_ulong_t
     * }
     */
    public static final OfLong user_ulong_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_time_t
     * }
     */
    public static final OfLong user_time_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_off_t
     * }
     */
    public static final OfLong user_off_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t syscall_arg_t
     * }
     */
    public static final OfLong syscall_arg_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = libproc_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = libproc_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = libproc_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = libproc_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = libproc_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_char
     * }
     */
    public static final OfByte u_char = libproc_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_short
     * }
     */
    public static final OfShort u_short = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int
     * }
     */
    public static final OfInt u_int = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long u_long
     * }
     */
    public static final OfLong u_long = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t quad_t
     * }
     */
    public static final OfLong quad_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef quad_t *qaddr_t
     * }
     */
    public static final AddressLayout qaddr_t = libproc_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef char *caddr_t
     * }
     */
    public static final AddressLayout caddr_t = libproc_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int32_t daddr_t
     * }
     */
    public static final OfInt daddr_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_dev_t dev_t
     * }
     */
    public static final OfInt dev_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fixpt_t
     * }
     */
    public static final OfInt fixpt_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blksize_t blksize_t
     * }
     */
    public static final OfInt blksize_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_gid_t gid_t
     * }
     */
    public static final OfInt gid_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t in_addr_t
     * }
     */
    public static final OfInt in_addr_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t in_port_t
     * }
     */
    public static final OfShort in_port_t = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino_t ino_t
     * }
     */
    public static final OfLong ino_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t ino64_t
     * }
     */
    public static final OfLong ino64_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t key_t
     * }
     */
    public static final OfInt key_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mode_t mode_t
     * }
     */
    public static final OfShort mode_t = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t nlink_t
     * }
     */
    public static final OfShort nlink_t = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_id_t id_t
     * }
     */
    public static final OfInt id_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pid_t pid_t
     * }
     */
    public static final OfInt pid_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t off_t
     * }
     */
    public static final OfLong off_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int32_t segsz_t
     * }
     */
    public static final OfInt segsz_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t swblk_t
     * }
     */
    public static final OfInt swblk_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_uid_t uid_t
     * }
     */
    public static final OfInt uid_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_clock_t clock_t
     * }
     */
    public static final OfLong clock_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t size_t
     * }
     */
    public static final OfLong size_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_time_t time_t
     * }
     */
    public static final OfLong time_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_useconds_t useconds_t
     * }
     */
    public static final OfInt useconds_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_suseconds_t suseconds_t
     * }
     */
    public static final OfInt suseconds_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = libproc_h.C_INT;

    private static class __darwin_check_fd_set_overflow {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("__darwin_check_fd_set_overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static FunctionDescriptor __darwin_check_fd_set_overflow$descriptor() {
        return __darwin_check_fd_set_overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MethodHandle __darwin_check_fd_set_overflow$handle() {
        return __darwin_check_fd_set_overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MemorySegment __darwin_check_fd_set_overflow$address() {
        return __darwin_check_fd_set_overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static int __darwin_check_fd_set_overflow(int x0, MemorySegment x1, int x2) {
        var mh$ = __darwin_check_fd_set_overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__darwin_check_fd_set_overflow", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __int32_t fd_mask
     * }
     */
    public static final OfInt fd_mask = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_t pthread_t
     * }
     */
    public static final AddressLayout pthread_t = libproc_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_key_t pthread_key_t
     * }
     */
    public static final OfLong pthread_key_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfInt fsblkcnt_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfInt fsfilcnt_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int sig_atomic_t
     * }
     */
    public static final OfInt sig_atomic_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct __darwin_mcontext64 {
     *     struct __darwin_arm_exception_state64 __es;
     *     struct __darwin_arm_thread_state64 __ss;
     *     struct __darwin_arm_neon_state64 __ns;
     * } *mcontext_t
     * }
     */
    public static final AddressLayout mcontext_t = libproc_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_sigset_t sigset_t
     * }
     */
    public static final OfInt sigset_t = libproc_h.C_INT;

    private static class signal {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_POINTER, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal(int x0, MemorySegment x1) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chmod {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_SHORT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("chmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor chmod$descriptor() {
        return chmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static MethodHandle chmod$handle() {
        return chmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static MemorySegment chmod$address() {
        return chmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static int chmod(MemorySegment x0, short x1) {
        var mh$ = chmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chmod", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmod {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_SHORT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("fchmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static FunctionDescriptor fchmod$descriptor() {
        return fchmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static MethodHandle fchmod$handle() {
        return fchmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static MemorySegment fchmod$address() {
        return fchmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static int fchmod(int x0, short x1) {
        var mh$ = fchmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmod", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstat {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("fstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static FunctionDescriptor fstat$descriptor() {
        return fstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static MethodHandle fstat$handle() {
        return fstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static MemorySegment fstat$address() {
        return fstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static int fstat(int x0, MemorySegment x1) {
        var mh$ = fstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstat", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstat {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("lstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static FunctionDescriptor lstat$descriptor() {
        return lstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static MethodHandle lstat$handle() {
        return lstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static MemorySegment lstat$address() {
        return lstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static int lstat(MemorySegment x0, MemorySegment x1) {
        var mh$ = lstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstat", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdir {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_SHORT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("mkdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkdir$descriptor() {
        return mkdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static MethodHandle mkdir$handle() {
        return mkdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static MemorySegment mkdir$address() {
        return mkdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static int mkdir(MemorySegment x0, short x1) {
        var mh$ = mkdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdir", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifo {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_SHORT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("mkfifo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkfifo$descriptor() {
        return mkfifo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static MethodHandle mkfifo$handle() {
        return mkfifo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static MemorySegment mkfifo$address() {
        return mkfifo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static int mkfifo(MemorySegment x0, short x1) {
        var mh$ = mkfifo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifo", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stat {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("stat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static FunctionDescriptor stat$descriptor() {
        return stat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static MethodHandle stat$handle() {
        return stat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static MemorySegment stat$address() {
        return stat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static int stat(MemorySegment x0, MemorySegment x1) {
        var mh$ = stat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stat", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mknod {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_SHORT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("mknod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static FunctionDescriptor mknod$descriptor() {
        return mknod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static MethodHandle mknod$handle() {
        return mknod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static MemorySegment mknod$address() {
        return mknod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static int mknod(MemorySegment x0, short x1, int x2) {
        var mh$ = mknod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mknod", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_SHORT, libproc_h.C_SHORT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("umask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static FunctionDescriptor umask$descriptor() {
        return umask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static MethodHandle umask$handle() {
        return umask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static MemorySegment umask$address() {
        return umask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static short umask(short x0) {
        var mh$ = umask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umask", x0);
            }
            return (short) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmodat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_SHORT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("fchmodat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static FunctionDescriptor fchmodat$descriptor() {
        return fchmodat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static MethodHandle fchmodat$handle() {
        return fchmodat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static MemorySegment fchmodat$address() {
        return fchmodat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static int fchmodat(int x0, MemorySegment x1, short x2, int x3) {
        var mh$ = fchmodat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmodat", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstatat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("fstatat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static FunctionDescriptor fstatat$descriptor() {
        return fstatat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static MethodHandle fstatat$handle() {
        return fstatat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static MemorySegment fstatat$address() {
        return fstatat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static int fstatat(int x0, MemorySegment x1, MemorySegment x2, int x3) {
        var mh$ = fstatat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstatat", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdirat {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_SHORT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("mkdirat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkdirat$descriptor() {
        return mkdirat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static MethodHandle mkdirat$handle() {
        return mkdirat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static MemorySegment mkdirat$address() {
        return mkdirat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static int mkdirat(int x0, MemorySegment x1, short x2) {
        var mh$ = mkdirat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdirat", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifoat {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_SHORT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("mkfifoat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkfifoat$descriptor() {
        return mkfifoat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static MethodHandle mkfifoat$handle() {
        return mkfifoat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static MemorySegment mkfifoat$address() {
        return mkfifoat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static int mkfifoat(int x0, MemorySegment x1, short x2) {
        var mh$ = mkfifoat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifoat", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mknodat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_SHORT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("mknodat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static FunctionDescriptor mknodat$descriptor() {
        return mknodat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static MethodHandle mknodat$handle() {
        return mknodat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static MemorySegment mknodat$address() {
        return mknodat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static int mknodat(int x0, MemorySegment x1, short x2, int x3) {
        var mh$ = mknodat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mknodat", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class futimens {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("futimens");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static FunctionDescriptor futimens$descriptor() {
        return futimens.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static MethodHandle futimens$handle() {
        return futimens.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static MemorySegment futimens$address() {
        return futimens.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static int futimens(int __fd, MemorySegment __times) {
        var mh$ = futimens.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("futimens", __fd, __times);
            }
            return (int) mh$.invokeExact(__fd, __times);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class utimensat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("utimensat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static FunctionDescriptor utimensat$descriptor() {
        return utimensat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static MethodHandle utimensat$handle() {
        return utimensat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static MemorySegment utimensat$address() {
        return utimensat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static int utimensat(int __fd, MemorySegment __path, MemorySegment __times, int __flag) {
        var mh$ = utimensat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("utimensat", __fd, __path, __times, __flag);
            }
            return (int) mh$.invokeExact(__fd, __path, __times, __flag);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _filesec *filesec_t
     * }
     */
    public static final AddressLayout filesec_t = libproc_h.C_POINTER;

    private static class chflags {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("chflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static FunctionDescriptor chflags$descriptor() {
        return chflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static MethodHandle chflags$handle() {
        return chflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static MemorySegment chflags$address() {
        return chflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static int chflags(MemorySegment x0, int x1) {
        var mh$ = chflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chflags", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chmodx_np {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("chmodx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static FunctionDescriptor chmodx_np$descriptor() {
        return chmodx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static MethodHandle chmodx_np$handle() {
        return chmodx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static MemorySegment chmodx_np$address() {
        return chmodx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static int chmodx_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = chmodx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chmodx_np", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchflags {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("fchflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static FunctionDescriptor fchflags$descriptor() {
        return fchflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static MethodHandle fchflags$handle() {
        return fchflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static MemorySegment fchflags$address() {
        return fchflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static int fchflags(int x0, int x1) {
        var mh$ = fchflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchflags", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmodx_np {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("fchmodx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static FunctionDescriptor fchmodx_np$descriptor() {
        return fchmodx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static MethodHandle fchmodx_np$handle() {
        return fchmodx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static MemorySegment fchmodx_np$address() {
        return fchmodx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static int fchmodx_np(int x0, MemorySegment x1) {
        var mh$ = fchmodx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmodx_np", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstatx_np {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("fstatx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static FunctionDescriptor fstatx_np$descriptor() {
        return fstatx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static MethodHandle fstatx_np$handle() {
        return fstatx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static MemorySegment fstatx_np$address() {
        return fstatx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static int fstatx_np(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = fstatx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstatx_np", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchflags {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("lchflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static FunctionDescriptor lchflags$descriptor() {
        return lchflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static MethodHandle lchflags$handle() {
        return lchflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static MemorySegment lchflags$address() {
        return lchflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static int lchflags(MemorySegment x0, int x1) {
        var mh$ = lchflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchflags", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchmod {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_SHORT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("lchmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor lchmod$descriptor() {
        return lchmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static MethodHandle lchmod$handle() {
        return lchmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static MemorySegment lchmod$address() {
        return lchmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static int lchmod(MemorySegment x0, short x1) {
        var mh$ = lchmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchmod", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstatx_np {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("lstatx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static FunctionDescriptor lstatx_np$descriptor() {
        return lstatx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MethodHandle lstatx_np$handle() {
        return lstatx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MemorySegment lstatx_np$address() {
        return lstatx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static int lstatx_np(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = lstatx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstatx_np", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdirx_np {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("mkdirx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static FunctionDescriptor mkdirx_np$descriptor() {
        return mkdirx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static MethodHandle mkdirx_np$handle() {
        return mkdirx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static MemorySegment mkdirx_np$address() {
        return mkdirx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static int mkdirx_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = mkdirx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdirx_np", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifox_np {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("mkfifox_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static FunctionDescriptor mkfifox_np$descriptor() {
        return mkfifox_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static MethodHandle mkfifox_np$handle() {
        return mkfifox_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static MemorySegment mkfifox_np$address() {
        return mkfifox_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static int mkfifox_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = mkfifox_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifox_np", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class statx_np {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("statx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static FunctionDescriptor statx_np$descriptor() {
        return statx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MethodHandle statx_np$handle() {
        return statx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MemorySegment statx_np$address() {
        return statx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static int statx_np(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = statx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("statx_np", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umaskx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("umaskx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static FunctionDescriptor umaskx_np$descriptor() {
        return umaskx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static MethodHandle umaskx_np$handle() {
        return umaskx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static MemorySegment umaskx_np$address() {
        return umaskx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static int umaskx_np(MemorySegment x0) {
        var mh$ = umaskx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umaskx_np", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uid_t au_id_t
     * }
     */
    public static final OfInt au_id_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef pid_t au_asid_t
     * }
     */
    public static final OfInt au_asid_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int16_t au_event_t
     * }
     */
    public static final OfShort au_event_t = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef u_int16_t au_emod_t
     * }
     */
    public static final OfShort au_emod_t = libproc_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t au_class_t
     * }
     */
    public static final OfInt au_class_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t au_asflgs_t
     * }
     */
    public static final OfLong au_asflgs_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char au_ctlmode_t
     * }
     */
    public static final OfByte au_ctlmode_t = libproc_h.C_CHAR;

    private static final int AU_SESSION_FLAG_IS_INITIAL = (int) 1L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_IS_INITIAL = 1
     * }
     */
    public static int AU_SESSION_FLAG_IS_INITIAL() {
        return AU_SESSION_FLAG_IS_INITIAL;
    }

    private static final int AU_SESSION_FLAG_HAS_GRAPHIC_ACCESS = (int) 16L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_HAS_GRAPHIC_ACCESS = 16
     * }
     */
    public static int AU_SESSION_FLAG_HAS_GRAPHIC_ACCESS() {
        return AU_SESSION_FLAG_HAS_GRAPHIC_ACCESS;
    }

    private static final int AU_SESSION_FLAG_HAS_TTY = (int) 32L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_HAS_TTY = 32
     * }
     */
    public static int AU_SESSION_FLAG_HAS_TTY() {
        return AU_SESSION_FLAG_HAS_TTY;
    }

    private static final int AU_SESSION_FLAG_IS_REMOTE = (int) 4096L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_IS_REMOTE = 4096
     * }
     */
    public static int AU_SESSION_FLAG_IS_REMOTE() {
        return AU_SESSION_FLAG_IS_REMOTE;
    }

    private static final int AU_SESSION_FLAG_HAS_CONSOLE_ACCESS = (int) 8192L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_HAS_CONSOLE_ACCESS = 8192
     * }
     */
    public static int AU_SESSION_FLAG_HAS_CONSOLE_ACCESS() {
        return AU_SESSION_FLAG_HAS_CONSOLE_ACCESS;
    }

    private static final int AU_SESSION_FLAG_HAS_AUTHENTICATED = (int) 16384L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_HAS_AUTHENTICATED = 16384
     * }
     */
    public static int AU_SESSION_FLAG_HAS_AUTHENTICATED() {
        return AU_SESSION_FLAG_HAS_AUTHENTICATED;
    }

    private static class audit {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("audit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int audit(const void *, int)
     * }
     */
    public static FunctionDescriptor audit$descriptor() {
        return audit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int audit(const void *, int)
     * }
     */
    public static MethodHandle audit$handle() {
        return audit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int audit(const void *, int)
     * }
     */
    public static MemorySegment audit$address() {
        return audit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int audit(const void *, int)
     * }
     */
    public static int audit(MemorySegment x0, int x1) {
        var mh$ = audit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("audit", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class auditon {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("auditon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int auditon(int, void *, int)
     * }
     */
    public static FunctionDescriptor auditon$descriptor() {
        return auditon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int auditon(int, void *, int)
     * }
     */
    public static MethodHandle auditon$handle() {
        return auditon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int auditon(int, void *, int)
     * }
     */
    public static MemorySegment auditon$address() {
        return auditon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int auditon(int, void *, int)
     * }
     */
    public static int auditon(int x0, MemorySegment x1, int x2) {
        var mh$ = auditon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("auditon", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class auditctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("auditctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int auditctl(const char *)
     * }
     */
    public static FunctionDescriptor auditctl$descriptor() {
        return auditctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int auditctl(const char *)
     * }
     */
    public static MethodHandle auditctl$handle() {
        return auditctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int auditctl(const char *)
     * }
     */
    public static MemorySegment auditctl$address() {
        return auditctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int auditctl(const char *)
     * }
     */
    public static int auditctl(MemorySegment x0) {
        var mh$ = auditctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("auditctl", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getauid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getauid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getauid(au_id_t *)
     * }
     */
    public static FunctionDescriptor getauid$descriptor() {
        return getauid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getauid(au_id_t *)
     * }
     */
    public static MethodHandle getauid$handle() {
        return getauid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getauid(au_id_t *)
     * }
     */
    public static MemorySegment getauid$address() {
        return getauid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getauid(au_id_t *)
     * }
     */
    public static int getauid(MemorySegment x0) {
        var mh$ = getauid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getauid", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setauid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("setauid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setauid(const au_id_t *)
     * }
     */
    public static FunctionDescriptor setauid$descriptor() {
        return setauid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setauid(const au_id_t *)
     * }
     */
    public static MethodHandle setauid$handle() {
        return setauid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setauid(const au_id_t *)
     * }
     */
    public static MemorySegment setauid$address() {
        return setauid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setauid(const au_id_t *)
     * }
     */
    public static int setauid(MemorySegment x0) {
        var mh$ = setauid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setauid", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getaudit_addr {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getaudit_addr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getaudit_addr(struct auditinfo_addr *, int)
     * }
     */
    public static FunctionDescriptor getaudit_addr$descriptor() {
        return getaudit_addr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getaudit_addr(struct auditinfo_addr *, int)
     * }
     */
    public static MethodHandle getaudit_addr$handle() {
        return getaudit_addr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getaudit_addr(struct auditinfo_addr *, int)
     * }
     */
    public static MemorySegment getaudit_addr$address() {
        return getaudit_addr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getaudit_addr(struct auditinfo_addr *, int)
     * }
     */
    public static int getaudit_addr(MemorySegment x0, int x1) {
        var mh$ = getaudit_addr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getaudit_addr", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setaudit_addr {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("setaudit_addr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setaudit_addr(const struct auditinfo_addr *, int)
     * }
     */
    public static FunctionDescriptor setaudit_addr$descriptor() {
        return setaudit_addr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setaudit_addr(const struct auditinfo_addr *, int)
     * }
     */
    public static MethodHandle setaudit_addr$handle() {
        return setaudit_addr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setaudit_addr(const struct auditinfo_addr *, int)
     * }
     */
    public static MemorySegment setaudit_addr$address() {
        return setaudit_addr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setaudit_addr(const struct auditinfo_addr *, int)
     * }
     */
    public static int setaudit_addr(MemorySegment x0, int x1) {
        var mh$ = setaudit_addr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setaudit_addr", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getaudit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getaudit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getaudit(struct auditinfo *)
     * }
     */
    public static FunctionDescriptor getaudit$descriptor() {
        return getaudit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getaudit(struct auditinfo *)
     * }
     */
    public static MethodHandle getaudit$handle() {
        return getaudit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getaudit(struct auditinfo *)
     * }
     */
    public static MemorySegment getaudit$address() {
        return getaudit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getaudit(struct auditinfo *)
     * }
     */
    public static int getaudit(MemorySegment x0) {
        var mh$ = getaudit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getaudit", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setaudit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("setaudit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setaudit(const struct auditinfo *)
     * }
     */
    public static FunctionDescriptor setaudit$descriptor() {
        return setaudit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setaudit(const struct auditinfo *)
     * }
     */
    public static MethodHandle setaudit$handle() {
        return setaudit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setaudit(const struct auditinfo *)
     * }
     */
    public static MemorySegment setaudit$address() {
        return setaudit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setaudit(const struct auditinfo *)
     * }
     */
    public static int setaudit(MemorySegment x0) {
        var mh$ = setaudit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setaudit", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int boolean_t
     * }
     */
    public static final OfInt boolean_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t natural_t
     * }
     */
    public static final OfInt natural_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int integer_t
     * }
     */
    public static final OfInt integer_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t vm_offset_t
     * }
     */
    public static final OfLong vm_offset_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t vm_size_t
     * }
     */
    public static final OfLong vm_size_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t mach_vm_address_t
     * }
     */
    public static final OfLong mach_vm_address_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t mach_vm_offset_t
     * }
     */
    public static final OfLong mach_vm_offset_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t mach_vm_size_t
     * }
     */
    public static final OfLong mach_vm_size_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_map_offset_t
     * }
     */
    public static final OfLong vm_map_offset_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_map_address_t
     * }
     */
    public static final OfLong vm_map_address_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_map_size_t
     * }
     */
    public static final OfLong vm_map_size_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_offset_t
     * }
     */
    public static final OfInt vm32_offset_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_address_t
     * }
     */
    public static final OfInt vm32_address_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_size_t
     * }
     */
    public static final OfInt vm32_size_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef vm_offset_t mach_port_context_t
     * }
     */
    public static final OfLong mach_port_context_t = libproc_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_name_t
     * }
     */
    public static final OfInt mach_port_name_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_name_t *mach_port_name_array_t
     * }
     */
    public static final AddressLayout mach_port_name_array_t = libproc_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_t mach_port_t
     * }
     */
    public static final OfInt mach_port_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t *mach_port_array_t
     * }
     */
    public static final AddressLayout mach_port_array_t = libproc_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_right_t
     * }
     */
    public static final OfInt mach_port_right_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_type_t
     * }
     */
    public static final OfInt mach_port_type_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_type_t *mach_port_type_array_t
     * }
     */
    public static final AddressLayout mach_port_type_array_t = libproc_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_urefs_t
     * }
     */
    public static final OfInt mach_port_urefs_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_port_delta_t
     * }
     */
    public static final OfInt mach_port_delta_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_seqno_t
     * }
     */
    public static final OfInt mach_port_seqno_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_mscount_t
     * }
     */
    public static final OfInt mach_port_mscount_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_msgcount_t
     * }
     */
    public static final OfInt mach_port_msgcount_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_rights_t
     * }
     */
    public static final OfInt mach_port_rights_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_port_srights_t
     * }
     */
    public static final OfInt mach_port_srights_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *mach_port_info_t
     * }
     */
    public static final AddressLayout mach_port_info_t = libproc_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int mach_port_flavor_t
     * }
     */
    public static final OfInt mach_port_flavor_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct mach_service_port_info {
     *     char mspi_string_name[255];
     *     uint8_t mspi_domain_type;
     * } *mach_service_port_info_t
     * }
     */
    public static final AddressLayout mach_service_port_info_t = libproc_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef mach_port_options_t *mach_port_options_ptr_t
     * }
     */
    public static final AddressLayout mach_port_options_ptr_t = libproc_h.C_POINTER;

    private static final int kGUARD_EXC_DESTROY = (int) 1L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_DESTROY = 1
     * }
     */
    public static int kGUARD_EXC_DESTROY() {
        return kGUARD_EXC_DESTROY;
    }

    private static final int kGUARD_EXC_MOD_REFS = (int) 2L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MOD_REFS = 2
     * }
     */
    public static int kGUARD_EXC_MOD_REFS() {
        return kGUARD_EXC_MOD_REFS;
    }

    private static final int kGUARD_EXC_INVALID_OPTIONS = (int) 3L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_OPTIONS = 3
     * }
     */
    public static int kGUARD_EXC_INVALID_OPTIONS() {
        return kGUARD_EXC_INVALID_OPTIONS;
    }

    private static final int kGUARD_EXC_SET_CONTEXT = (int) 4L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SET_CONTEXT = 4
     * }
     */
    public static int kGUARD_EXC_SET_CONTEXT() {
        return kGUARD_EXC_SET_CONTEXT;
    }

    private static final int kGUARD_EXC_THREAD_SET_STATE = (int) 5L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_THREAD_SET_STATE = 5
     * }
     */
    public static int kGUARD_EXC_THREAD_SET_STATE() {
        return kGUARD_EXC_THREAD_SET_STATE;
    }

    private static final int kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE = (int) 6L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE = 6
     * }
     */
    public static int kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE() {
        return kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE;
    }

    private static final int kGUARD_EXC_UNGUARDED = (int) 8L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_UNGUARDED = 8
     * }
     */
    public static int kGUARD_EXC_UNGUARDED() {
        return kGUARD_EXC_UNGUARDED;
    }

    private static final int kGUARD_EXC_INCORRECT_GUARD = (int) 16L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INCORRECT_GUARD = 16
     * }
     */
    public static int kGUARD_EXC_INCORRECT_GUARD() {
        return kGUARD_EXC_INCORRECT_GUARD;
    }

    private static final int kGUARD_EXC_IMMOVABLE = (int) 32L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_IMMOVABLE = 32
     * }
     */
    public static int kGUARD_EXC_IMMOVABLE() {
        return kGUARD_EXC_IMMOVABLE;
    }

    private static final int kGUARD_EXC_STRICT_REPLY = (int) 64L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_STRICT_REPLY = 64
     * }
     */
    public static int kGUARD_EXC_STRICT_REPLY() {
        return kGUARD_EXC_STRICT_REPLY;
    }

    private static final int kGUARD_EXC_MSG_FILTERED = (int) 128L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MSG_FILTERED = 128
     * }
     */
    public static int kGUARD_EXC_MSG_FILTERED() {
        return kGUARD_EXC_MSG_FILTERED;
    }

    private static final int kGUARD_EXC_INVALID_RIGHT = (int) 256L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_RIGHT = 256
     * }
     */
    public static int kGUARD_EXC_INVALID_RIGHT() {
        return kGUARD_EXC_INVALID_RIGHT;
    }

    private static final int kGUARD_EXC_INVALID_NAME = (int) 512L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_NAME = 512
     * }
     */
    public static int kGUARD_EXC_INVALID_NAME() {
        return kGUARD_EXC_INVALID_NAME;
    }

    private static final int kGUARD_EXC_INVALID_VALUE = (int) 1024L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_VALUE = 1024
     * }
     */
    public static int kGUARD_EXC_INVALID_VALUE() {
        return kGUARD_EXC_INVALID_VALUE;
    }

    private static final int kGUARD_EXC_INVALID_ARGUMENT = (int) 2048L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_ARGUMENT = 2048
     * }
     */
    public static int kGUARD_EXC_INVALID_ARGUMENT() {
        return kGUARD_EXC_INVALID_ARGUMENT;
    }

    private static final int kGUARD_EXC_RIGHT_EXISTS = (int) 4096L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RIGHT_EXISTS = 4096
     * }
     */
    public static int kGUARD_EXC_RIGHT_EXISTS() {
        return kGUARD_EXC_RIGHT_EXISTS;
    }

    private static final int kGUARD_EXC_KERN_NO_SPACE = (int) 8192L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_NO_SPACE = 8192
     * }
     */
    public static int kGUARD_EXC_KERN_NO_SPACE() {
        return kGUARD_EXC_KERN_NO_SPACE;
    }

    private static final int kGUARD_EXC_KERN_FAILURE = (int) 16384L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_FAILURE = 16384
     * }
     */
    public static int kGUARD_EXC_KERN_FAILURE() {
        return kGUARD_EXC_KERN_FAILURE;
    }

    private static final int kGUARD_EXC_KERN_RESOURCE = (int) 32768L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_RESOURCE = 32768
     * }
     */
    public static int kGUARD_EXC_KERN_RESOURCE() {
        return kGUARD_EXC_KERN_RESOURCE;
    }

    private static final int kGUARD_EXC_SEND_INVALID_REPLY = (int) 65536L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_REPLY = 65536
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_REPLY() {
        return kGUARD_EXC_SEND_INVALID_REPLY;
    }

    private static final int kGUARD_EXC_SEND_INVALID_VOUCHER = (int) 131072L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_VOUCHER = 131072
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_VOUCHER() {
        return kGUARD_EXC_SEND_INVALID_VOUCHER;
    }

    private static final int kGUARD_EXC_SEND_INVALID_RIGHT = (int) 262144L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_RIGHT = 262144
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_RIGHT() {
        return kGUARD_EXC_SEND_INVALID_RIGHT;
    }

    private static final int kGUARD_EXC_RCV_INVALID_NAME = (int) 524288L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RCV_INVALID_NAME = 524288
     * }
     */
    public static int kGUARD_EXC_RCV_INVALID_NAME() {
        return kGUARD_EXC_RCV_INVALID_NAME;
    }

    private static final int kGUARD_EXC_RCV_GUARDED_DESC = (int) 1048576L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RCV_GUARDED_DESC = 1048576
     * }
     */
    public static int kGUARD_EXC_RCV_GUARDED_DESC() {
        return kGUARD_EXC_RCV_GUARDED_DESC;
    }

    private static final int kGUARD_EXC_MOD_REFS_NON_FATAL = (int) 2097152L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MOD_REFS_NON_FATAL = 2097152
     * }
     */
    public static int kGUARD_EXC_MOD_REFS_NON_FATAL() {
        return kGUARD_EXC_MOD_REFS_NON_FATAL;
    }

    private static final int kGUARD_EXC_IMMOVABLE_NON_FATAL = (int) 4194304L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_IMMOVABLE_NON_FATAL = 4194304
     * }
     */
    public static int kGUARD_EXC_IMMOVABLE_NON_FATAL() {
        return kGUARD_EXC_IMMOVABLE_NON_FATAL;
    }

    private static final int kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS = (int) 8388608L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS = 8388608
     * }
     */
    public static int kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS() {
        return kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS;
    }

    private static class audit_session_self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("audit_session_self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mach_port_name_t audit_session_self()
     * }
     */
    public static FunctionDescriptor audit_session_self$descriptor() {
        return audit_session_self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mach_port_name_t audit_session_self()
     * }
     */
    public static MethodHandle audit_session_self$handle() {
        return audit_session_self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mach_port_name_t audit_session_self()
     * }
     */
    public static MemorySegment audit_session_self$address() {
        return audit_session_self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mach_port_name_t audit_session_self()
     * }
     */
    public static int audit_session_self() {
        var mh$ = audit_session_self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("audit_session_self");
            }
            return (int) mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class audit_session_join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("audit_session_join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * au_asid_t audit_session_join(mach_port_name_t port)
     * }
     */
    public static FunctionDescriptor audit_session_join$descriptor() {
        return audit_session_join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * au_asid_t audit_session_join(mach_port_name_t port)
     * }
     */
    public static MethodHandle audit_session_join$handle() {
        return audit_session_join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * au_asid_t audit_session_join(mach_port_name_t port)
     * }
     */
    public static MemorySegment audit_session_join$address() {
        return audit_session_join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * au_asid_t audit_session_join(mach_port_name_t port)
     * }
     */
    public static int audit_session_join(int port) {
        var mh$ = audit_session_join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("audit_session_join", port);
            }
            return (int) mh$.invokeExact(port);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class audit_session_port {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("audit_session_port");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int audit_session_port(au_asid_t asid, mach_port_name_t *portname)
     * }
     */
    public static FunctionDescriptor audit_session_port$descriptor() {
        return audit_session_port.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int audit_session_port(au_asid_t asid, mach_port_name_t *portname)
     * }
     */
    public static MethodHandle audit_session_port$handle() {
        return audit_session_port.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int audit_session_port(au_asid_t asid, mach_port_name_t *portname)
     * }
     */
    public static MemorySegment audit_session_port$address() {
        return audit_session_port.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int audit_session_port(au_asid_t asid, mach_port_name_t *portname)
     * }
     */
    public static int audit_session_port(int asid, MemorySegment portname) {
        var mh$ = audit_session_port.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("audit_session_port", asid, portname);
            }
            return (int) mh$.invokeExact(asid, portname);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ucred *kauth_cred_t
     * }
     */
    public static final AddressLayout kauth_cred_t = libproc_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct posix_cred *posix_cred_t
     * }
     */
    public static final AddressLayout posix_cred_t = libproc_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_nl_item
     * }
     */
    public static final OfInt __darwin_nl_item = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wctrans_t
     * }
     */
    public static final OfInt __darwin_wctrans_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_wctype_t
     * }
     */
    public static final OfInt __darwin_wctype_t = libproc_h.C_INT;

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, libproc_h.C_POINTER);
        public static final MemorySegment SEGMENT =
                libproc_h.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {};
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    private static class getdate_err$constants {
        public static final OfInt LAYOUT = libproc_h.C_INT;
        public static final MemorySegment SEGMENT =
                libproc_h.findOrThrow("getdate_err").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static OfInt getdate_err$layout() {
        return getdate_err$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static MemorySegment getdate_err$segment() {
        return getdate_err$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static int getdate_err() {
        return getdate_err$constants.SEGMENT.get(getdate_err$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static void getdate_err(int varValue) {
        getdate_err$constants.SEGMENT.set(getdate_err$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = libproc_h.C_LONG;
        public static final MemorySegment SEGMENT =
                libproc_h.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = libproc_h.C_INT;
        public static final MemorySegment SEGMENT =
                libproc_h.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MemorySegment asctime(MemorySegment x0) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", x0);
            }
            return (MemorySegment) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_LONG);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long) mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MemorySegment ctime(MemorySegment x0) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", x0);
            }
            return (MemorySegment) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_DOUBLE, libproc_h.C_LONG, libproc_h.C_LONG);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static double difftime(long x0, long x1) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", x0, x1);
            }
            return (double) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static FunctionDescriptor getdate$descriptor() {
        return getdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MethodHandle getdate$handle() {
        return getdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MemorySegment getdate$address() {
        return getdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MemorySegment getdate(MemorySegment x0) {
        var mh$ = getdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdate", x0);
            }
            return (MemorySegment) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MemorySegment gmtime(MemorySegment x0) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", x0);
            }
            return (MemorySegment) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MemorySegment localtime(MemorySegment x0) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", x0);
            }
            return (MemorySegment) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_LONG, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static long mktime(MemorySegment x0) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_LONG, libproc_h.C_POINTER, libproc_h.C_LONG, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static long strftime(MemorySegment x0, long x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", x0, x1, x2, x3);
            }
            return (long) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strptime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("strptime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor strptime$descriptor() {
        return strptime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle strptime$handle() {
        return strptime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment strptime$address() {
        return strptime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment strptime(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = strptime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strptime", x0, x1, x2);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_LONG, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static long time(MemorySegment x0) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid();

        public static final MemorySegment ADDR = libproc_h.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix2time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_LONG, libproc_h.C_LONG);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("posix2time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static FunctionDescriptor posix2time$descriptor() {
        return posix2time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static MethodHandle posix2time$handle() {
        return posix2time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static MemorySegment posix2time$address() {
        return posix2time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static long posix2time(long x0) {
        var mh$ = posix2time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix2time", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tzsetwall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid();

        public static final MemorySegment ADDR = libproc_h.findOrThrow("tzsetwall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static FunctionDescriptor tzsetwall$descriptor() {
        return tzsetwall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static MethodHandle tzsetwall$handle() {
        return tzsetwall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static MemorySegment tzsetwall$address() {
        return tzsetwall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static void tzsetwall() {
        var mh$ = tzsetwall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzsetwall");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time2posix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_LONG, libproc_h.C_LONG);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("time2posix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static FunctionDescriptor time2posix$descriptor() {
        return time2posix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static MethodHandle time2posix$handle() {
        return time2posix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static MemorySegment time2posix$address() {
        return time2posix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static long time2posix(long x0) {
        var mh$ = time2posix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time2posix", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_LONG, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static long timelocal(MemorySegment x0) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_LONG, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static long timegm(MemorySegment x0) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static int nanosleep(MemorySegment __rqtp, MemorySegment __rmtp) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __rqtp, __rmtp);
            }
            return (int) mh$.invokeExact(__rqtp, __rmtp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static final int _CLOCK_REALTIME = (int) 0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_REALTIME = 0
     * }
     */
    public static int _CLOCK_REALTIME() {
        return _CLOCK_REALTIME;
    }

    private static final int _CLOCK_MONOTONIC = (int) 6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC = 6
     * }
     */
    public static int _CLOCK_MONOTONIC() {
        return _CLOCK_MONOTONIC;
    }

    private static final int _CLOCK_MONOTONIC_RAW = (int) 4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC_RAW = 4
     * }
     */
    public static int _CLOCK_MONOTONIC_RAW() {
        return _CLOCK_MONOTONIC_RAW;
    }

    private static final int _CLOCK_MONOTONIC_RAW_APPROX = (int) 5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC_RAW_APPROX = 5
     * }
     */
    public static int _CLOCK_MONOTONIC_RAW_APPROX() {
        return _CLOCK_MONOTONIC_RAW_APPROX;
    }

    private static final int _CLOCK_UPTIME_RAW = (int) 8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_UPTIME_RAW = 8
     * }
     */
    public static int _CLOCK_UPTIME_RAW() {
        return _CLOCK_UPTIME_RAW;
    }

    private static final int _CLOCK_UPTIME_RAW_APPROX = (int) 9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_UPTIME_RAW_APPROX = 9
     * }
     */
    public static int _CLOCK_UPTIME_RAW_APPROX() {
        return _CLOCK_UPTIME_RAW_APPROX;
    }

    private static final int _CLOCK_PROCESS_CPUTIME_ID = (int) 12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_PROCESS_CPUTIME_ID = 12
     * }
     */
    public static int _CLOCK_PROCESS_CPUTIME_ID() {
        return _CLOCK_PROCESS_CPUTIME_ID;
    }

    private static final int _CLOCK_THREAD_CPUTIME_ID = (int) 16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_THREAD_CPUTIME_ID = 16
     * }
     */
    public static int _CLOCK_THREAD_CPUTIME_ID() {
        return _CLOCK_THREAD_CPUTIME_ID;
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int) mh$.invokeExact(__clock_id, __res);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int) mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime_nsec_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_LONG_LONG, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("clock_gettime_nsec_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static FunctionDescriptor clock_gettime_nsec_np$descriptor() {
        return clock_gettime_nsec_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static MethodHandle clock_gettime_nsec_np$handle() {
        return clock_gettime_nsec_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static MemorySegment clock_gettime_nsec_np$address() {
        return clock_gettime_nsec_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static long clock_gettime_nsec_np(int __clock_id) {
        var mh$ = clock_gettime_nsec_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime_nsec_np", __clock_id);
            }
            return (long) mh$.invokeExact(__clock_id);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int) mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static int timespec_get(MemorySegment ts, int base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", ts, base);
            }
            return (int) mh$.invokeExact(ts, base);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class adjtime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("adjtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static FunctionDescriptor adjtime$descriptor() {
        return adjtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static MethodHandle adjtime$handle() {
        return adjtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static MemorySegment adjtime$address() {
        return adjtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static int adjtime(MemorySegment x0, MemorySegment x1) {
        var mh$ = adjtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("adjtime", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class futimes {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("futimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static FunctionDescriptor futimes$descriptor() {
        return futimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static MethodHandle futimes$handle() {
        return futimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static MemorySegment futimes$address() {
        return futimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static int futimes(int x0, MemorySegment x1) {
        var mh$ = futimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("futimes", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lutimes {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("lutimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static FunctionDescriptor lutimes$descriptor() {
        return lutimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static MethodHandle lutimes$handle() {
        return lutimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static MemorySegment lutimes$address() {
        return lutimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static int lutimes(MemorySegment x0, MemorySegment x1) {
        var mh$ = lutimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lutimes", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class settimeofday {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("settimeofday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static FunctionDescriptor settimeofday$descriptor() {
        return settimeofday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static MethodHandle settimeofday$handle() {
        return settimeofday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static MemorySegment settimeofday$address() {
        return settimeofday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static int settimeofday(MemorySegment x0, MemorySegment x1) {
        var mh$ = settimeofday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("settimeofday", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getitimer {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getitimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static FunctionDescriptor getitimer$descriptor() {
        return getitimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static MethodHandle getitimer$handle() {
        return getitimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static MemorySegment getitimer$address() {
        return getitimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static int getitimer(int x0, MemorySegment x1) {
        var mh$ = getitimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getitimer", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gettimeofday {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("gettimeofday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static FunctionDescriptor gettimeofday$descriptor() {
        return gettimeofday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static MethodHandle gettimeofday$handle() {
        return gettimeofday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static MemorySegment gettimeofday$address() {
        return gettimeofday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static int gettimeofday(MemorySegment x0, MemorySegment x1) {
        var mh$ = gettimeofday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gettimeofday", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_POINTER,
                libproc_h.C_POINTER,
                libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static int select(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", x0, x1, x2, x3, x4);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setitimer {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("setitimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static FunctionDescriptor setitimer$descriptor() {
        return setitimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static MethodHandle setitimer$handle() {
        return setitimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static MemorySegment setitimer$address() {
        return setitimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static int setitimer(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = setitimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setitimer", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class utimes {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("utimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static FunctionDescriptor utimes$descriptor() {
        return utimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static MethodHandle utimes$handle() {
        return utimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static MemorySegment utimes$address() {
        return utimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static int utimes(MemorySegment x0, MemorySegment x1) {
        var mh$ = utimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("utimes", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef u_int32_t text_encoding_t
     * }
     */
    public static final OfInt text_encoding_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fsobj_type_t
     * }
     */
    public static final OfInt fsobj_type_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fsobj_tag_t
     * }
     */
    public static final OfInt fsobj_tag_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fsfile_type_t
     * }
     */
    public static final OfInt fsfile_type_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fsvolid_t
     * }
     */
    public static final OfInt fsvolid_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t attrgroup_t
     * }
     */
    public static final OfInt attrgroup_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct mount *mount_t
     * }
     */
    public static final AddressLayout mount_t = libproc_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct vnode *vnode_t
     * }
     */
    public static final AddressLayout vnode_t = libproc_h.C_POINTER;

    private static final int GRAFTDMG_CRYPTEX_BOOT = (int) 1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GRAFTDMG_CRYPTEX_BOOT = 1
     * }
     */
    public static int GRAFTDMG_CRYPTEX_BOOT() {
        return GRAFTDMG_CRYPTEX_BOOT;
    }

    private static final int GRAFTDMG_CRYPTEX_PREBOOT = (int) 2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GRAFTDMG_CRYPTEX_PREBOOT = 2
     * }
     */
    public static int GRAFTDMG_CRYPTEX_PREBOOT() {
        return GRAFTDMG_CRYPTEX_PREBOOT;
    }

    private static final int GRAFTDMG_CRYPTEX_DOWNLEVEL = (int) 3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GRAFTDMG_CRYPTEX_DOWNLEVEL = 3
     * }
     */
    public static int GRAFTDMG_CRYPTEX_DOWNLEVEL() {
        return GRAFTDMG_CRYPTEX_DOWNLEVEL;
    }

    private static final int GRAFTDMG_CRYPTEX_PDI_NONCE = (int) 6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GRAFTDMG_CRYPTEX_PDI_NONCE = 6
     * }
     */
    public static int GRAFTDMG_CRYPTEX_PDI_NONCE() {
        return GRAFTDMG_CRYPTEX_PDI_NONCE;
    }

    private static final int GRAFTDMG_CRYPTEX_EFFECTIVE_AP = (int) 7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GRAFTDMG_CRYPTEX_EFFECTIVE_AP = 7
     * }
     */
    public static int GRAFTDMG_CRYPTEX_EFFECTIVE_AP() {
        return GRAFTDMG_CRYPTEX_EFFECTIVE_AP;
    }

    private static final int GRAFTDMG_CRYPTEX_MAX = (int) 7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GRAFTDMG_CRYPTEX_MAX = 7
     * }
     */
    public static int GRAFTDMG_CRYPTEX_MAX() {
        return GRAFTDMG_CRYPTEX_MAX;
    }

    private static final int CRYPTEX1_AUTH_ENV_GENERIC = (int) 4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CRYPTEX1_AUTH_ENV_GENERIC = 4
     * }
     */
    public static int CRYPTEX1_AUTH_ENV_GENERIC() {
        return CRYPTEX1_AUTH_ENV_GENERIC;
    }

    private static final int CRYPTEX1_AUTH_ENV_GENERIC_SUPPLEMENTAL = (int) 5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CRYPTEX1_AUTH_ENV_GENERIC_SUPPLEMENTAL = 5
     * }
     */
    public static int CRYPTEX1_AUTH_ENV_GENERIC_SUPPLEMENTAL() {
        return CRYPTEX1_AUTH_ENV_GENERIC_SUPPLEMENTAL;
    }

    private static final int CRYPTEX_AUTH_PDI_NONCE = (int) 6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CRYPTEX_AUTH_PDI_NONCE = 6
     * }
     */
    public static int CRYPTEX_AUTH_PDI_NONCE() {
        return CRYPTEX_AUTH_PDI_NONCE;
    }

    private static final int CRYPTEX_AUTH_MAX = (int) 7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CRYPTEX_AUTH_MAX = 7
     * }
     */
    public static int CRYPTEX_AUTH_MAX() {
        return CRYPTEX_AUTH_MAX;
    }

    private static class fhopen {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("fhopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fhopen(const struct fhandle *, int)
     * }
     */
    public static FunctionDescriptor fhopen$descriptor() {
        return fhopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fhopen(const struct fhandle *, int)
     * }
     */
    public static MethodHandle fhopen$handle() {
        return fhopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fhopen(const struct fhandle *, int)
     * }
     */
    public static MemorySegment fhopen$address() {
        return fhopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fhopen(const struct fhandle *, int)
     * }
     */
    public static int fhopen(MemorySegment x0, int x1) {
        var mh$ = fhopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fhopen", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstatfs {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("fstatfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fstatfs(int, struct statfs *)
     * }
     */
    public static FunctionDescriptor fstatfs$descriptor() {
        return fstatfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fstatfs(int, struct statfs *)
     * }
     */
    public static MethodHandle fstatfs$handle() {
        return fstatfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fstatfs(int, struct statfs *)
     * }
     */
    public static MemorySegment fstatfs$address() {
        return fstatfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fstatfs(int, struct statfs *)
     * }
     */
    public static int fstatfs(int x0, MemorySegment x1) {
        var mh$ = fstatfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstatfs", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getfh {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getfh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getfh(const char *, fhandle_t *)
     * }
     */
    public static FunctionDescriptor getfh$descriptor() {
        return getfh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getfh(const char *, fhandle_t *)
     * }
     */
    public static MethodHandle getfh$handle() {
        return getfh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getfh(const char *, fhandle_t *)
     * }
     */
    public static MemorySegment getfh$address() {
        return getfh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getfh(const char *, fhandle_t *)
     * }
     */
    public static int getfh(MemorySegment x0, MemorySegment x1) {
        var mh$ = getfh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getfh", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getfsstat {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getfsstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getfsstat(struct statfs *, int, int)
     * }
     */
    public static FunctionDescriptor getfsstat$descriptor() {
        return getfsstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getfsstat(struct statfs *, int, int)
     * }
     */
    public static MethodHandle getfsstat$handle() {
        return getfsstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getfsstat(struct statfs *, int, int)
     * }
     */
    public static MemorySegment getfsstat$address() {
        return getfsstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getfsstat(struct statfs *, int, int)
     * }
     */
    public static int getfsstat(MemorySegment x0, int x1, int x2) {
        var mh$ = getfsstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getfsstat", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getmntinfo {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getmntinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getmntinfo(struct statfs **, int)
     * }
     */
    public static FunctionDescriptor getmntinfo$descriptor() {
        return getmntinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getmntinfo(struct statfs **, int)
     * }
     */
    public static MethodHandle getmntinfo$handle() {
        return getmntinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getmntinfo(struct statfs **, int)
     * }
     */
    public static MemorySegment getmntinfo$address() {
        return getmntinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getmntinfo(struct statfs **, int)
     * }
     */
    public static int getmntinfo(MemorySegment x0, int x1) {
        var mh$ = getmntinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getmntinfo", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getmntinfo_r_np {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getmntinfo_r_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getmntinfo_r_np(struct statfs **, int)
     * }
     */
    public static FunctionDescriptor getmntinfo_r_np$descriptor() {
        return getmntinfo_r_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getmntinfo_r_np(struct statfs **, int)
     * }
     */
    public static MethodHandle getmntinfo_r_np$handle() {
        return getmntinfo_r_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getmntinfo_r_np(struct statfs **, int)
     * }
     */
    public static MemorySegment getmntinfo_r_np$address() {
        return getmntinfo_r_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getmntinfo_r_np(struct statfs **, int)
     * }
     */
    public static int getmntinfo_r_np(MemorySegment x0, int x1) {
        var mh$ = getmntinfo_r_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getmntinfo_r_np", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("mount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mount(const char *, const char *, int, void *)
     * }
     */
    public static FunctionDescriptor mount$descriptor() {
        return mount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mount(const char *, const char *, int, void *)
     * }
     */
    public static MethodHandle mount$handle() {
        return mount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mount(const char *, const char *, int, void *)
     * }
     */
    public static MemorySegment mount$address() {
        return mount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mount(const char *, const char *, int, void *)
     * }
     */
    public static int mount(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = mount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mount", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("fmount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fmount(const char *, int, int, void *)
     * }
     */
    public static FunctionDescriptor fmount$descriptor() {
        return fmount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fmount(const char *, int, int, void *)
     * }
     */
    public static MethodHandle fmount$handle() {
        return fmount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fmount(const char *, int, int, void *)
     * }
     */
    public static MemorySegment fmount$address() {
        return fmount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fmount(const char *, int, int, void *)
     * }
     */
    public static int fmount(MemorySegment x0, int x1, int x2, MemorySegment x3) {
        var mh$ = fmount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmount", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class statfs {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("statfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int statfs(const char *, struct statfs *)
     * }
     */
    public static FunctionDescriptor statfs$descriptor() {
        return statfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int statfs(const char *, struct statfs *)
     * }
     */
    public static MethodHandle statfs$handle() {
        return statfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int statfs(const char *, struct statfs *)
     * }
     */
    public static MemorySegment statfs$address() {
        return statfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int statfs(const char *, struct statfs *)
     * }
     */
    public static int statfs(MemorySegment x0, MemorySegment x1) {
        var mh$ = statfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("statfs", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unmount {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("unmount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unmount(const char *, int)
     * }
     */
    public static FunctionDescriptor unmount$descriptor() {
        return unmount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unmount(const char *, int)
     * }
     */
    public static MethodHandle unmount$handle() {
        return unmount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unmount(const char *, int)
     * }
     */
    public static MemorySegment unmount$address() {
        return unmount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unmount(const char *, int)
     * }
     */
    public static int unmount(MemorySegment x0, int x1) {
        var mh$ = unmount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unmount", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getvfsbyname {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getvfsbyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getvfsbyname(const char *, struct vfsconf *)
     * }
     */
    public static FunctionDescriptor getvfsbyname$descriptor() {
        return getvfsbyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getvfsbyname(const char *, struct vfsconf *)
     * }
     */
    public static MethodHandle getvfsbyname$handle() {
        return getvfsbyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getvfsbyname(const char *, struct vfsconf *)
     * }
     */
    public static MemorySegment getvfsbyname$address() {
        return getvfsbyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getvfsbyname(const char *, struct vfsconf *)
     * }
     */
    public static int getvfsbyname(MemorySegment x0, MemorySegment x1) {
        var mh$ = getvfsbyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getvfsbyname", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint64_t rlim_t
     * }
     */
    public static final OfLong rlim_t = libproc_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef void *rusage_info_t
     * }
     */
    public static final AddressLayout rusage_info_t = libproc_h.C_POINTER;

    private static class getpriority {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static FunctionDescriptor getpriority$descriptor() {
        return getpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MethodHandle getpriority$handle() {
        return getpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MemorySegment getpriority$address() {
        return getpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static int getpriority(int x0, int x1) {
        var mh$ = getpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpriority", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getiopolicy_np {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static FunctionDescriptor getiopolicy_np$descriptor() {
        return getiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MethodHandle getiopolicy_np$handle() {
        return getiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MemorySegment getiopolicy_np$address() {
        return getiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static int getiopolicy_np(int x0, int x1) {
        var mh$ = getiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getiopolicy_np", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrlimit {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static FunctionDescriptor getrlimit$descriptor() {
        return getrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MethodHandle getrlimit$handle() {
        return getrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MemorySegment getrlimit$address() {
        return getrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static int getrlimit(int x0, MemorySegment x1) {
        var mh$ = getrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrlimit", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrusage {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getrusage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static FunctionDescriptor getrusage$descriptor() {
        return getrusage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MethodHandle getrusage$handle() {
        return getrusage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MemorySegment getrusage$address() {
        return getrusage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static int getrusage(int x0, MemorySegment x1) {
        var mh$ = getrusage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrusage", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpriority {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("setpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static FunctionDescriptor setpriority$descriptor() {
        return setpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MethodHandle setpriority$handle() {
        return setpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MemorySegment setpriority$address() {
        return setpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static int setpriority(int x0, int x1, int x2) {
        var mh$ = setpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpriority", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setiopolicy_np {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("setiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static FunctionDescriptor setiopolicy_np$descriptor() {
        return setiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MethodHandle setiopolicy_np$handle() {
        return setiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MemorySegment setiopolicy_np$address() {
        return setiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static int setiopolicy_np(int x0, int x1, int x2) {
        var mh$ = setiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setiopolicy_np", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrlimit {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("setrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static FunctionDescriptor setrlimit$descriptor() {
        return setrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MethodHandle setrlimit$handle() {
        return setrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MemorySegment setrlimit$address() {
        return setrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static int setrlimit(int x0, MemorySegment x1) {
        var mh$ = setrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrlimit", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int kern_return_t
     * }
     */
    public static final OfInt kern_return_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_timeout_t
     * }
     */
    public static final OfInt mach_msg_timeout_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_bits_t
     * }
     */
    public static final OfInt mach_msg_bits_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_size_t
     * }
     */
    public static final OfInt mach_msg_size_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_msg_id_t
     * }
     */
    public static final OfInt mach_msg_id_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_priority_t
     * }
     */
    public static final OfInt mach_msg_priority_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_type_name_t
     * }
     */
    public static final OfInt mach_msg_type_name_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_copy_options_t
     * }
     */
    public static final OfInt mach_msg_copy_options_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_guard_flags_t
     * }
     */
    public static final OfInt mach_msg_guard_flags_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_descriptor_type_t
     * }
     */
    public static final OfInt mach_msg_descriptor_type_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_trailer_type_t
     * }
     */
    public static final OfInt mach_msg_trailer_type_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_trailer_size_t
     * }
     */
    public static final OfInt mach_msg_trailer_size_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef char *mach_msg_trailer_info_t
     * }
     */
    public static final AddressLayout mach_msg_trailer_info_t = libproc_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int mach_msg_filter_id
     * }
     */
    public static final OfInt mach_msg_filter_id = libproc_h.C_INT;

    private static class KERNEL_SECURITY_TOKEN$constants {
        public static final GroupLayout LAYOUT = security_token_t.layout();
        public static final MemorySegment SEGMENT =
                libproc_h.findOrThrow("KERNEL_SECURITY_TOKEN").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const security_token_t KERNEL_SECURITY_TOKEN
     * }
     */
    public static GroupLayout KERNEL_SECURITY_TOKEN$layout() {
        return KERNEL_SECURITY_TOKEN$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const security_token_t KERNEL_SECURITY_TOKEN
     * }
     */
    public static MemorySegment KERNEL_SECURITY_TOKEN() {
        return KERNEL_SECURITY_TOKEN$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const security_token_t KERNEL_SECURITY_TOKEN
     * }
     */
    public static void KERNEL_SECURITY_TOKEN(MemorySegment varValue) {
        MemorySegment.copy(
                varValue,
                0L,
                KERNEL_SECURITY_TOKEN$constants.SEGMENT,
                0L,
                KERNEL_SECURITY_TOKEN$constants.LAYOUT.byteSize());
    }

    private static class KERNEL_AUDIT_TOKEN$constants {
        public static final GroupLayout LAYOUT = audit_token_t.layout();
        public static final MemorySegment SEGMENT =
                libproc_h.findOrThrow("KERNEL_AUDIT_TOKEN").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const audit_token_t KERNEL_AUDIT_TOKEN
     * }
     */
    public static GroupLayout KERNEL_AUDIT_TOKEN$layout() {
        return KERNEL_AUDIT_TOKEN$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const audit_token_t KERNEL_AUDIT_TOKEN
     * }
     */
    public static MemorySegment KERNEL_AUDIT_TOKEN() {
        return KERNEL_AUDIT_TOKEN$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const audit_token_t KERNEL_AUDIT_TOKEN
     * }
     */
    public static void KERNEL_AUDIT_TOKEN(MemorySegment varValue) {
        MemorySegment.copy(
                varValue, 0L, KERNEL_AUDIT_TOKEN$constants.SEGMENT, 0L, KERNEL_AUDIT_TOKEN$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_msg_options_t
     * }
     */
    public static final OfInt mach_msg_options_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_type_size_t
     * }
     */
    public static final OfInt mach_msg_type_size_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_type_number_t
     * }
     */
    public static final OfInt mach_msg_type_number_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_msg_option_t
     * }
     */
    public static final OfInt mach_msg_option_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef kern_return_t mach_msg_return_t
     * }
     */
    public static final OfInt mach_msg_return_t = libproc_h.C_INT;

    private static class mach_msg_overwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("mach_msg_overwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static FunctionDescriptor mach_msg_overwrite$descriptor() {
        return mach_msg_overwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static MethodHandle mach_msg_overwrite$handle() {
        return mach_msg_overwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static MemorySegment mach_msg_overwrite$address() {
        return mach_msg_overwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static int mach_msg_overwrite(
            MemorySegment msg,
            int option,
            int send_size,
            int rcv_size,
            int rcv_name,
            int timeout,
            int notify,
            MemorySegment rcv_msg,
            int rcv_limit) {
        var mh$ = mach_msg_overwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall(
                        "mach_msg_overwrite",
                        msg,
                        option,
                        send_size,
                        rcv_size,
                        rcv_name,
                        timeout,
                        notify,
                        rcv_msg,
                        rcv_limit);
            }
            return (int)
                    mh$.invokeExact(msg, option, send_size, rcv_size, rcv_name, timeout, notify, rcv_msg, rcv_limit);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mach_msg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("mach_msg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static FunctionDescriptor mach_msg$descriptor() {
        return mach_msg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static MethodHandle mach_msg$handle() {
        return mach_msg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static MemorySegment mach_msg$address() {
        return mach_msg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static int mach_msg(
            MemorySegment msg, int option, int send_size, int rcv_size, int rcv_name, int timeout, int notify) {
        var mh$ = mach_msg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mach_msg", msg, option, send_size, rcv_size, rcv_name, timeout, notify);
            }
            return (int) mh$.invokeExact(msg, option, send_size, rcv_size, rcv_name, timeout, notify);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mach_voucher_deallocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("mach_voucher_deallocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static FunctionDescriptor mach_voucher_deallocate$descriptor() {
        return mach_voucher_deallocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static MethodHandle mach_voucher_deallocate$handle() {
        return mach_voucher_deallocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static MemorySegment mach_voucher_deallocate$address() {
        return mach_voucher_deallocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static int mach_voucher_deallocate(int voucher) {
        var mh$ = mach_voucher_deallocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mach_voucher_deallocate", voucher);
            }
            return (int) mh$.invokeExact(voucher);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint8_t sa_family_t
     * }
     */
    public static final OfByte sa_family_t = libproc_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __darwin_socklen_t socklen_t
     * }
     */
    public static final OfInt socklen_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t sae_associd_t
     * }
     */
    public static final OfInt sae_associd_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t sae_connid_t
     * }
     */
    public static final OfInt sae_connid_t = libproc_h.C_INT;

    private static class accept {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("accept");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int accept(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static FunctionDescriptor accept$descriptor() {
        return accept.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int accept(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MethodHandle accept$handle() {
        return accept.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int accept(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MemorySegment accept$address() {
        return accept.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int accept(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static int accept(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = accept.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("accept", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bind {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("bind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bind(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static FunctionDescriptor bind$descriptor() {
        return bind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bind(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static MethodHandle bind$handle() {
        return bind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int bind(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static MemorySegment bind$address() {
        return bind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int bind(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static int bind(int x0, MemorySegment x1, int x2) {
        var mh$ = bind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bind", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class connect {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("connect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int connect(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static FunctionDescriptor connect$descriptor() {
        return connect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int connect(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static MethodHandle connect$handle() {
        return connect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int connect(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static MemorySegment connect$address() {
        return connect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int connect(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static int connect(int x0, MemorySegment x1, int x2) {
        var mh$ = connect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("connect", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpeername {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getpeername");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpeername(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static FunctionDescriptor getpeername$descriptor() {
        return getpeername.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpeername(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MethodHandle getpeername$handle() {
        return getpeername.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpeername(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MemorySegment getpeername$address() {
        return getpeername.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpeername(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static int getpeername(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getpeername.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpeername", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockname {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getsockname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsockname(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static FunctionDescriptor getsockname$descriptor() {
        return getsockname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsockname(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MethodHandle getsockname$handle() {
        return getsockname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsockname(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MemorySegment getsockname$address() {
        return getsockname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsockname(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static int getsockname(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getsockname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockname", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsockopt(int, int, int, void *restrict, socklen_t *restrict)
     * }
     */
    public static FunctionDescriptor getsockopt$descriptor() {
        return getsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsockopt(int, int, int, void *restrict, socklen_t *restrict)
     * }
     */
    public static MethodHandle getsockopt$handle() {
        return getsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsockopt(int, int, int, void *restrict, socklen_t *restrict)
     * }
     */
    public static MemorySegment getsockopt$address() {
        return getsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsockopt(int, int, int, void *restrict, socklen_t *restrict)
     * }
     */
    public static int getsockopt(int x0, int x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = getsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockopt", x0, x1, x2, x3, x4);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class listen {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("listen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int listen(int, int)
     * }
     */
    public static FunctionDescriptor listen$descriptor() {
        return listen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int listen(int, int)
     * }
     */
    public static MethodHandle listen$handle() {
        return listen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int listen(int, int)
     * }
     */
    public static MemorySegment listen$address() {
        return listen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int listen(int, int)
     * }
     */
    public static int listen(int x0, int x1) {
        var mh$ = listen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("listen", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_LONG, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_LONG, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("recv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t recv(int, void *, size_t, int)
     * }
     */
    public static FunctionDescriptor recv$descriptor() {
        return recv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t recv(int, void *, size_t, int)
     * }
     */
    public static MethodHandle recv$handle() {
        return recv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t recv(int, void *, size_t, int)
     * }
     */
    public static MemorySegment recv$address() {
        return recv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t recv(int, void *, size_t, int)
     * }
     */
    public static long recv(int x0, MemorySegment x1, long x2, int x3) {
        var mh$ = recv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recv", x0, x1, x2, x3);
            }
            return (long) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvfrom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_LONG,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_LONG,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("recvfrom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t recvfrom(int, void *, size_t, int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static FunctionDescriptor recvfrom$descriptor() {
        return recvfrom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t recvfrom(int, void *, size_t, int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MethodHandle recvfrom$handle() {
        return recvfrom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t recvfrom(int, void *, size_t, int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MemorySegment recvfrom$address() {
        return recvfrom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t recvfrom(int, void *, size_t, int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static long recvfrom(int x0, MemorySegment x1, long x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = recvfrom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvfrom", x0, x1, x2, x3, x4, x5);
            }
            return (long) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvmsg {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_LONG, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("recvmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t recvmsg(int, struct msghdr *, int)
     * }
     */
    public static FunctionDescriptor recvmsg$descriptor() {
        return recvmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t recvmsg(int, struct msghdr *, int)
     * }
     */
    public static MethodHandle recvmsg$handle() {
        return recvmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t recvmsg(int, struct msghdr *, int)
     * }
     */
    public static MemorySegment recvmsg$address() {
        return recvmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t recvmsg(int, struct msghdr *, int)
     * }
     */
    public static long recvmsg(int x0, MemorySegment x1, int x2) {
        var mh$ = recvmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvmsg", x0, x1, x2);
            }
            return (long) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class send {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_LONG, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_LONG, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("send");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t send(int, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor send$descriptor() {
        return send.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t send(int, const void *, size_t, int)
     * }
     */
    public static MethodHandle send$handle() {
        return send.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t send(int, const void *, size_t, int)
     * }
     */
    public static MemorySegment send$address() {
        return send.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t send(int, const void *, size_t, int)
     * }
     */
    public static long send(int x0, MemorySegment x1, long x2, int x3) {
        var mh$ = send.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("send", x0, x1, x2, x3);
            }
            return (long) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendmsg {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_LONG, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("sendmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t sendmsg(int, const struct msghdr *, int)
     * }
     */
    public static FunctionDescriptor sendmsg$descriptor() {
        return sendmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t sendmsg(int, const struct msghdr *, int)
     * }
     */
    public static MethodHandle sendmsg$handle() {
        return sendmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t sendmsg(int, const struct msghdr *, int)
     * }
     */
    public static MemorySegment sendmsg$address() {
        return sendmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t sendmsg(int, const struct msghdr *, int)
     * }
     */
    public static long sendmsg(int x0, MemorySegment x1, int x2) {
        var mh$ = sendmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendmsg", x0, x1, x2);
            }
            return (long) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_LONG,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_LONG,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("sendto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t sendto(int, const void *, size_t, int, const struct sockaddr *, socklen_t)
     * }
     */
    public static FunctionDescriptor sendto$descriptor() {
        return sendto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t sendto(int, const void *, size_t, int, const struct sockaddr *, socklen_t)
     * }
     */
    public static MethodHandle sendto$handle() {
        return sendto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t sendto(int, const void *, size_t, int, const struct sockaddr *, socklen_t)
     * }
     */
    public static MemorySegment sendto$address() {
        return sendto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t sendto(int, const void *, size_t, int, const struct sockaddr *, socklen_t)
     * }
     */
    public static long sendto(int x0, MemorySegment x1, long x2, int x3, MemorySegment x4, int x5) {
        var mh$ = sendto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendto", x0, x1, x2, x3, x4, x5);
            }
            return (long) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("setsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setsockopt(int, int, int, const void *, socklen_t)
     * }
     */
    public static FunctionDescriptor setsockopt$descriptor() {
        return setsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setsockopt(int, int, int, const void *, socklen_t)
     * }
     */
    public static MethodHandle setsockopt$handle() {
        return setsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setsockopt(int, int, int, const void *, socklen_t)
     * }
     */
    public static MemorySegment setsockopt$address() {
        return setsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setsockopt(int, int, int, const void *, socklen_t)
     * }
     */
    public static int setsockopt(int x0, int x1, int x2, MemorySegment x3, int x4) {
        var mh$ = setsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsockopt", x0, x1, x2, x3, x4);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shutdown {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("shutdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int shutdown(int, int)
     * }
     */
    public static FunctionDescriptor shutdown$descriptor() {
        return shutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int shutdown(int, int)
     * }
     */
    public static MethodHandle shutdown$handle() {
        return shutdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int shutdown(int, int)
     * }
     */
    public static MemorySegment shutdown$address() {
        return shutdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int shutdown(int, int)
     * }
     */
    public static int shutdown(int x0, int x1) {
        var mh$ = shutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shutdown", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sockatmark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("sockatmark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sockatmark(int)
     * }
     */
    public static FunctionDescriptor sockatmark$descriptor() {
        return sockatmark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sockatmark(int)
     * }
     */
    public static MethodHandle sockatmark$handle() {
        return sockatmark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sockatmark(int)
     * }
     */
    public static MemorySegment sockatmark$address() {
        return sockatmark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sockatmark(int)
     * }
     */
    public static int sockatmark(int x0) {
        var mh$ = sockatmark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sockatmark", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class socket {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("socket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int socket(int, int, int)
     * }
     */
    public static FunctionDescriptor socket$descriptor() {
        return socket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int socket(int, int, int)
     * }
     */
    public static MethodHandle socket$handle() {
        return socket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int socket(int, int, int)
     * }
     */
    public static MemorySegment socket$address() {
        return socket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int socket(int, int, int)
     * }
     */
    public static int socket(int x0, int x1, int x2) {
        var mh$ = socket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socket", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class socketpair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("socketpair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int socketpair(int, int, int, int *)
     * }
     */
    public static FunctionDescriptor socketpair$descriptor() {
        return socketpair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int socketpair(int, int, int, int *)
     * }
     */
    public static MethodHandle socketpair$handle() {
        return socketpair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int socketpair(int, int, int, int *)
     * }
     */
    public static MemorySegment socketpair$address() {
        return socketpair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int socketpair(int, int, int, int *)
     * }
     */
    public static int socketpair(int x0, int x1, int x2, MemorySegment x3) {
        var mh$ = socketpair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socketpair", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_LONG_LONG,
                libproc_h.C_POINTER,
                libproc_h.C_POINTER,
                libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("sendfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sendfile(int, int, off_t, off_t *, struct sf_hdtr *, int)
     * }
     */
    public static FunctionDescriptor sendfile$descriptor() {
        return sendfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sendfile(int, int, off_t, off_t *, struct sf_hdtr *, int)
     * }
     */
    public static MethodHandle sendfile$handle() {
        return sendfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sendfile(int, int, off_t, off_t *, struct sf_hdtr *, int)
     * }
     */
    public static MemorySegment sendfile$address() {
        return sendfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sendfile(int, int, off_t, off_t *, struct sf_hdtr *, int)
     * }
     */
    public static int sendfile(int x0, int x1, long x2, MemorySegment x3, MemorySegment x4, int x5) {
        var mh$ = sendfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendfile", x0, x1, x2, x3, x4, x5);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pfctlinput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("pfctlinput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pfctlinput(int, struct sockaddr *)
     * }
     */
    public static FunctionDescriptor pfctlinput$descriptor() {
        return pfctlinput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pfctlinput(int, struct sockaddr *)
     * }
     */
    public static MethodHandle pfctlinput$handle() {
        return pfctlinput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pfctlinput(int, struct sockaddr *)
     * }
     */
    public static MemorySegment pfctlinput$address() {
        return pfctlinput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pfctlinput(int, struct sockaddr *)
     * }
     */
    public static void pfctlinput(int x0, MemorySegment x1) {
        var mh$ = pfctlinput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pfctlinput", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class connectx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("connectx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int connectx(int, const sa_endpoints_t *, sae_associd_t, unsigned int, const struct iovec *, unsigned int, size_t *, sae_connid_t *)
     * }
     */
    public static FunctionDescriptor connectx$descriptor() {
        return connectx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int connectx(int, const sa_endpoints_t *, sae_associd_t, unsigned int, const struct iovec *, unsigned int, size_t *, sae_connid_t *)
     * }
     */
    public static MethodHandle connectx$handle() {
        return connectx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int connectx(int, const sa_endpoints_t *, sae_associd_t, unsigned int, const struct iovec *, unsigned int, size_t *, sae_connid_t *)
     * }
     */
    public static MemorySegment connectx$address() {
        return connectx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int connectx(int, const sa_endpoints_t *, sae_associd_t, unsigned int, const struct iovec *, unsigned int, size_t *, sae_connid_t *)
     * }
     */
    public static int connectx(
            int x0, MemorySegment x1, int x2, int x3, MemorySegment x4, int x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = connectx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("connectx", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class disconnectx {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("disconnectx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int disconnectx(int, sae_associd_t, sae_connid_t)
     * }
     */
    public static FunctionDescriptor disconnectx$descriptor() {
        return disconnectx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int disconnectx(int, sae_associd_t, sae_connid_t)
     * }
     */
    public static MethodHandle disconnectx$handle() {
        return disconnectx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int disconnectx(int, sae_associd_t, sae_connid_t)
     * }
     */
    public static MemorySegment disconnectx$address() {
        return disconnectx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int disconnectx(int, sae_associd_t, sae_connid_t)
     * }
     */
    public static int disconnectx(int x0, int x1, int x2) {
        var mh$ = disconnectx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("disconnectx", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static final int eNoteReapDeprecated = (int) 268435456L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.eNoteReapDeprecated = 268435456
     * }
     */
    public static int eNoteReapDeprecated() {
        return eNoteReapDeprecated;
    }

    private static final int eNoteExitReparentedDeprecated = (int) 524288L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.eNoteExitReparentedDeprecated = 524288
     * }
     */
    public static int eNoteExitReparentedDeprecated() {
        return eNoteExitReparentedDeprecated;
    }

    private static class kqueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("kqueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int kqueue()
     * }
     */
    public static FunctionDescriptor kqueue$descriptor() {
        return kqueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int kqueue()
     * }
     */
    public static MethodHandle kqueue$handle() {
        return kqueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int kqueue()
     * }
     */
    public static MemorySegment kqueue$address() {
        return kqueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int kqueue()
     * }
     */
    public static int kqueue() {
        var mh$ = kqueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("kqueue");
            }
            return (int) mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class kevent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT,
                libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("kevent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)
     * }
     */
    public static FunctionDescriptor kevent$descriptor() {
        return kevent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)
     * }
     */
    public static MethodHandle kevent$handle() {
        return kevent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)
     * }
     */
    public static MemorySegment kevent$address() {
        return kevent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)
     * }
     */
    public static int kevent(
            int kq,
            MemorySegment changelist,
            int nchanges,
            MemorySegment eventlist,
            int nevents,
            MemorySegment timeout) {
        var mh$ = kevent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("kevent", kq, changelist, nchanges, eventlist, nevents, timeout);
            }
            return (int) mh$.invokeExact(kq, changelist, nchanges, eventlist, nevents, timeout);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class kevent64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("kevent64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int kevent64(int kq, const struct kevent64_s *changelist, int nchanges, struct kevent64_s *eventlist, int nevents, unsigned int flags, const struct timespec *timeout)
     * }
     */
    public static FunctionDescriptor kevent64$descriptor() {
        return kevent64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int kevent64(int kq, const struct kevent64_s *changelist, int nchanges, struct kevent64_s *eventlist, int nevents, unsigned int flags, const struct timespec *timeout)
     * }
     */
    public static MethodHandle kevent64$handle() {
        return kevent64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int kevent64(int kq, const struct kevent64_s *changelist, int nchanges, struct kevent64_s *eventlist, int nevents, unsigned int flags, const struct timespec *timeout)
     * }
     */
    public static MemorySegment kevent64$address() {
        return kevent64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int kevent64(int kq, const struct kevent64_s *changelist, int nchanges, struct kevent64_s *eventlist, int nevents, unsigned int flags, const struct timespec *timeout)
     * }
     */
    public static int kevent64(
            int kq,
            MemorySegment changelist,
            int nchanges,
            MemorySegment eventlist,
            int nevents,
            int flags,
            MemorySegment timeout) {
        var mh$ = kevent64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("kevent64", kq, changelist, nchanges, eventlist, nevents, flags, timeout);
            }
            return (int) mh$.invokeExact(kq, changelist, nchanges, eventlist, nevents, flags, timeout);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class if_nametoindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("if_nametoindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int if_nametoindex(const char *)
     * }
     */
    public static FunctionDescriptor if_nametoindex$descriptor() {
        return if_nametoindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int if_nametoindex(const char *)
     * }
     */
    public static MethodHandle if_nametoindex$handle() {
        return if_nametoindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int if_nametoindex(const char *)
     * }
     */
    public static MemorySegment if_nametoindex$address() {
        return if_nametoindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int if_nametoindex(const char *)
     * }
     */
    public static int if_nametoindex(MemorySegment x0) {
        var mh$ = if_nametoindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("if_nametoindex", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class if_indextoname {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_POINTER, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("if_indextoname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *if_indextoname(unsigned int, char *)
     * }
     */
    public static FunctionDescriptor if_indextoname$descriptor() {
        return if_indextoname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *if_indextoname(unsigned int, char *)
     * }
     */
    public static MethodHandle if_indextoname$handle() {
        return if_indextoname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *if_indextoname(unsigned int, char *)
     * }
     */
    public static MemorySegment if_indextoname$address() {
        return if_indextoname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *if_indextoname(unsigned int, char *)
     * }
     */
    public static MemorySegment if_indextoname(int x0, MemorySegment x1) {
        var mh$ = if_indextoname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("if_indextoname", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class if_nameindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("if_nameindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct if_nameindex *if_nameindex()
     * }
     */
    public static FunctionDescriptor if_nameindex$descriptor() {
        return if_nameindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct if_nameindex *if_nameindex()
     * }
     */
    public static MethodHandle if_nameindex$handle() {
        return if_nameindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct if_nameindex *if_nameindex()
     * }
     */
    public static MemorySegment if_nameindex$address() {
        return if_nameindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct if_nameindex *if_nameindex()
     * }
     */
    public static MemorySegment if_nameindex() {
        var mh$ = if_nameindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("if_nameindex");
            }
            return (MemorySegment) mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class if_freenameindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("if_freenameindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void if_freenameindex(struct if_nameindex *)
     * }
     */
    public static FunctionDescriptor if_freenameindex$descriptor() {
        return if_freenameindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void if_freenameindex(struct if_nameindex *)
     * }
     */
    public static MethodHandle if_freenameindex$handle() {
        return if_freenameindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void if_freenameindex(struct if_nameindex *)
     * }
     */
    public static MemorySegment if_freenameindex$address() {
        return if_freenameindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void if_freenameindex(struct if_nameindex *)
     * }
     */
    public static void if_freenameindex(MemorySegment x0) {
        var mh$ = if_freenameindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("if_freenameindex", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setipv4sourcefilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_INT,
                in_addr.layout(),
                in_addr.layout(),
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("setipv4sourcefilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t, uint32_t, struct in_addr *)
     * }
     */
    public static FunctionDescriptor setipv4sourcefilter$descriptor() {
        return setipv4sourcefilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t, uint32_t, struct in_addr *)
     * }
     */
    public static MethodHandle setipv4sourcefilter$handle() {
        return setipv4sourcefilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t, uint32_t, struct in_addr *)
     * }
     */
    public static MemorySegment setipv4sourcefilter$address() {
        return setipv4sourcefilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t, uint32_t, struct in_addr *)
     * }
     */
    public static int setipv4sourcefilter(
            int x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5) {
        var mh$ = setipv4sourcefilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setipv4sourcefilter", x0, x1, x2, x3, x4, x5);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getipv4sourcefilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_INT,
                in_addr.layout(),
                in_addr.layout(),
                libproc_h.C_POINTER,
                libproc_h.C_POINTER,
                libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getipv4sourcefilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t *, uint32_t *, struct in_addr *)
     * }
     */
    public static FunctionDescriptor getipv4sourcefilter$descriptor() {
        return getipv4sourcefilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t *, uint32_t *, struct in_addr *)
     * }
     */
    public static MethodHandle getipv4sourcefilter$handle() {
        return getipv4sourcefilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t *, uint32_t *, struct in_addr *)
     * }
     */
    public static MemorySegment getipv4sourcefilter$address() {
        return getipv4sourcefilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t *, uint32_t *, struct in_addr *)
     * }
     */
    public static int getipv4sourcefilter(
            int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = getipv4sourcefilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getipv4sourcefilter", x0, x1, x2, x3, x4, x5);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsourcefilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("setsourcefilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t, uint32_t, struct sockaddr_storage *)
     * }
     */
    public static FunctionDescriptor setsourcefilter$descriptor() {
        return setsourcefilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t, uint32_t, struct sockaddr_storage *)
     * }
     */
    public static MethodHandle setsourcefilter$handle() {
        return setsourcefilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t, uint32_t, struct sockaddr_storage *)
     * }
     */
    public static MemorySegment setsourcefilter$address() {
        return setsourcefilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t, uint32_t, struct sockaddr_storage *)
     * }
     */
    public static int setsourcefilter(int x0, int x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6) {
        var mh$ = setsourcefilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsourcefilter", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsourcefilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_POINTER,
                libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("getsourcefilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t *, uint32_t *, struct sockaddr_storage *)
     * }
     */
    public static FunctionDescriptor getsourcefilter$descriptor() {
        return getsourcefilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t *, uint32_t *, struct sockaddr_storage *)
     * }
     */
    public static MethodHandle getsourcefilter$handle() {
        return getsourcefilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t *, uint32_t *, struct sockaddr_storage *)
     * }
     */
    public static MemorySegment getsourcefilter$address() {
        return getsourcefilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t *, uint32_t *, struct sockaddr_storage *)
     * }
     */
    public static int getsourcefilter(
            int x0, int x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = getsourcefilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsourcefilter", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class in6addr_any$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT =
                libproc_h.findOrThrow("in6addr_any").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_any
     * }
     */
    public static GroupLayout in6addr_any$layout() {
        return in6addr_any$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_any
     * }
     */
    public static MemorySegment in6addr_any() {
        return in6addr_any$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_any
     * }
     */
    public static void in6addr_any(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, in6addr_any$constants.SEGMENT, 0L, in6addr_any$constants.LAYOUT.byteSize());
    }

    private static class in6addr_loopback$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT =
                libproc_h.findOrThrow("in6addr_loopback").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_loopback
     * }
     */
    public static GroupLayout in6addr_loopback$layout() {
        return in6addr_loopback$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_loopback
     * }
     */
    public static MemorySegment in6addr_loopback() {
        return in6addr_loopback$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_loopback
     * }
     */
    public static void in6addr_loopback(MemorySegment varValue) {
        MemorySegment.copy(
                varValue, 0L, in6addr_loopback$constants.SEGMENT, 0L, in6addr_loopback$constants.LAYOUT.byteSize());
    }

    private static class in6addr_nodelocal_allnodes$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT =
                libproc_h.findOrThrow("in6addr_nodelocal_allnodes").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_nodelocal_allnodes
     * }
     */
    public static GroupLayout in6addr_nodelocal_allnodes$layout() {
        return in6addr_nodelocal_allnodes$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_nodelocal_allnodes
     * }
     */
    public static MemorySegment in6addr_nodelocal_allnodes() {
        return in6addr_nodelocal_allnodes$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_nodelocal_allnodes
     * }
     */
    public static void in6addr_nodelocal_allnodes(MemorySegment varValue) {
        MemorySegment.copy(
                varValue,
                0L,
                in6addr_nodelocal_allnodes$constants.SEGMENT,
                0L,
                in6addr_nodelocal_allnodes$constants.LAYOUT.byteSize());
    }

    private static class in6addr_linklocal_allnodes$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT =
                libproc_h.findOrThrow("in6addr_linklocal_allnodes").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allnodes
     * }
     */
    public static GroupLayout in6addr_linklocal_allnodes$layout() {
        return in6addr_linklocal_allnodes$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allnodes
     * }
     */
    public static MemorySegment in6addr_linklocal_allnodes() {
        return in6addr_linklocal_allnodes$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allnodes
     * }
     */
    public static void in6addr_linklocal_allnodes(MemorySegment varValue) {
        MemorySegment.copy(
                varValue,
                0L,
                in6addr_linklocal_allnodes$constants.SEGMENT,
                0L,
                in6addr_linklocal_allnodes$constants.LAYOUT.byteSize());
    }

    private static class in6addr_linklocal_allrouters$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT =
                libproc_h.findOrThrow("in6addr_linklocal_allrouters").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allrouters
     * }
     */
    public static GroupLayout in6addr_linklocal_allrouters$layout() {
        return in6addr_linklocal_allrouters$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allrouters
     * }
     */
    public static MemorySegment in6addr_linklocal_allrouters() {
        return in6addr_linklocal_allrouters$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allrouters
     * }
     */
    public static void in6addr_linklocal_allrouters(MemorySegment varValue) {
        MemorySegment.copy(
                varValue,
                0L,
                in6addr_linklocal_allrouters$constants.SEGMENT,
                0L,
                in6addr_linklocal_allrouters$constants.LAYOUT.byteSize());
    }

    private static class in6addr_linklocal_allv2routers$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT =
                libproc_h.findOrThrow("in6addr_linklocal_allv2routers").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allv2routers
     * }
     */
    public static GroupLayout in6addr_linklocal_allv2routers$layout() {
        return in6addr_linklocal_allv2routers$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allv2routers
     * }
     */
    public static MemorySegment in6addr_linklocal_allv2routers() {
        return in6addr_linklocal_allv2routers$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allv2routers
     * }
     */
    public static void in6addr_linklocal_allv2routers(MemorySegment varValue) {
        MemorySegment.copy(
                varValue,
                0L,
                in6addr_linklocal_allv2routers$constants.SEGMENT,
                0L,
                in6addr_linklocal_allv2routers$constants.LAYOUT.byteSize());
    }

    private static class inet6_option_space {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_option_space");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_option_space(int)
     * }
     */
    public static FunctionDescriptor inet6_option_space$descriptor() {
        return inet6_option_space.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_option_space(int)
     * }
     */
    public static MethodHandle inet6_option_space$handle() {
        return inet6_option_space.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_option_space(int)
     * }
     */
    public static MemorySegment inet6_option_space$address() {
        return inet6_option_space.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_option_space(int)
     * }
     */
    public static int inet6_option_space(int x0) {
        var mh$ = inet6_option_space.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_option_space", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_option_init {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_option_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_option_init(void *, struct cmsghdr **, int)
     * }
     */
    public static FunctionDescriptor inet6_option_init$descriptor() {
        return inet6_option_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_option_init(void *, struct cmsghdr **, int)
     * }
     */
    public static MethodHandle inet6_option_init$handle() {
        return inet6_option_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_option_init(void *, struct cmsghdr **, int)
     * }
     */
    public static MemorySegment inet6_option_init$address() {
        return inet6_option_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_option_init(void *, struct cmsghdr **, int)
     * }
     */
    public static int inet6_option_init(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = inet6_option_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_option_init", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_option_append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_option_append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_option_append(struct cmsghdr *, const __uint8_t *, int, int)
     * }
     */
    public static FunctionDescriptor inet6_option_append$descriptor() {
        return inet6_option_append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_option_append(struct cmsghdr *, const __uint8_t *, int, int)
     * }
     */
    public static MethodHandle inet6_option_append$handle() {
        return inet6_option_append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_option_append(struct cmsghdr *, const __uint8_t *, int, int)
     * }
     */
    public static MemorySegment inet6_option_append$address() {
        return inet6_option_append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_option_append(struct cmsghdr *, const __uint8_t *, int, int)
     * }
     */
    public static int inet6_option_append(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = inet6_option_append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_option_append", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_option_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_option_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint8_t *inet6_option_alloc(struct cmsghdr *, int, int, int)
     * }
     */
    public static FunctionDescriptor inet6_option_alloc$descriptor() {
        return inet6_option_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint8_t *inet6_option_alloc(struct cmsghdr *, int, int, int)
     * }
     */
    public static MethodHandle inet6_option_alloc$handle() {
        return inet6_option_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uint8_t *inet6_option_alloc(struct cmsghdr *, int, int, int)
     * }
     */
    public static MemorySegment inet6_option_alloc$address() {
        return inet6_option_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uint8_t *inet6_option_alloc(struct cmsghdr *, int, int, int)
     * }
     */
    public static MemorySegment inet6_option_alloc(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = inet6_option_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_option_alloc", x0, x1, x2, x3);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_option_next {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_option_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_option_next(const struct cmsghdr *, __uint8_t **)
     * }
     */
    public static FunctionDescriptor inet6_option_next$descriptor() {
        return inet6_option_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_option_next(const struct cmsghdr *, __uint8_t **)
     * }
     */
    public static MethodHandle inet6_option_next$handle() {
        return inet6_option_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_option_next(const struct cmsghdr *, __uint8_t **)
     * }
     */
    public static MemorySegment inet6_option_next$address() {
        return inet6_option_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_option_next(const struct cmsghdr *, __uint8_t **)
     * }
     */
    public static int inet6_option_next(MemorySegment x0, MemorySegment x1) {
        var mh$ = inet6_option_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_option_next", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_option_find {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_option_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_option_find(const struct cmsghdr *, __uint8_t **, int)
     * }
     */
    public static FunctionDescriptor inet6_option_find$descriptor() {
        return inet6_option_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_option_find(const struct cmsghdr *, __uint8_t **, int)
     * }
     */
    public static MethodHandle inet6_option_find$handle() {
        return inet6_option_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_option_find(const struct cmsghdr *, __uint8_t **, int)
     * }
     */
    public static MemorySegment inet6_option_find$address() {
        return inet6_option_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_option_find(const struct cmsghdr *, __uint8_t **, int)
     * }
     */
    public static int inet6_option_find(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = inet6_option_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_option_find", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rthdr_space {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_LONG, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_rthdr_space");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t inet6_rthdr_space(int, int)
     * }
     */
    public static FunctionDescriptor inet6_rthdr_space$descriptor() {
        return inet6_rthdr_space.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t inet6_rthdr_space(int, int)
     * }
     */
    public static MethodHandle inet6_rthdr_space$handle() {
        return inet6_rthdr_space.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t inet6_rthdr_space(int, int)
     * }
     */
    public static MemorySegment inet6_rthdr_space$address() {
        return inet6_rthdr_space.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t inet6_rthdr_space(int, int)
     * }
     */
    public static long inet6_rthdr_space(int x0, int x1) {
        var mh$ = inet6_rthdr_space.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rthdr_space", x0, x1);
            }
            return (long) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rthdr_init {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_rthdr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct cmsghdr *inet6_rthdr_init(void *, int)
     * }
     */
    public static FunctionDescriptor inet6_rthdr_init$descriptor() {
        return inet6_rthdr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct cmsghdr *inet6_rthdr_init(void *, int)
     * }
     */
    public static MethodHandle inet6_rthdr_init$handle() {
        return inet6_rthdr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct cmsghdr *inet6_rthdr_init(void *, int)
     * }
     */
    public static MemorySegment inet6_rthdr_init$address() {
        return inet6_rthdr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct cmsghdr *inet6_rthdr_init(void *, int)
     * }
     */
    public static MemorySegment inet6_rthdr_init(MemorySegment x0, int x1) {
        var mh$ = inet6_rthdr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rthdr_init", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rthdr_add {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_rthdr_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_add(struct cmsghdr *, const struct in6_addr *, unsigned int)
     * }
     */
    public static FunctionDescriptor inet6_rthdr_add$descriptor() {
        return inet6_rthdr_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_add(struct cmsghdr *, const struct in6_addr *, unsigned int)
     * }
     */
    public static MethodHandle inet6_rthdr_add$handle() {
        return inet6_rthdr_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_add(struct cmsghdr *, const struct in6_addr *, unsigned int)
     * }
     */
    public static MemorySegment inet6_rthdr_add$address() {
        return inet6_rthdr_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_rthdr_add(struct cmsghdr *, const struct in6_addr *, unsigned int)
     * }
     */
    public static int inet6_rthdr_add(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = inet6_rthdr_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rthdr_add", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rthdr_lasthop {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_rthdr_lasthop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_lasthop(struct cmsghdr *, unsigned int)
     * }
     */
    public static FunctionDescriptor inet6_rthdr_lasthop$descriptor() {
        return inet6_rthdr_lasthop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_lasthop(struct cmsghdr *, unsigned int)
     * }
     */
    public static MethodHandle inet6_rthdr_lasthop$handle() {
        return inet6_rthdr_lasthop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_lasthop(struct cmsghdr *, unsigned int)
     * }
     */
    public static MemorySegment inet6_rthdr_lasthop$address() {
        return inet6_rthdr_lasthop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_rthdr_lasthop(struct cmsghdr *, unsigned int)
     * }
     */
    public static int inet6_rthdr_lasthop(MemorySegment x0, int x1) {
        var mh$ = inet6_rthdr_lasthop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rthdr_lasthop", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rthdr_segments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_rthdr_segments");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_segments(const struct cmsghdr *)
     * }
     */
    public static FunctionDescriptor inet6_rthdr_segments$descriptor() {
        return inet6_rthdr_segments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_segments(const struct cmsghdr *)
     * }
     */
    public static MethodHandle inet6_rthdr_segments$handle() {
        return inet6_rthdr_segments.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_segments(const struct cmsghdr *)
     * }
     */
    public static MemorySegment inet6_rthdr_segments$address() {
        return inet6_rthdr_segments.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_rthdr_segments(const struct cmsghdr *)
     * }
     */
    public static int inet6_rthdr_segments(MemorySegment x0) {
        var mh$ = inet6_rthdr_segments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rthdr_segments", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rthdr_getaddr {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_rthdr_getaddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr *, int)
     * }
     */
    public static FunctionDescriptor inet6_rthdr_getaddr$descriptor() {
        return inet6_rthdr_getaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr *, int)
     * }
     */
    public static MethodHandle inet6_rthdr_getaddr$handle() {
        return inet6_rthdr_getaddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr *, int)
     * }
     */
    public static MemorySegment inet6_rthdr_getaddr$address() {
        return inet6_rthdr_getaddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr *, int)
     * }
     */
    public static MemorySegment inet6_rthdr_getaddr(MemorySegment x0, int x1) {
        var mh$ = inet6_rthdr_getaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rthdr_getaddr", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rthdr_getflags {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_rthdr_getflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_getflags(const struct cmsghdr *, int)
     * }
     */
    public static FunctionDescriptor inet6_rthdr_getflags$descriptor() {
        return inet6_rthdr_getflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_getflags(const struct cmsghdr *, int)
     * }
     */
    public static MethodHandle inet6_rthdr_getflags$handle() {
        return inet6_rthdr_getflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_getflags(const struct cmsghdr *, int)
     * }
     */
    public static MemorySegment inet6_rthdr_getflags$address() {
        return inet6_rthdr_getflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_rthdr_getflags(const struct cmsghdr *, int)
     * }
     */
    public static int inet6_rthdr_getflags(MemorySegment x0, int x1) {
        var mh$ = inet6_rthdr_getflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rthdr_getflags", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_opt_init {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_opt_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_opt_init(void *, socklen_t)
     * }
     */
    public static FunctionDescriptor inet6_opt_init$descriptor() {
        return inet6_opt_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_opt_init(void *, socklen_t)
     * }
     */
    public static MethodHandle inet6_opt_init$handle() {
        return inet6_opt_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_opt_init(void *, socklen_t)
     * }
     */
    public static MemorySegment inet6_opt_init$address() {
        return inet6_opt_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_opt_init(void *, socklen_t)
     * }
     */
    public static int inet6_opt_init(MemorySegment x0, int x1) {
        var mh$ = inet6_opt_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_opt_init", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_opt_append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_CHAR,
                libproc_h.C_INT,
                libproc_h.C_CHAR,
                libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_opt_append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_opt_append(void *, socklen_t, int, __uint8_t, socklen_t, __uint8_t, void **)
     * }
     */
    public static FunctionDescriptor inet6_opt_append$descriptor() {
        return inet6_opt_append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_opt_append(void *, socklen_t, int, __uint8_t, socklen_t, __uint8_t, void **)
     * }
     */
    public static MethodHandle inet6_opt_append$handle() {
        return inet6_opt_append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_opt_append(void *, socklen_t, int, __uint8_t, socklen_t, __uint8_t, void **)
     * }
     */
    public static MemorySegment inet6_opt_append$address() {
        return inet6_opt_append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_opt_append(void *, socklen_t, int, __uint8_t, socklen_t, __uint8_t, void **)
     * }
     */
    public static int inet6_opt_append(MemorySegment x0, int x1, int x2, byte x3, int x4, byte x5, MemorySegment x6) {
        var mh$ = inet6_opt_append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_opt_append", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_opt_finish {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_opt_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_opt_finish(void *, socklen_t, int)
     * }
     */
    public static FunctionDescriptor inet6_opt_finish$descriptor() {
        return inet6_opt_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_opt_finish(void *, socklen_t, int)
     * }
     */
    public static MethodHandle inet6_opt_finish$handle() {
        return inet6_opt_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_opt_finish(void *, socklen_t, int)
     * }
     */
    public static MemorySegment inet6_opt_finish$address() {
        return inet6_opt_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_opt_finish(void *, socklen_t, int)
     * }
     */
    public static int inet6_opt_finish(MemorySegment x0, int x1, int x2) {
        var mh$ = inet6_opt_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_opt_finish", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_opt_set_val {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_opt_set_val");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_opt_set_val(void *, int, void *, socklen_t)
     * }
     */
    public static FunctionDescriptor inet6_opt_set_val$descriptor() {
        return inet6_opt_set_val.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_opt_set_val(void *, int, void *, socklen_t)
     * }
     */
    public static MethodHandle inet6_opt_set_val$handle() {
        return inet6_opt_set_val.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_opt_set_val(void *, int, void *, socklen_t)
     * }
     */
    public static MemorySegment inet6_opt_set_val$address() {
        return inet6_opt_set_val.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_opt_set_val(void *, int, void *, socklen_t)
     * }
     */
    public static int inet6_opt_set_val(MemorySegment x0, int x1, MemorySegment x2, int x3) {
        var mh$ = inet6_opt_set_val.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_opt_set_val", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_opt_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_POINTER,
                libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_opt_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_opt_next(void *, socklen_t, int, __uint8_t *, socklen_t *, void **)
     * }
     */
    public static FunctionDescriptor inet6_opt_next$descriptor() {
        return inet6_opt_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_opt_next(void *, socklen_t, int, __uint8_t *, socklen_t *, void **)
     * }
     */
    public static MethodHandle inet6_opt_next$handle() {
        return inet6_opt_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_opt_next(void *, socklen_t, int, __uint8_t *, socklen_t *, void **)
     * }
     */
    public static MemorySegment inet6_opt_next$address() {
        return inet6_opt_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_opt_next(void *, socklen_t, int, __uint8_t *, socklen_t *, void **)
     * }
     */
    public static int inet6_opt_next(
            MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = inet6_opt_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_opt_next", x0, x1, x2, x3, x4, x5);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_opt_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_CHAR,
                libproc_h.C_POINTER,
                libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_opt_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_opt_find(void *, socklen_t, int, __uint8_t, socklen_t *, void **)
     * }
     */
    public static FunctionDescriptor inet6_opt_find$descriptor() {
        return inet6_opt_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_opt_find(void *, socklen_t, int, __uint8_t, socklen_t *, void **)
     * }
     */
    public static MethodHandle inet6_opt_find$handle() {
        return inet6_opt_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_opt_find(void *, socklen_t, int, __uint8_t, socklen_t *, void **)
     * }
     */
    public static MemorySegment inet6_opt_find$address() {
        return inet6_opt_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_opt_find(void *, socklen_t, int, __uint8_t, socklen_t *, void **)
     * }
     */
    public static int inet6_opt_find(MemorySegment x0, int x1, int x2, byte x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = inet6_opt_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_opt_find", x0, x1, x2, x3, x4, x5);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_opt_get_val {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_opt_get_val");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_opt_get_val(void *, int, void *, socklen_t)
     * }
     */
    public static FunctionDescriptor inet6_opt_get_val$descriptor() {
        return inet6_opt_get_val.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_opt_get_val(void *, int, void *, socklen_t)
     * }
     */
    public static MethodHandle inet6_opt_get_val$handle() {
        return inet6_opt_get_val.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_opt_get_val(void *, int, void *, socklen_t)
     * }
     */
    public static MemorySegment inet6_opt_get_val$address() {
        return inet6_opt_get_val.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_opt_get_val(void *, int, void *, socklen_t)
     * }
     */
    public static int inet6_opt_get_val(MemorySegment x0, int x1, MemorySegment x2, int x3) {
        var mh$ = inet6_opt_get_val.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_opt_get_val", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rth_space {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_rth_space");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern socklen_t inet6_rth_space(int, int)
     * }
     */
    public static FunctionDescriptor inet6_rth_space$descriptor() {
        return inet6_rth_space.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern socklen_t inet6_rth_space(int, int)
     * }
     */
    public static MethodHandle inet6_rth_space$handle() {
        return inet6_rth_space.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern socklen_t inet6_rth_space(int, int)
     * }
     */
    public static MemorySegment inet6_rth_space$address() {
        return inet6_rth_space.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern socklen_t inet6_rth_space(int, int)
     * }
     */
    public static int inet6_rth_space(int x0, int x1) {
        var mh$ = inet6_rth_space.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rth_space", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rth_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_rth_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *inet6_rth_init(void *, socklen_t, int, int)
     * }
     */
    public static FunctionDescriptor inet6_rth_init$descriptor() {
        return inet6_rth_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *inet6_rth_init(void *, socklen_t, int, int)
     * }
     */
    public static MethodHandle inet6_rth_init$handle() {
        return inet6_rth_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *inet6_rth_init(void *, socklen_t, int, int)
     * }
     */
    public static MemorySegment inet6_rth_init$address() {
        return inet6_rth_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *inet6_rth_init(void *, socklen_t, int, int)
     * }
     */
    public static MemorySegment inet6_rth_init(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = inet6_rth_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rth_init", x0, x1, x2, x3);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rth_add {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_rth_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_rth_add(void *, const struct in6_addr *)
     * }
     */
    public static FunctionDescriptor inet6_rth_add$descriptor() {
        return inet6_rth_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_rth_add(void *, const struct in6_addr *)
     * }
     */
    public static MethodHandle inet6_rth_add$handle() {
        return inet6_rth_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_rth_add(void *, const struct in6_addr *)
     * }
     */
    public static MemorySegment inet6_rth_add$address() {
        return inet6_rth_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_rth_add(void *, const struct in6_addr *)
     * }
     */
    public static int inet6_rth_add(MemorySegment x0, MemorySegment x1) {
        var mh$ = inet6_rth_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rth_add", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rth_reverse {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_rth_reverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_rth_reverse(const void *, void *)
     * }
     */
    public static FunctionDescriptor inet6_rth_reverse$descriptor() {
        return inet6_rth_reverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_rth_reverse(const void *, void *)
     * }
     */
    public static MethodHandle inet6_rth_reverse$handle() {
        return inet6_rth_reverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_rth_reverse(const void *, void *)
     * }
     */
    public static MemorySegment inet6_rth_reverse$address() {
        return inet6_rth_reverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_rth_reverse(const void *, void *)
     * }
     */
    public static int inet6_rth_reverse(MemorySegment x0, MemorySegment x1) {
        var mh$ = inet6_rth_reverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rth_reverse", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rth_segments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_rth_segments");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_rth_segments(const void *)
     * }
     */
    public static FunctionDescriptor inet6_rth_segments$descriptor() {
        return inet6_rth_segments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_rth_segments(const void *)
     * }
     */
    public static MethodHandle inet6_rth_segments$handle() {
        return inet6_rth_segments.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_rth_segments(const void *)
     * }
     */
    public static MemorySegment inet6_rth_segments$address() {
        return inet6_rth_segments.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_rth_segments(const void *)
     * }
     */
    public static int inet6_rth_segments(MemorySegment x0) {
        var mh$ = inet6_rth_segments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rth_segments", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rth_getaddr {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("inet6_rth_getaddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rth_getaddr(const void *, int)
     * }
     */
    public static FunctionDescriptor inet6_rth_getaddr$descriptor() {
        return inet6_rth_getaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rth_getaddr(const void *, int)
     * }
     */
    public static MethodHandle inet6_rth_getaddr$handle() {
        return inet6_rth_getaddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rth_getaddr(const void *, int)
     * }
     */
    public static MemorySegment inet6_rth_getaddr$address() {
        return inet6_rth_getaddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rth_getaddr(const void *, int)
     * }
     */
    public static MemorySegment inet6_rth_getaddr(MemorySegment x0, int x1) {
        var mh$ = inet6_rth_getaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rth_getaddr", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bindresvport {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("bindresvport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bindresvport(int, struct sockaddr_in *)
     * }
     */
    public static FunctionDescriptor bindresvport$descriptor() {
        return bindresvport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bindresvport(int, struct sockaddr_in *)
     * }
     */
    public static MethodHandle bindresvport$handle() {
        return bindresvport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int bindresvport(int, struct sockaddr_in *)
     * }
     */
    public static MemorySegment bindresvport$address() {
        return bindresvport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int bindresvport(int, struct sockaddr_in *)
     * }
     */
    public static int bindresvport(int x0, MemorySegment x1) {
        var mh$ = bindresvport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bindresvport", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bindresvport_sa {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("bindresvport_sa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bindresvport_sa(int, struct sockaddr *)
     * }
     */
    public static FunctionDescriptor bindresvport_sa$descriptor() {
        return bindresvport_sa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bindresvport_sa(int, struct sockaddr *)
     * }
     */
    public static MethodHandle bindresvport_sa$handle() {
        return bindresvport_sa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int bindresvport_sa(int, struct sockaddr *)
     * }
     */
    public static MemorySegment bindresvport_sa$address() {
        return bindresvport_sa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int bindresvport_sa(int, struct sockaddr *)
     * }
     */
    public static int bindresvport_sa(int x0, MemorySegment x1) {
        var mh$ = bindresvport_sa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bindresvport_sa", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint32_t tcp_seq
     * }
     */
    public static final OfInt tcp_seq = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t tcp_cc
     * }
     */
    public static final OfInt tcp_cc = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t cpu_type_t
     * }
     */
    public static final OfInt cpu_type_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t cpu_subtype_t
     * }
     */
    public static final OfInt cpu_subtype_t = libproc_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t cpu_threadtype_t
     * }
     */
    public static final OfInt cpu_threadtype_t = libproc_h.C_INT;

    private static class uuid_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("uuid_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_clear(uuid_t uu)
     * }
     */
    public static FunctionDescriptor uuid_clear$descriptor() {
        return uuid_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_clear(uuid_t uu)
     * }
     */
    public static MethodHandle uuid_clear$handle() {
        return uuid_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_clear(uuid_t uu)
     * }
     */
    public static MemorySegment uuid_clear$address() {
        return uuid_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_clear(uuid_t uu)
     * }
     */
    public static void uuid_clear(MemorySegment uu) {
        var mh$ = uuid_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_clear", uu);
            }
            mh$.invokeExact(uu);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_compare {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("uuid_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uuid_compare(const uuid_t uu1, const uuid_t uu2)
     * }
     */
    public static FunctionDescriptor uuid_compare$descriptor() {
        return uuid_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uuid_compare(const uuid_t uu1, const uuid_t uu2)
     * }
     */
    public static MethodHandle uuid_compare$handle() {
        return uuid_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uuid_compare(const uuid_t uu1, const uuid_t uu2)
     * }
     */
    public static MemorySegment uuid_compare$address() {
        return uuid_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uuid_compare(const uuid_t uu1, const uuid_t uu2)
     * }
     */
    public static int uuid_compare(MemorySegment uu1, MemorySegment uu2) {
        var mh$ = uuid_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_compare", uu1, uu2);
            }
            return (int) mh$.invokeExact(uu1, uu2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_copy {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.ofVoid(libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("uuid_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_copy(uuid_t dst, const uuid_t src)
     * }
     */
    public static FunctionDescriptor uuid_copy$descriptor() {
        return uuid_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_copy(uuid_t dst, const uuid_t src)
     * }
     */
    public static MethodHandle uuid_copy$handle() {
        return uuid_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_copy(uuid_t dst, const uuid_t src)
     * }
     */
    public static MemorySegment uuid_copy$address() {
        return uuid_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_copy(uuid_t dst, const uuid_t src)
     * }
     */
    public static void uuid_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = uuid_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_copy", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_generate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("uuid_generate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_generate(uuid_t out)
     * }
     */
    public static FunctionDescriptor uuid_generate$descriptor() {
        return uuid_generate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_generate(uuid_t out)
     * }
     */
    public static MethodHandle uuid_generate$handle() {
        return uuid_generate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_generate(uuid_t out)
     * }
     */
    public static MemorySegment uuid_generate$address() {
        return uuid_generate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_generate(uuid_t out)
     * }
     */
    public static void uuid_generate(MemorySegment out) {
        var mh$ = uuid_generate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_generate", out);
            }
            mh$.invokeExact(out);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_generate_random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("uuid_generate_random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_generate_random(uuid_t out)
     * }
     */
    public static FunctionDescriptor uuid_generate_random$descriptor() {
        return uuid_generate_random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_generate_random(uuid_t out)
     * }
     */
    public static MethodHandle uuid_generate_random$handle() {
        return uuid_generate_random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_generate_random(uuid_t out)
     * }
     */
    public static MemorySegment uuid_generate_random$address() {
        return uuid_generate_random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_generate_random(uuid_t out)
     * }
     */
    public static void uuid_generate_random(MemorySegment out) {
        var mh$ = uuid_generate_random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_generate_random", out);
            }
            mh$.invokeExact(out);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_generate_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("uuid_generate_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_generate_time(uuid_t out)
     * }
     */
    public static FunctionDescriptor uuid_generate_time$descriptor() {
        return uuid_generate_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_generate_time(uuid_t out)
     * }
     */
    public static MethodHandle uuid_generate_time$handle() {
        return uuid_generate_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_generate_time(uuid_t out)
     * }
     */
    public static MemorySegment uuid_generate_time$address() {
        return uuid_generate_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_generate_time(uuid_t out)
     * }
     */
    public static void uuid_generate_time(MemorySegment out) {
        var mh$ = uuid_generate_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_generate_time", out);
            }
            mh$.invokeExact(out);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_is_null {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("uuid_is_null");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uuid_is_null(const uuid_t uu)
     * }
     */
    public static FunctionDescriptor uuid_is_null$descriptor() {
        return uuid_is_null.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uuid_is_null(const uuid_t uu)
     * }
     */
    public static MethodHandle uuid_is_null$handle() {
        return uuid_is_null.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uuid_is_null(const uuid_t uu)
     * }
     */
    public static MemorySegment uuid_is_null$address() {
        return uuid_is_null.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uuid_is_null(const uuid_t uu)
     * }
     */
    public static int uuid_is_null(MemorySegment uu) {
        var mh$ = uuid_is_null.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_is_null", uu);
            }
            return (int) mh$.invokeExact(uu);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_parse {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("uuid_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uuid_parse(const uuid_string_t in, uuid_t uu)
     * }
     */
    public static FunctionDescriptor uuid_parse$descriptor() {
        return uuid_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uuid_parse(const uuid_string_t in, uuid_t uu)
     * }
     */
    public static MethodHandle uuid_parse$handle() {
        return uuid_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uuid_parse(const uuid_string_t in, uuid_t uu)
     * }
     */
    public static MemorySegment uuid_parse$address() {
        return uuid_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uuid_parse(const uuid_string_t in, uuid_t uu)
     * }
     */
    public static int uuid_parse(MemorySegment in, MemorySegment uu) {
        var mh$ = uuid_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_parse", in, uu);
            }
            return (int) mh$.invokeExact(in, uu);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_unparse {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.ofVoid(libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("uuid_unparse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_unparse(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static FunctionDescriptor uuid_unparse$descriptor() {
        return uuid_unparse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_unparse(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static MethodHandle uuid_unparse$handle() {
        return uuid_unparse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_unparse(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static MemorySegment uuid_unparse$address() {
        return uuid_unparse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_unparse(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static void uuid_unparse(MemorySegment uu, MemorySegment out) {
        var mh$ = uuid_unparse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_unparse", uu, out);
            }
            mh$.invokeExact(uu, out);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_unparse_lower {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.ofVoid(libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("uuid_unparse_lower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_unparse_lower(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static FunctionDescriptor uuid_unparse_lower$descriptor() {
        return uuid_unparse_lower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_unparse_lower(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static MethodHandle uuid_unparse_lower$handle() {
        return uuid_unparse_lower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_unparse_lower(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static MemorySegment uuid_unparse_lower$address() {
        return uuid_unparse_lower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_unparse_lower(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static void uuid_unparse_lower(MemorySegment uu, MemorySegment out) {
        var mh$ = uuid_unparse_lower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_unparse_lower", uu, out);
            }
            mh$.invokeExact(uu, out);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_unparse_upper {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.ofVoid(libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("uuid_unparse_upper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static FunctionDescriptor uuid_unparse_upper$descriptor() {
        return uuid_unparse_upper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static MethodHandle uuid_unparse_upper$handle() {
        return uuid_unparse_upper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static MemorySegment uuid_unparse_upper$address() {
        return uuid_unparse_upper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static void uuid_unparse_upper(MemorySegment uu, MemorySegment out) {
        var mh$ = uuid_unparse_upper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_unparse_upper", uu, out);
            }
            mh$.invokeExact(uu, out);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static final int SOCKINFO_GENERIC = (int) 0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_GENERIC = 0
     * }
     */
    public static int SOCKINFO_GENERIC() {
        return SOCKINFO_GENERIC;
    }

    private static final int SOCKINFO_IN = (int) 1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_IN = 1
     * }
     */
    public static int SOCKINFO_IN() {
        return SOCKINFO_IN;
    }

    private static final int SOCKINFO_TCP = (int) 2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_TCP = 2
     * }
     */
    public static int SOCKINFO_TCP() {
        return SOCKINFO_TCP;
    }

    private static final int SOCKINFO_UN = (int) 3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_UN = 3
     * }
     */
    public static int SOCKINFO_UN() {
        return SOCKINFO_UN;
    }

    private static final int SOCKINFO_NDRV = (int) 4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_NDRV = 4
     * }
     */
    public static int SOCKINFO_NDRV() {
        return SOCKINFO_NDRV;
    }

    private static final int SOCKINFO_KERN_EVENT = (int) 5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_KERN_EVENT = 5
     * }
     */
    public static int SOCKINFO_KERN_EVENT() {
        return SOCKINFO_KERN_EVENT;
    }

    private static final int SOCKINFO_KERN_CTL = (int) 6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_KERN_CTL = 6
     * }
     */
    public static int SOCKINFO_KERN_CTL() {
        return SOCKINFO_KERN_CTL;
    }

    private static final int SOCKINFO_VSOCK = (int) 7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_VSOCK = 7
     * }
     */
    public static int SOCKINFO_VSOCK() {
        return SOCKINFO_VSOCK;
    }
    /**
     * {@snippet lang=c :
     * typedef uint64_t proc_info_udata_t
     * }
     */
    public static final OfLong proc_info_udata_t = libproc_h.C_LONG_LONG;

    private static class proc_listpidspath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_listpidspath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_listpidspath(uint32_t type, uint32_t typeinfo, const char *path, uint32_t pathflags, void *buffer, int buffersize)
     * }
     */
    public static FunctionDescriptor proc_listpidspath$descriptor() {
        return proc_listpidspath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_listpidspath(uint32_t type, uint32_t typeinfo, const char *path, uint32_t pathflags, void *buffer, int buffersize)
     * }
     */
    public static MethodHandle proc_listpidspath$handle() {
        return proc_listpidspath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_listpidspath(uint32_t type, uint32_t typeinfo, const char *path, uint32_t pathflags, void *buffer, int buffersize)
     * }
     */
    public static MemorySegment proc_listpidspath$address() {
        return proc_listpidspath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_listpidspath(uint32_t type, uint32_t typeinfo, const char *path, uint32_t pathflags, void *buffer, int buffersize)
     * }
     */
    public static int proc_listpidspath(
            int type, int typeinfo, MemorySegment path, int pathflags, MemorySegment buffer, int buffersize) {
        var mh$ = proc_listpidspath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_listpidspath", type, typeinfo, path, pathflags, buffer, buffersize);
            }
            return (int) mh$.invokeExact(type, typeinfo, path, pathflags, buffer, buffersize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_listpids {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_listpids");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_listpids(uint32_t type, uint32_t typeinfo, void *buffer, int buffersize)
     * }
     */
    public static FunctionDescriptor proc_listpids$descriptor() {
        return proc_listpids.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_listpids(uint32_t type, uint32_t typeinfo, void *buffer, int buffersize)
     * }
     */
    public static MethodHandle proc_listpids$handle() {
        return proc_listpids.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_listpids(uint32_t type, uint32_t typeinfo, void *buffer, int buffersize)
     * }
     */
    public static MemorySegment proc_listpids$address() {
        return proc_listpids.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_listpids(uint32_t type, uint32_t typeinfo, void *buffer, int buffersize)
     * }
     */
    public static int proc_listpids(int type, int typeinfo, MemorySegment buffer, int buffersize) {
        var mh$ = proc_listpids.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_listpids", type, typeinfo, buffer, buffersize);
            }
            return (int) mh$.invokeExact(type, typeinfo, buffer, buffersize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_listallpids {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_listallpids");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_listallpids(void *buffer, int buffersize)
     * }
     */
    public static FunctionDescriptor proc_listallpids$descriptor() {
        return proc_listallpids.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_listallpids(void *buffer, int buffersize)
     * }
     */
    public static MethodHandle proc_listallpids$handle() {
        return proc_listallpids.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_listallpids(void *buffer, int buffersize)
     * }
     */
    public static MemorySegment proc_listallpids$address() {
        return proc_listallpids.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_listallpids(void *buffer, int buffersize)
     * }
     */
    public static int proc_listallpids(MemorySegment buffer, int buffersize) {
        var mh$ = proc_listallpids.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_listallpids", buffer, buffersize);
            }
            return (int) mh$.invokeExact(buffer, buffersize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_listpgrppids {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_listpgrppids");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_listpgrppids(pid_t pgrpid, void *buffer, int buffersize)
     * }
     */
    public static FunctionDescriptor proc_listpgrppids$descriptor() {
        return proc_listpgrppids.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_listpgrppids(pid_t pgrpid, void *buffer, int buffersize)
     * }
     */
    public static MethodHandle proc_listpgrppids$handle() {
        return proc_listpgrppids.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_listpgrppids(pid_t pgrpid, void *buffer, int buffersize)
     * }
     */
    public static MemorySegment proc_listpgrppids$address() {
        return proc_listpgrppids.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_listpgrppids(pid_t pgrpid, void *buffer, int buffersize)
     * }
     */
    public static int proc_listpgrppids(int pgrpid, MemorySegment buffer, int buffersize) {
        var mh$ = proc_listpgrppids.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_listpgrppids", pgrpid, buffer, buffersize);
            }
            return (int) mh$.invokeExact(pgrpid, buffer, buffersize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_listchildpids {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_listchildpids");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_listchildpids(pid_t ppid, void *buffer, int buffersize)
     * }
     */
    public static FunctionDescriptor proc_listchildpids$descriptor() {
        return proc_listchildpids.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_listchildpids(pid_t ppid, void *buffer, int buffersize)
     * }
     */
    public static MethodHandle proc_listchildpids$handle() {
        return proc_listchildpids.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_listchildpids(pid_t ppid, void *buffer, int buffersize)
     * }
     */
    public static MemorySegment proc_listchildpids$address() {
        return proc_listchildpids.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_listchildpids(pid_t ppid, void *buffer, int buffersize)
     * }
     */
    public static int proc_listchildpids(int ppid, MemorySegment buffer, int buffersize) {
        var mh$ = proc_listchildpids.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_listchildpids", ppid, buffer, buffersize);
            }
            return (int) mh$.invokeExact(ppid, buffer, buffersize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_pidinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_LONG_LONG,
                libproc_h.C_POINTER,
                libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_pidinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
     * }
     */
    public static FunctionDescriptor proc_pidinfo$descriptor() {
        return proc_pidinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
     * }
     */
    public static MethodHandle proc_pidinfo$handle() {
        return proc_pidinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
     * }
     */
    public static MemorySegment proc_pidinfo$address() {
        return proc_pidinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
     * }
     */
    public static int proc_pidinfo(int pid, int flavor, long arg, MemorySegment buffer, int buffersize) {
        var mh$ = proc_pidinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_pidinfo", pid, flavor, arg, buffer, buffersize);
            }
            return (int) mh$.invokeExact(pid, flavor, arg, buffer, buffersize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_pidfdinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_pidfdinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_pidfdinfo(int pid, int fd, int flavor, void *buffer, int buffersize)
     * }
     */
    public static FunctionDescriptor proc_pidfdinfo$descriptor() {
        return proc_pidfdinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_pidfdinfo(int pid, int fd, int flavor, void *buffer, int buffersize)
     * }
     */
    public static MethodHandle proc_pidfdinfo$handle() {
        return proc_pidfdinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_pidfdinfo(int pid, int fd, int flavor, void *buffer, int buffersize)
     * }
     */
    public static MemorySegment proc_pidfdinfo$address() {
        return proc_pidfdinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_pidfdinfo(int pid, int fd, int flavor, void *buffer, int buffersize)
     * }
     */
    public static int proc_pidfdinfo(int pid, int fd, int flavor, MemorySegment buffer, int buffersize) {
        var mh$ = proc_pidfdinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_pidfdinfo", pid, fd, flavor, buffer, buffersize);
            }
            return (int) mh$.invokeExact(pid, fd, flavor, buffer, buffersize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_pidfileportinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_INT,
                libproc_h.C_POINTER,
                libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_pidfileportinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_pidfileportinfo(int pid, uint32_t fileport, int flavor, void *buffer, int buffersize)
     * }
     */
    public static FunctionDescriptor proc_pidfileportinfo$descriptor() {
        return proc_pidfileportinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_pidfileportinfo(int pid, uint32_t fileport, int flavor, void *buffer, int buffersize)
     * }
     */
    public static MethodHandle proc_pidfileportinfo$handle() {
        return proc_pidfileportinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_pidfileportinfo(int pid, uint32_t fileport, int flavor, void *buffer, int buffersize)
     * }
     */
    public static MemorySegment proc_pidfileportinfo$address() {
        return proc_pidfileportinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_pidfileportinfo(int pid, uint32_t fileport, int flavor, void *buffer, int buffersize)
     * }
     */
    public static int proc_pidfileportinfo(int pid, int fileport, int flavor, MemorySegment buffer, int buffersize) {
        var mh$ = proc_pidfileportinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_pidfileportinfo", pid, fileport, flavor, buffer, buffersize);
            }
            return (int) mh$.invokeExact(pid, fileport, flavor, buffer, buffersize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_name {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_name(int pid, void *buffer, uint32_t buffersize)
     * }
     */
    public static FunctionDescriptor proc_name$descriptor() {
        return proc_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_name(int pid, void *buffer, uint32_t buffersize)
     * }
     */
    public static MethodHandle proc_name$handle() {
        return proc_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_name(int pid, void *buffer, uint32_t buffersize)
     * }
     */
    public static MemorySegment proc_name$address() {
        return proc_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_name(int pid, void *buffer, uint32_t buffersize)
     * }
     */
    public static int proc_name(int pid, MemorySegment buffer, int buffersize) {
        var mh$ = proc_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_name", pid, buffer, buffersize);
            }
            return (int) mh$.invokeExact(pid, buffer, buffersize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_regionfilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_LONG_LONG, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_regionfilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_regionfilename(int pid, uint64_t address, void *buffer, uint32_t buffersize)
     * }
     */
    public static FunctionDescriptor proc_regionfilename$descriptor() {
        return proc_regionfilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_regionfilename(int pid, uint64_t address, void *buffer, uint32_t buffersize)
     * }
     */
    public static MethodHandle proc_regionfilename$handle() {
        return proc_regionfilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_regionfilename(int pid, uint64_t address, void *buffer, uint32_t buffersize)
     * }
     */
    public static MemorySegment proc_regionfilename$address() {
        return proc_regionfilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_regionfilename(int pid, uint64_t address, void *buffer, uint32_t buffersize)
     * }
     */
    public static int proc_regionfilename(int pid, long address, MemorySegment buffer, int buffersize) {
        var mh$ = proc_regionfilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_regionfilename", pid, address, buffer, buffersize);
            }
            return (int) mh$.invokeExact(pid, address, buffer, buffersize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_kmsgbuf {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_kmsgbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_kmsgbuf(void *buffer, uint32_t buffersize)
     * }
     */
    public static FunctionDescriptor proc_kmsgbuf$descriptor() {
        return proc_kmsgbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_kmsgbuf(void *buffer, uint32_t buffersize)
     * }
     */
    public static MethodHandle proc_kmsgbuf$handle() {
        return proc_kmsgbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_kmsgbuf(void *buffer, uint32_t buffersize)
     * }
     */
    public static MemorySegment proc_kmsgbuf$address() {
        return proc_kmsgbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_kmsgbuf(void *buffer, uint32_t buffersize)
     * }
     */
    public static int proc_kmsgbuf(MemorySegment buffer, int buffersize) {
        var mh$ = proc_kmsgbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_kmsgbuf", buffer, buffersize);
            }
            return (int) mh$.invokeExact(buffer, buffersize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_pidpath {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_pidpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_pidpath(int pid, void *buffer, uint32_t buffersize)
     * }
     */
    public static FunctionDescriptor proc_pidpath$descriptor() {
        return proc_pidpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_pidpath(int pid, void *buffer, uint32_t buffersize)
     * }
     */
    public static MethodHandle proc_pidpath$handle() {
        return proc_pidpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_pidpath(int pid, void *buffer, uint32_t buffersize)
     * }
     */
    public static MemorySegment proc_pidpath$address() {
        return proc_pidpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_pidpath(int pid, void *buffer, uint32_t buffersize)
     * }
     */
    public static int proc_pidpath(int pid, MemorySegment buffer, int buffersize) {
        var mh$ = proc_pidpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_pidpath", pid, buffer, buffersize);
            }
            return (int) mh$.invokeExact(pid, buffer, buffersize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_pidpath_audittoken {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_pidpath_audittoken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_pidpath_audittoken(audit_token_t *audittoken, void *buffer, uint32_t buffersize)
     * }
     */
    public static FunctionDescriptor proc_pidpath_audittoken$descriptor() {
        return proc_pidpath_audittoken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_pidpath_audittoken(audit_token_t *audittoken, void *buffer, uint32_t buffersize)
     * }
     */
    public static MethodHandle proc_pidpath_audittoken$handle() {
        return proc_pidpath_audittoken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_pidpath_audittoken(audit_token_t *audittoken, void *buffer, uint32_t buffersize)
     * }
     */
    public static MemorySegment proc_pidpath_audittoken$address() {
        return proc_pidpath_audittoken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_pidpath_audittoken(audit_token_t *audittoken, void *buffer, uint32_t buffersize)
     * }
     */
    public static int proc_pidpath_audittoken(MemorySegment audittoken, MemorySegment buffer, int buffersize) {
        var mh$ = proc_pidpath_audittoken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_pidpath_audittoken", audittoken, buffer, buffersize);
            }
            return (int) mh$.invokeExact(audittoken, buffer, buffersize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_libversion {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_libversion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_libversion(int *major, int *minor)
     * }
     */
    public static FunctionDescriptor proc_libversion$descriptor() {
        return proc_libversion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_libversion(int *major, int *minor)
     * }
     */
    public static MethodHandle proc_libversion$handle() {
        return proc_libversion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_libversion(int *major, int *minor)
     * }
     */
    public static MemorySegment proc_libversion$address() {
        return proc_libversion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_libversion(int *major, int *minor)
     * }
     */
    public static int proc_libversion(MemorySegment major, MemorySegment minor) {
        var mh$ = proc_libversion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_libversion", major, minor);
            }
            return (int) mh$.invokeExact(major, minor);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_pid_rusage {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_pid_rusage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_pid_rusage(int pid, int flavor, rusage_info_t *buffer)
     * }
     */
    public static FunctionDescriptor proc_pid_rusage$descriptor() {
        return proc_pid_rusage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_pid_rusage(int pid, int flavor, rusage_info_t *buffer)
     * }
     */
    public static MethodHandle proc_pid_rusage$handle() {
        return proc_pid_rusage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_pid_rusage(int pid, int flavor, rusage_info_t *buffer)
     * }
     */
    public static MemorySegment proc_pid_rusage$address() {
        return proc_pid_rusage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_pid_rusage(int pid, int flavor, rusage_info_t *buffer)
     * }
     */
    public static int proc_pid_rusage(int pid, int flavor, MemorySegment buffer) {
        var mh$ = proc_pid_rusage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_pid_rusage", pid, flavor, buffer);
            }
            return (int) mh$.invokeExact(pid, flavor, buffer);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_setpcontrol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_setpcontrol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_setpcontrol(const int control)
     * }
     */
    public static FunctionDescriptor proc_setpcontrol$descriptor() {
        return proc_setpcontrol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_setpcontrol(const int control)
     * }
     */
    public static MethodHandle proc_setpcontrol$handle() {
        return proc_setpcontrol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_setpcontrol(const int control)
     * }
     */
    public static MemorySegment proc_setpcontrol$address() {
        return proc_setpcontrol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_setpcontrol(const int control)
     * }
     */
    public static int proc_setpcontrol(int control) {
        var mh$ = proc_setpcontrol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_setpcontrol", control);
            }
            return (int) mh$.invokeExact(control);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_track_dirty {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_track_dirty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_track_dirty(pid_t pid, uint32_t flags)
     * }
     */
    public static FunctionDescriptor proc_track_dirty$descriptor() {
        return proc_track_dirty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_track_dirty(pid_t pid, uint32_t flags)
     * }
     */
    public static MethodHandle proc_track_dirty$handle() {
        return proc_track_dirty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_track_dirty(pid_t pid, uint32_t flags)
     * }
     */
    public static MemorySegment proc_track_dirty$address() {
        return proc_track_dirty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_track_dirty(pid_t pid, uint32_t flags)
     * }
     */
    public static int proc_track_dirty(int pid, int flags) {
        var mh$ = proc_track_dirty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_track_dirty", pid, flags);
            }
            return (int) mh$.invokeExact(pid, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_set_dirty {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_BOOL);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_set_dirty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_set_dirty(pid_t pid, bool dirty)
     * }
     */
    public static FunctionDescriptor proc_set_dirty$descriptor() {
        return proc_set_dirty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_set_dirty(pid_t pid, bool dirty)
     * }
     */
    public static MethodHandle proc_set_dirty$handle() {
        return proc_set_dirty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_set_dirty(pid_t pid, bool dirty)
     * }
     */
    public static MemorySegment proc_set_dirty$address() {
        return proc_set_dirty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_set_dirty(pid_t pid, bool dirty)
     * }
     */
    public static int proc_set_dirty(int pid, boolean dirty) {
        var mh$ = proc_set_dirty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_set_dirty", pid, dirty);
            }
            return (int) mh$.invokeExact(pid, dirty);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_get_dirty {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_get_dirty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_get_dirty(pid_t pid, uint32_t *flags)
     * }
     */
    public static FunctionDescriptor proc_get_dirty$descriptor() {
        return proc_get_dirty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_get_dirty(pid_t pid, uint32_t *flags)
     * }
     */
    public static MethodHandle proc_get_dirty$handle() {
        return proc_get_dirty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_get_dirty(pid_t pid, uint32_t *flags)
     * }
     */
    public static MemorySegment proc_get_dirty$address() {
        return proc_get_dirty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_get_dirty(pid_t pid, uint32_t *flags)
     * }
     */
    public static int proc_get_dirty(int pid, MemorySegment flags) {
        var mh$ = proc_get_dirty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_get_dirty", pid, flags);
            }
            return (int) mh$.invokeExact(pid, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_clear_dirty {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_clear_dirty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_clear_dirty(pid_t pid, uint32_t flags)
     * }
     */
    public static FunctionDescriptor proc_clear_dirty$descriptor() {
        return proc_clear_dirty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_clear_dirty(pid_t pid, uint32_t flags)
     * }
     */
    public static MethodHandle proc_clear_dirty$handle() {
        return proc_clear_dirty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_clear_dirty(pid_t pid, uint32_t flags)
     * }
     */
    public static MemorySegment proc_clear_dirty$address() {
        return proc_clear_dirty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_clear_dirty(pid_t pid, uint32_t flags)
     * }
     */
    public static int proc_clear_dirty(int pid, int flags) {
        var mh$ = proc_clear_dirty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_clear_dirty", pid, flags);
            }
            return (int) mh$.invokeExact(pid, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_terminate {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_terminate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_terminate(pid_t pid, int *sig)
     * }
     */
    public static FunctionDescriptor proc_terminate$descriptor() {
        return proc_terminate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_terminate(pid_t pid, int *sig)
     * }
     */
    public static MethodHandle proc_terminate$handle() {
        return proc_terminate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_terminate(pid_t pid, int *sig)
     * }
     */
    public static MemorySegment proc_terminate$address() {
        return proc_terminate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_terminate(pid_t pid, int *sig)
     * }
     */
    public static int proc_terminate(int pid, MemorySegment sig) {
        var mh$ = proc_terminate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_terminate", pid, sig);
            }
            return (int) mh$.invokeExact(pid, sig);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_terminate_all_rsr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_terminate_all_rsr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_terminate_all_rsr(int sig)
     * }
     */
    public static FunctionDescriptor proc_terminate_all_rsr$descriptor() {
        return proc_terminate_all_rsr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_terminate_all_rsr(int sig)
     * }
     */
    public static MethodHandle proc_terminate_all_rsr$handle() {
        return proc_terminate_all_rsr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_terminate_all_rsr(int sig)
     * }
     */
    public static MemorySegment proc_terminate_all_rsr$address() {
        return proc_terminate_all_rsr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_terminate_all_rsr(int sig)
     * }
     */
    public static int proc_terminate_all_rsr(int sig) {
        var mh$ = proc_terminate_all_rsr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_terminate_all_rsr", sig);
            }
            return (int) mh$.invokeExact(sig);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_signal_with_audittoken {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_signal_with_audittoken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_signal_with_audittoken(audit_token_t *audittoken, int sig)
     * }
     */
    public static FunctionDescriptor proc_signal_with_audittoken$descriptor() {
        return proc_signal_with_audittoken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_signal_with_audittoken(audit_token_t *audittoken, int sig)
     * }
     */
    public static MethodHandle proc_signal_with_audittoken$handle() {
        return proc_signal_with_audittoken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_signal_with_audittoken(audit_token_t *audittoken, int sig)
     * }
     */
    public static MemorySegment proc_signal_with_audittoken$address() {
        return proc_signal_with_audittoken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_signal_with_audittoken(audit_token_t *audittoken, int sig)
     * }
     */
    public static int proc_signal_with_audittoken(MemorySegment audittoken, int sig) {
        var mh$ = proc_signal_with_audittoken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_signal_with_audittoken", audittoken, sig);
            }
            return (int) mh$.invokeExact(audittoken, sig);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_terminate_with_audittoken {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_POINTER);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_terminate_with_audittoken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_terminate_with_audittoken(audit_token_t *audittoken, int *sig)
     * }
     */
    public static FunctionDescriptor proc_terminate_with_audittoken$descriptor() {
        return proc_terminate_with_audittoken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_terminate_with_audittoken(audit_token_t *audittoken, int *sig)
     * }
     */
    public static MethodHandle proc_terminate_with_audittoken$handle() {
        return proc_terminate_with_audittoken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_terminate_with_audittoken(audit_token_t *audittoken, int *sig)
     * }
     */
    public static MemorySegment proc_terminate_with_audittoken$address() {
        return proc_terminate_with_audittoken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_terminate_with_audittoken(audit_token_t *audittoken, int *sig)
     * }
     */
    public static int proc_terminate_with_audittoken(MemorySegment audittoken, MemorySegment sig) {
        var mh$ = proc_terminate_with_audittoken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_terminate_with_audittoken", audittoken, sig);
            }
            return (int) mh$.invokeExact(audittoken, sig);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_set_no_smt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_set_no_smt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_set_no_smt()
     * }
     */
    public static FunctionDescriptor proc_set_no_smt$descriptor() {
        return proc_set_no_smt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_set_no_smt()
     * }
     */
    public static MethodHandle proc_set_no_smt$handle() {
        return proc_set_no_smt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_set_no_smt()
     * }
     */
    public static MemorySegment proc_set_no_smt$address() {
        return proc_set_no_smt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_set_no_smt()
     * }
     */
    public static int proc_set_no_smt() {
        var mh$ = proc_set_no_smt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_set_no_smt");
            }
            return (int) mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_setthread_no_smt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_setthread_no_smt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_setthread_no_smt()
     * }
     */
    public static FunctionDescriptor proc_setthread_no_smt$descriptor() {
        return proc_setthread_no_smt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_setthread_no_smt()
     * }
     */
    public static MethodHandle proc_setthread_no_smt$handle() {
        return proc_setthread_no_smt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_setthread_no_smt()
     * }
     */
    public static MemorySegment proc_setthread_no_smt$address() {
        return proc_setthread_no_smt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_setthread_no_smt()
     * }
     */
    public static int proc_setthread_no_smt() {
        var mh$ = proc_setthread_no_smt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_setthread_no_smt");
            }
            return (int) mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_set_csm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_set_csm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_set_csm(uint32_t flags)
     * }
     */
    public static FunctionDescriptor proc_set_csm$descriptor() {
        return proc_set_csm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_set_csm(uint32_t flags)
     * }
     */
    public static MethodHandle proc_set_csm$handle() {
        return proc_set_csm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_set_csm(uint32_t flags)
     * }
     */
    public static MemorySegment proc_set_csm$address() {
        return proc_set_csm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_set_csm(uint32_t flags)
     * }
     */
    public static int proc_set_csm(int flags) {
        var mh$ = proc_set_csm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_set_csm", flags);
            }
            return (int) mh$.invokeExact(flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_setthread_csm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(libproc_h.C_INT, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_setthread_csm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_setthread_csm(uint32_t flags)
     * }
     */
    public static FunctionDescriptor proc_setthread_csm$descriptor() {
        return proc_setthread_csm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_setthread_csm(uint32_t flags)
     * }
     */
    public static MethodHandle proc_setthread_csm$handle() {
        return proc_setthread_csm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_setthread_csm(uint32_t flags)
     * }
     */
    public static MemorySegment proc_setthread_csm$address() {
        return proc_setthread_csm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_setthread_csm(uint32_t flags)
     * }
     */
    public static int proc_setthread_csm(int flags) {
        var mh$ = proc_setthread_csm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_setthread_csm", flags);
            }
            return (int) mh$.invokeExact(flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proc_udata_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_INT, libproc_h.C_POINTER, libproc_h.C_INT);

        public static final MemorySegment ADDR = libproc_h.findOrThrow("proc_udata_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proc_udata_info(int pid, int flavor, void *buffer, int buffersize)
     * }
     */
    public static FunctionDescriptor proc_udata_info$descriptor() {
        return proc_udata_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proc_udata_info(int pid, int flavor, void *buffer, int buffersize)
     * }
     */
    public static MethodHandle proc_udata_info$handle() {
        return proc_udata_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proc_udata_info(int pid, int flavor, void *buffer, int buffersize)
     * }
     */
    public static MemorySegment proc_udata_info$address() {
        return proc_udata_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proc_udata_info(int pid, int flavor, void *buffer, int buffersize)
     * }
     */
    public static int proc_udata_info(int pid, int flavor, MemorySegment buffer, int buffersize) {
        var mh$ = proc_udata_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proc_udata_info", pid, flavor, buffer, buffersize);
            }
            return (int) mh$.invokeExact(pid, flavor, buffer, buffersize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN = libproc_h.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }

    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }

    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }

    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }

    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }

    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }

    private static final long USER_ADDR_NULL = 0L;
    /**
     * {@snippet lang=c :
     * #define USER_ADDR_NULL 0
     * }
     */
    public static long USER_ADDR_NULL() {
        return USER_ADDR_NULL;
    }

    private static final int __DARWIN_BYTE_ORDER = (int) 1234L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_BYTE_ORDER 1234
     * }
     */
    public static int __DARWIN_BYTE_ORDER() {
        return __DARWIN_BYTE_ORDER;
    }

    private static final int LITTLE_ENDIAN = (int) 1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }

    private static final int BIG_ENDIAN = (int) 4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }

    private static final int PDP_ENDIAN = (int) 3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }

    private static final int BYTE_ORDER = (int) 1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }

    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }

    private static final int INT8_MIN = (int) -128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }

    private static final int INT16_MIN = (int) -32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }

    private static final int INT32_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }

    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }

    private static final int UINT32_MAX = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }

    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }

    private static final int INT_LEAST8_MIN = (int) -128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }

    private static final int INT_LEAST16_MIN = (int) -32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }

    private static final int INT_LEAST32_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }

    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }

    private static final int INT_LEAST8_MAX = (int) 127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }

    private static final int INT_LEAST16_MAX = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }

    private static final int INT_LEAST32_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }

    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }

    private static final int UINT_LEAST8_MAX = (int) 255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }

    private static final int UINT_LEAST16_MAX = (int) 65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }

    private static final int UINT_LEAST32_MAX = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }

    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }

    private static final int INT_FAST8_MIN = (int) -128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }

    private static final int INT_FAST16_MIN = (int) -32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }

    private static final int INT_FAST32_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }

    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }

    private static final int INT_FAST8_MAX = (int) 127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }

    private static final int INT_FAST16_MAX = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }

    private static final int INT_FAST32_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }

    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }

    private static final int UINT_FAST8_MAX = (int) 255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }

    private static final int UINT_FAST16_MAX = (int) 65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }

    private static final int UINT_FAST32_MAX = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }

    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }

    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }

    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }

    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }

    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }

    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }

    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }

    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }

    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }

    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }

    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }

    private static final int WCHAR_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }

    private static final int WCHAR_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }

    private static final int WINT_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }

    private static final int WINT_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }

    private static final int SIG_ATOMIC_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }

    private static final int SIG_ATOMIC_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }

    private static final int MAC_OS_X_VERSION_10_0 = (int) 1000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_0 1000
     * }
     */
    public static int MAC_OS_X_VERSION_10_0() {
        return MAC_OS_X_VERSION_10_0;
    }

    private static final int MAC_OS_X_VERSION_10_1 = (int) 1010L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_1 1010
     * }
     */
    public static int MAC_OS_X_VERSION_10_1() {
        return MAC_OS_X_VERSION_10_1;
    }

    private static final int MAC_OS_X_VERSION_10_2 = (int) 1020L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_2 1020
     * }
     */
    public static int MAC_OS_X_VERSION_10_2() {
        return MAC_OS_X_VERSION_10_2;
    }

    private static final int MAC_OS_X_VERSION_10_3 = (int) 1030L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_3 1030
     * }
     */
    public static int MAC_OS_X_VERSION_10_3() {
        return MAC_OS_X_VERSION_10_3;
    }

    private static final int MAC_OS_X_VERSION_10_4 = (int) 1040L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_4 1040
     * }
     */
    public static int MAC_OS_X_VERSION_10_4() {
        return MAC_OS_X_VERSION_10_4;
    }

    private static final int MAC_OS_X_VERSION_10_5 = (int) 1050L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_5 1050
     * }
     */
    public static int MAC_OS_X_VERSION_10_5() {
        return MAC_OS_X_VERSION_10_5;
    }

    private static final int MAC_OS_X_VERSION_10_6 = (int) 1060L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_6 1060
     * }
     */
    public static int MAC_OS_X_VERSION_10_6() {
        return MAC_OS_X_VERSION_10_6;
    }

    private static final int MAC_OS_X_VERSION_10_7 = (int) 1070L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_7 1070
     * }
     */
    public static int MAC_OS_X_VERSION_10_7() {
        return MAC_OS_X_VERSION_10_7;
    }

    private static final int MAC_OS_X_VERSION_10_8 = (int) 1080L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_8 1080
     * }
     */
    public static int MAC_OS_X_VERSION_10_8() {
        return MAC_OS_X_VERSION_10_8;
    }

    private static final int MAC_OS_X_VERSION_10_9 = (int) 1090L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_9 1090
     * }
     */
    public static int MAC_OS_X_VERSION_10_9() {
        return MAC_OS_X_VERSION_10_9;
    }

    private static final int MAC_OS_X_VERSION_10_10 = (int) 101000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10 101000
     * }
     */
    public static int MAC_OS_X_VERSION_10_10() {
        return MAC_OS_X_VERSION_10_10;
    }

    private static final int MAC_OS_X_VERSION_10_10_2 = (int) 101002L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_2 101002
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_2() {
        return MAC_OS_X_VERSION_10_10_2;
    }

    private static final int MAC_OS_X_VERSION_10_10_3 = (int) 101003L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_3 101003
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_3() {
        return MAC_OS_X_VERSION_10_10_3;
    }

    private static final int MAC_OS_X_VERSION_10_11 = (int) 101100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11 101100
     * }
     */
    public static int MAC_OS_X_VERSION_10_11() {
        return MAC_OS_X_VERSION_10_11;
    }

    private static final int MAC_OS_X_VERSION_10_11_2 = (int) 101102L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_2 101102
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_2() {
        return MAC_OS_X_VERSION_10_11_2;
    }

    private static final int MAC_OS_X_VERSION_10_11_3 = (int) 101103L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_3 101103
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_3() {
        return MAC_OS_X_VERSION_10_11_3;
    }

    private static final int MAC_OS_X_VERSION_10_11_4 = (int) 101104L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_4 101104
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_4() {
        return MAC_OS_X_VERSION_10_11_4;
    }

    private static final int MAC_OS_X_VERSION_10_12 = (int) 101200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12 101200
     * }
     */
    public static int MAC_OS_X_VERSION_10_12() {
        return MAC_OS_X_VERSION_10_12;
    }

    private static final int MAC_OS_X_VERSION_10_12_1 = (int) 101201L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_1 101201
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_1() {
        return MAC_OS_X_VERSION_10_12_1;
    }

    private static final int MAC_OS_X_VERSION_10_12_2 = (int) 101202L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_2 101202
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_2() {
        return MAC_OS_X_VERSION_10_12_2;
    }

    private static final int MAC_OS_X_VERSION_10_12_4 = (int) 101204L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_4 101204
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_4() {
        return MAC_OS_X_VERSION_10_12_4;
    }

    private static final int MAC_OS_X_VERSION_10_13 = (int) 101300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13 101300
     * }
     */
    public static int MAC_OS_X_VERSION_10_13() {
        return MAC_OS_X_VERSION_10_13;
    }

    private static final int MAC_OS_X_VERSION_10_13_1 = (int) 101301L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_1 101301
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_1() {
        return MAC_OS_X_VERSION_10_13_1;
    }

    private static final int MAC_OS_X_VERSION_10_13_2 = (int) 101302L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_2 101302
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_2() {
        return MAC_OS_X_VERSION_10_13_2;
    }

    private static final int MAC_OS_X_VERSION_10_13_4 = (int) 101304L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_4 101304
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_4() {
        return MAC_OS_X_VERSION_10_13_4;
    }

    private static final int MAC_OS_X_VERSION_10_14 = (int) 101400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14 101400
     * }
     */
    public static int MAC_OS_X_VERSION_10_14() {
        return MAC_OS_X_VERSION_10_14;
    }

    private static final int MAC_OS_X_VERSION_10_14_1 = (int) 101401L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_1 101401
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_1() {
        return MAC_OS_X_VERSION_10_14_1;
    }

    private static final int MAC_OS_X_VERSION_10_14_4 = (int) 101404L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_4 101404
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_4() {
        return MAC_OS_X_VERSION_10_14_4;
    }

    private static final int MAC_OS_X_VERSION_10_14_5 = (int) 101405L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_5 101405
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_5() {
        return MAC_OS_X_VERSION_10_14_5;
    }

    private static final int MAC_OS_X_VERSION_10_14_6 = (int) 101406L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_6 101406
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_6() {
        return MAC_OS_X_VERSION_10_14_6;
    }

    private static final int MAC_OS_X_VERSION_10_15 = (int) 101500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15 101500
     * }
     */
    public static int MAC_OS_X_VERSION_10_15() {
        return MAC_OS_X_VERSION_10_15;
    }

    private static final int MAC_OS_X_VERSION_10_15_1 = (int) 101501L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_1 101501
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_1() {
        return MAC_OS_X_VERSION_10_15_1;
    }

    private static final int MAC_OS_X_VERSION_10_15_4 = (int) 101504L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_4 101504
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_4() {
        return MAC_OS_X_VERSION_10_15_4;
    }

    private static final int MAC_OS_X_VERSION_10_16 = (int) 101600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_16 101600
     * }
     */
    public static int MAC_OS_X_VERSION_10_16() {
        return MAC_OS_X_VERSION_10_16;
    }

    private static final int MAC_OS_VERSION_11_0 = (int) 110000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_0 110000
     * }
     */
    public static int MAC_OS_VERSION_11_0() {
        return MAC_OS_VERSION_11_0;
    }

    private static final int MAC_OS_VERSION_11_1 = (int) 110100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_1 110100
     * }
     */
    public static int MAC_OS_VERSION_11_1() {
        return MAC_OS_VERSION_11_1;
    }

    private static final int MAC_OS_VERSION_11_3 = (int) 110300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_3 110300
     * }
     */
    public static int MAC_OS_VERSION_11_3() {
        return MAC_OS_VERSION_11_3;
    }

    private static final int MAC_OS_VERSION_11_4 = (int) 110400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_4 110400
     * }
     */
    public static int MAC_OS_VERSION_11_4() {
        return MAC_OS_VERSION_11_4;
    }

    private static final int MAC_OS_VERSION_11_5 = (int) 110500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_5 110500
     * }
     */
    public static int MAC_OS_VERSION_11_5() {
        return MAC_OS_VERSION_11_5;
    }

    private static final int MAC_OS_VERSION_11_6 = (int) 110600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_6 110600
     * }
     */
    public static int MAC_OS_VERSION_11_6() {
        return MAC_OS_VERSION_11_6;
    }

    private static final int MAC_OS_VERSION_12_0 = (int) 120000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_0 120000
     * }
     */
    public static int MAC_OS_VERSION_12_0() {
        return MAC_OS_VERSION_12_0;
    }

    private static final int MAC_OS_VERSION_12_1 = (int) 120100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_1 120100
     * }
     */
    public static int MAC_OS_VERSION_12_1() {
        return MAC_OS_VERSION_12_1;
    }

    private static final int MAC_OS_VERSION_12_2 = (int) 120200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_2 120200
     * }
     */
    public static int MAC_OS_VERSION_12_2() {
        return MAC_OS_VERSION_12_2;
    }

    private static final int MAC_OS_VERSION_12_3 = (int) 120300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_3 120300
     * }
     */
    public static int MAC_OS_VERSION_12_3() {
        return MAC_OS_VERSION_12_3;
    }

    private static final int MAC_OS_VERSION_12_4 = (int) 120400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_4 120400
     * }
     */
    public static int MAC_OS_VERSION_12_4() {
        return MAC_OS_VERSION_12_4;
    }

    private static final int MAC_OS_VERSION_12_5 = (int) 120500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_5 120500
     * }
     */
    public static int MAC_OS_VERSION_12_5() {
        return MAC_OS_VERSION_12_5;
    }

    private static final int MAC_OS_VERSION_12_6 = (int) 120600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_6 120600
     * }
     */
    public static int MAC_OS_VERSION_12_6() {
        return MAC_OS_VERSION_12_6;
    }

    private static final int MAC_OS_VERSION_12_7 = (int) 120700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_7 120700
     * }
     */
    public static int MAC_OS_VERSION_12_7() {
        return MAC_OS_VERSION_12_7;
    }

    private static final int MAC_OS_VERSION_13_0 = (int) 130000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_0 130000
     * }
     */
    public static int MAC_OS_VERSION_13_0() {
        return MAC_OS_VERSION_13_0;
    }

    private static final int MAC_OS_VERSION_13_1 = (int) 130100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_1 130100
     * }
     */
    public static int MAC_OS_VERSION_13_1() {
        return MAC_OS_VERSION_13_1;
    }

    private static final int MAC_OS_VERSION_13_2 = (int) 130200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_2 130200
     * }
     */
    public static int MAC_OS_VERSION_13_2() {
        return MAC_OS_VERSION_13_2;
    }

    private static final int MAC_OS_VERSION_13_3 = (int) 130300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_3 130300
     * }
     */
    public static int MAC_OS_VERSION_13_3() {
        return MAC_OS_VERSION_13_3;
    }

    private static final int MAC_OS_VERSION_13_4 = (int) 130400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_4 130400
     * }
     */
    public static int MAC_OS_VERSION_13_4() {
        return MAC_OS_VERSION_13_4;
    }

    private static final int MAC_OS_VERSION_13_5 = (int) 130500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_5 130500
     * }
     */
    public static int MAC_OS_VERSION_13_5() {
        return MAC_OS_VERSION_13_5;
    }

    private static final int MAC_OS_VERSION_13_6 = (int) 130600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_6 130600
     * }
     */
    public static int MAC_OS_VERSION_13_6() {
        return MAC_OS_VERSION_13_6;
    }

    private static final int MAC_OS_VERSION_14_0 = (int) 140000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_0 140000
     * }
     */
    public static int MAC_OS_VERSION_14_0() {
        return MAC_OS_VERSION_14_0;
    }

    private static final int MAC_OS_VERSION_14_1 = (int) 140100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_1 140100
     * }
     */
    public static int MAC_OS_VERSION_14_1() {
        return MAC_OS_VERSION_14_1;
    }

    private static final int MAC_OS_VERSION_14_2 = (int) 140200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_2 140200
     * }
     */
    public static int MAC_OS_VERSION_14_2() {
        return MAC_OS_VERSION_14_2;
    }

    private static final int MAC_OS_VERSION_14_3 = (int) 140300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_3 140300
     * }
     */
    public static int MAC_OS_VERSION_14_3() {
        return MAC_OS_VERSION_14_3;
    }

    private static final int MAC_OS_VERSION_14_4 = (int) 140400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_4 140400
     * }
     */
    public static int MAC_OS_VERSION_14_4() {
        return MAC_OS_VERSION_14_4;
    }

    private static final int __MAC_OS_X_VERSION_MAX_ALLOWED = (int) 140400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_OS_X_VERSION_MAX_ALLOWED 140400
     * }
     */
    public static int __MAC_OS_X_VERSION_MAX_ALLOWED() {
        return __MAC_OS_X_VERSION_MAX_ALLOWED;
    }

    private static final long __DARWIN_NFDBITS = 32L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NFDBITS 32
     * }
     */
    public static long __DARWIN_NFDBITS() {
        return __DARWIN_NFDBITS;
    }

    private static final int NBBY = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define NBBY 8
     * }
     */
    public static int NBBY() {
        return NBBY;
    }

    private static final long NFDBITS = 32L;
    /**
     * {@snippet lang=c :
     * #define NFDBITS 32
     * }
     */
    public static long NFDBITS() {
        return NFDBITS;
    }

    private static final int FD_SETSIZE = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define FD_SETSIZE 1024
     * }
     */
    public static int FD_SETSIZE() {
        return FD_SETSIZE;
    }

    private static final int ARG_MAX = (int) 1048576L;
    /**
     * {@snippet lang=c :
     * #define ARG_MAX 1048576
     * }
     */
    public static int ARG_MAX() {
        return ARG_MAX;
    }

    private static final int GID_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define GID_MAX 2147483647
     * }
     */
    public static int GID_MAX() {
        return GID_MAX;
    }

    private static final int UID_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define UID_MAX 2147483647
     * }
     */
    public static int UID_MAX() {
        return UID_MAX;
    }

    private static final int MAXUPRC = (int) 266L;
    /**
     * {@snippet lang=c :
     * #define MAXUPRC 266
     * }
     */
    public static int MAXUPRC() {
        return MAXUPRC;
    }

    private static final int NCARGS = (int) 1048576L;
    /**
     * {@snippet lang=c :
     * #define NCARGS 1048576
     * }
     */
    public static int NCARGS() {
        return NCARGS;
    }

    private static final int NGROUPS = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define NGROUPS 16
     * }
     */
    public static int NGROUPS() {
        return NGROUPS;
    }

    private static final long __DARWIN_ALIGNBYTES = 7L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ALIGNBYTES 7
     * }
     */
    public static long __DARWIN_ALIGNBYTES() {
        return __DARWIN_ALIGNBYTES;
    }

    private static final long __DARWIN_ALIGNBYTES32 = 3L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ALIGNBYTES32 3
     * }
     */
    public static long __DARWIN_ALIGNBYTES32() {
        return __DARWIN_ALIGNBYTES32;
    }

    private static final long ALIGNBYTES = 7L;
    /**
     * {@snippet lang=c :
     * #define ALIGNBYTES 7
     * }
     */
    public static long ALIGNBYTES() {
        return ALIGNBYTES;
    }

    private static final int PGOFSET = (int) 4095L;
    /**
     * {@snippet lang=c :
     * #define PGOFSET 4095
     * }
     */
    public static int PGOFSET() {
        return PGOFSET;
    }

    private static final int MAXPHYS = (int) 65536L;
    /**
     * {@snippet lang=c :
     * #define MAXPHYS 65536
     * }
     */
    public static int MAXPHYS() {
        return MAXPHYS;
    }

    private static final int MSIZE = (int) 256L;
    /**
     * {@snippet lang=c :
     * #define MSIZE 256
     * }
     */
    public static int MSIZE() {
        return MSIZE;
    }

    private static final int MCLBYTES = (int) 2048L;
    /**
     * {@snippet lang=c :
     * #define MCLBYTES 2048
     * }
     */
    public static int MCLBYTES() {
        return MCLBYTES;
    }

    private static final int MBIGCLBYTES = (int) 4096L;
    /**
     * {@snippet lang=c :
     * #define MBIGCLBYTES 4096
     * }
     */
    public static int MBIGCLBYTES() {
        return MBIGCLBYTES;
    }

    private static final int M16KCLBYTES = (int) 16384L;
    /**
     * {@snippet lang=c :
     * #define M16KCLBYTES 16384
     * }
     */
    public static int M16KCLBYTES() {
        return M16KCLBYTES;
    }

    private static final int MCLOFSET = (int) 2047L;
    /**
     * {@snippet lang=c :
     * #define MCLOFSET 2047
     * }
     */
    public static int MCLOFSET() {
        return MCLOFSET;
    }

    private static final int CLK_TCK = (int) 100L;
    /**
     * {@snippet lang=c :
     * #define CLK_TCK 100
     * }
     */
    public static int CLK_TCK() {
        return CLK_TCK;
    }

    private static final int SCHAR_MIN = (int) -128L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MIN -128
     * }
     */
    public static int SCHAR_MIN() {
        return SCHAR_MIN;
    }

    private static final int CHAR_MIN = (int) -128L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MIN -128
     * }
     */
    public static int CHAR_MIN() {
        return CHAR_MIN;
    }

    private static final int SHRT_MIN = (int) -32768L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MIN -32768
     * }
     */
    public static int SHRT_MIN() {
        return SHRT_MIN;
    }

    private static final int UINT_MAX = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_MAX 4294967295
     * }
     */
    public static int UINT_MAX() {
        return UINT_MAX;
    }

    private static final int INT_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_MIN -2147483648
     * }
     */
    public static int INT_MIN() {
        return INT_MIN;
    }

    private static final long ULONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_MAX -1
     * }
     */
    public static long ULONG_MAX() {
        return ULONG_MAX;
    }

    private static final long LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_MAX() {
        return LONG_MAX;
    }

    private static final long LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_MIN() {
        return LONG_MIN;
    }

    private static final long ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULLONG_MAX -1
     * }
     */
    public static long ULLONG_MAX() {
        return ULLONG_MAX;
    }

    private static final long LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MAX 9223372036854775807
     * }
     */
    public static long LLONG_MAX() {
        return LLONG_MAX;
    }

    private static final long LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MIN -9223372036854775808
     * }
     */
    public static long LLONG_MIN() {
        return LLONG_MIN;
    }

    private static final long SSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define SSIZE_MAX 9223372036854775807
     * }
     */
    public static long SSIZE_MAX() {
        return SSIZE_MAX;
    }

    private static final long SIZE_T_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_T_MAX -1
     * }
     */
    public static long SIZE_T_MAX() {
        return SIZE_T_MAX;
    }

    private static final long UQUAD_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UQUAD_MAX -1
     * }
     */
    public static long UQUAD_MAX() {
        return UQUAD_MAX;
    }

    private static final long QUAD_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define QUAD_MAX 9223372036854775807
     * }
     */
    public static long QUAD_MAX() {
        return QUAD_MAX;
    }

    private static final long QUAD_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define QUAD_MIN -9223372036854775808
     * }
     */
    public static long QUAD_MIN() {
        return QUAD_MIN;
    }

    private static final int _POSIX_RE_DUP_MAX = (int) 255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX_RE_DUP_MAX() {
        return _POSIX_RE_DUP_MAX;
    }

    private static final long OFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define OFF_MIN -9223372036854775808
     * }
     */
    public static long OFF_MIN() {
        return OFF_MIN;
    }

    private static final long OFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define OFF_MAX 9223372036854775807
     * }
     */
    public static long OFF_MAX() {
        return OFF_MAX;
    }

    private static final int NSIG = (int) 32L;
    /**
     * {@snippet lang=c :
     * #define NSIG 32
     * }
     */
    public static int NSIG() {
        return NSIG;
    }

    private static final int SIGIOT = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define SIGIOT 6
     * }
     */
    public static int SIGIOT() {
        return SIGIOT;
    }

    private static final MemorySegment SIG_DFL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define SIG_DFL (void*) 0
     * }
     */
    public static MemorySegment SIG_DFL() {
        return SIG_DFL;
    }

    private static final MemorySegment SIG_IGN = MemorySegment.ofAddress(1L);
    /**
     * {@snippet lang=c :
     * #define SIG_IGN (void*) 1
     * }
     */
    public static MemorySegment SIG_IGN() {
        return SIG_IGN;
    }

    private static final MemorySegment SIG_HOLD = MemorySegment.ofAddress(5L);
    /**
     * {@snippet lang=c :
     * #define SIG_HOLD (void*) 5
     * }
     */
    public static MemorySegment SIG_HOLD() {
        return SIG_HOLD;
    }

    private static final MemorySegment SIG_ERR = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define SIG_ERR (void*) -1
     * }
     */
    public static MemorySegment SIG_ERR() {
        return SIG_ERR;
    }

    private static final int SA_USERSPACE_MASK = (int) 127L;
    /**
     * {@snippet lang=c :
     * #define SA_USERSPACE_MASK 127
     * }
     */
    public static int SA_USERSPACE_MASK() {
        return SA_USERSPACE_MASK;
    }

    private static final int SV_ONSTACK = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define SV_ONSTACK 1
     * }
     */
    public static int SV_ONSTACK() {
        return SV_ONSTACK;
    }

    private static final int SV_INTERRUPT = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define SV_INTERRUPT 2
     * }
     */
    public static int SV_INTERRUPT() {
        return SV_INTERRUPT;
    }

    private static final int SV_RESETHAND = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define SV_RESETHAND 4
     * }
     */
    public static int SV_RESETHAND() {
        return SV_RESETHAND;
    }

    private static final int SV_NODEFER = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define SV_NODEFER 16
     * }
     */
    public static int SV_NODEFER() {
        return SV_NODEFER;
    }

    private static final int SV_NOCLDSTOP = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define SV_NOCLDSTOP 8
     * }
     */
    public static int SV_NOCLDSTOP() {
        return SV_NOCLDSTOP;
    }

    private static final int SV_SIGINFO = (int) 64L;
    /**
     * {@snippet lang=c :
     * #define SV_SIGINFO 64
     * }
     */
    public static int SV_SIGINFO() {
        return SV_SIGINFO;
    }

    private static final MemorySegment BADSIG = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define BADSIG (void*) -1
     * }
     */
    public static MemorySegment BADSIG() {
        return BADSIG;
    }

    private static final long NBPW = 4L;
    /**
     * {@snippet lang=c :
     * #define NBPW 4
     * }
     */
    public static long NBPW() {
        return NBPW;
    }

    private static final int NODEV = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define NODEV -1
     * }
     */
    public static int NODEV() {
        return NODEV;
    }

    private static final int CLBYTES = (int) 4096L;
    /**
     * {@snippet lang=c :
     * #define CLBYTES 4096
     * }
     */
    public static int CLBYTES() {
        return CLBYTES;
    }

    private static final int CLOFSET = (int) 4095L;
    /**
     * {@snippet lang=c :
     * #define CLOFSET 4095
     * }
     */
    public static int CLOFSET() {
        return CLOFSET;
    }

    private static final int CLOFF = (int) 4095L;
    /**
     * {@snippet lang=c :
     * #define CLOFF 4095
     * }
     */
    public static int CLOFF() {
        return CLOFF;
    }

    private static final int CLSHIFT = (int) 12L;
    /**
     * {@snippet lang=c :
     * #define CLSHIFT 12
     * }
     */
    public static int CLSHIFT() {
        return CLSHIFT;
    }

    private static final int CBQSIZE = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define CBQSIZE 8
     * }
     */
    public static int CBQSIZE() {
        return CBQSIZE;
    }

    private static final long CBSIZE = 48L;
    /**
     * {@snippet lang=c :
     * #define CBSIZE 48
     * }
     */
    public static long CBSIZE() {
        return CBSIZE;
    }

    private static final int CROUND = (int) 63L;
    /**
     * {@snippet lang=c :
     * #define CROUND 63
     * }
     */
    public static int CROUND() {
        return CROUND;
    }

    private static final int MAXBSIZE = (int) 1048576L;
    /**
     * {@snippet lang=c :
     * #define MAXBSIZE 1048576
     * }
     */
    public static int MAXBSIZE() {
        return MAXBSIZE;
    }

    private static final int MAXPHYSIO = (int) 65536L;
    /**
     * {@snippet lang=c :
     * #define MAXPHYSIO 65536
     * }
     */
    public static int MAXPHYSIO() {
        return MAXPHYSIO;
    }

    private static final int MAXPHYSIO_WIRED = (int) 16777216L;
    /**
     * {@snippet lang=c :
     * #define MAXPHYSIO_WIRED 16777216
     * }
     */
    public static int MAXPHYSIO_WIRED() {
        return MAXPHYSIO_WIRED;
    }

    private static final int MAXPATHLEN = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define MAXPATHLEN 1024
     * }
     */
    public static int MAXPATHLEN() {
        return MAXPATHLEN;
    }

    private static final int FSCALE = (int) 2048L;
    /**
     * {@snippet lang=c :
     * #define FSCALE 2048
     * }
     */
    public static int FSCALE() {
        return FSCALE;
    }

    private static final int S_ISTXT = (int) 512L;
    /**
     * {@snippet lang=c :
     * #define S_ISTXT 512
     * }
     */
    public static int S_ISTXT() {
        return S_ISTXT;
    }

    private static final int S_IREAD = (int) 256L;
    /**
     * {@snippet lang=c :
     * #define S_IREAD 256
     * }
     */
    public static int S_IREAD() {
        return S_IREAD;
    }

    private static final int S_IWRITE = (int) 128L;
    /**
     * {@snippet lang=c :
     * #define S_IWRITE 128
     * }
     */
    public static int S_IWRITE() {
        return S_IWRITE;
    }

    private static final int S_IEXEC = (int) 64L;
    /**
     * {@snippet lang=c :
     * #define S_IEXEC 64
     * }
     */
    public static int S_IEXEC() {
        return S_IEXEC;
    }

    private static final int ACCESSPERMS = (int) 511L;
    /**
     * {@snippet lang=c :
     * #define ACCESSPERMS 511
     * }
     */
    public static int ACCESSPERMS() {
        return ACCESSPERMS;
    }

    private static final int ALLPERMS = (int) 4095L;
    /**
     * {@snippet lang=c :
     * #define ALLPERMS 4095
     * }
     */
    public static int ALLPERMS() {
        return ALLPERMS;
    }

    private static final int DEFFILEMODE = (int) 438L;
    /**
     * {@snippet lang=c :
     * #define DEFFILEMODE 438
     * }
     */
    public static int DEFFILEMODE() {
        return DEFFILEMODE;
    }

    private static final int SF_SYNTHETIC = (int) 3221225472L;
    /**
     * {@snippet lang=c :
     * #define SF_SYNTHETIC 3221225472
     * }
     */
    public static int SF_SYNTHETIC() {
        return SF_SYNTHETIC;
    }

    private static final int UTIME_NOW = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define UTIME_NOW -1
     * }
     */
    public static int UTIME_NOW() {
        return UTIME_NOW;
    }

    private static final int UTIME_OMIT = (int) -2L;
    /**
     * {@snippet lang=c :
     * #define UTIME_OMIT -2
     * }
     */
    public static int UTIME_OMIT() {
        return UTIME_OMIT;
    }

    private static final int AUDIT_RECORD_MAGIC = (int) 2190085915L;
    /**
     * {@snippet lang=c :
     * #define AUDIT_RECORD_MAGIC 2190085915
     * }
     */
    public static int AUDIT_RECORD_MAGIC() {
        return AUDIT_RECORD_MAGIC;
    }

    private static final int MAXAUDITDATA = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define MAXAUDITDATA 32767
     * }
     */
    public static int MAXAUDITDATA() {
        return MAXAUDITDATA;
    }

    private static final int MAX_AUDIT_RECORD_SIZE = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define MAX_AUDIT_RECORD_SIZE 32767
     * }
     */
    public static int MAX_AUDIT_RECORD_SIZE() {
        return MAX_AUDIT_RECORD_SIZE;
    }

    private static final int MIN_AUDIT_FILE_SIZE = (int) 524288L;
    /**
     * {@snippet lang=c :
     * #define MIN_AUDIT_FILE_SIZE 524288
     * }
     */
    public static int MIN_AUDIT_FILE_SIZE() {
        return MIN_AUDIT_FILE_SIZE;
    }
    /**
     * {@snippet lang=c :
     * #define AUDITDEV_FILENAME "audit"
     * }
     */
    public static MemorySegment AUDITDEV_FILENAME() {
        class Holder {
            static final MemorySegment AUDITDEV_FILENAME = libproc_h.LIBRARY_ARENA.allocateFrom("audit");
        }
        return Holder.AUDITDEV_FILENAME;
    }

    private static final int AU_DEFAUDITID = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define AU_DEFAUDITID 4294967295
     * }
     */
    public static int AU_DEFAUDITID() {
        return AU_DEFAUDITID;
    }

    private static final int AU_ASSIGN_ASID = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define AU_ASSIGN_ASID -1
     * }
     */
    public static int AU_ASSIGN_ASID() {
        return AU_ASSIGN_ASID;
    }

    private static final byte AT_IPC_MSG = (byte) 1L;
    /**
     * {@snippet lang=c :
     * #define AT_IPC_MSG 1
     * }
     */
    public static byte AT_IPC_MSG() {
        return AT_IPC_MSG;
    }

    private static final byte AT_IPC_SEM = (byte) 2L;
    /**
     * {@snippet lang=c :
     * #define AT_IPC_SEM 2
     * }
     */
    public static byte AT_IPC_SEM() {
        return AT_IPC_SEM;
    }

    private static final byte AT_IPC_SHM = (byte) 3L;
    /**
     * {@snippet lang=c :
     * #define AT_IPC_SHM 3
     * }
     */
    public static byte AT_IPC_SHM() {
        return AT_IPC_SHM;
    }

    private static final int AUC_DISABLED = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define AUC_DISABLED -1
     * }
     */
    public static int AUC_DISABLED() {
        return AUC_DISABLED;
    }

    private static final int AQ_BUFSZ = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define AQ_BUFSZ 32767
     * }
     */
    public static int AQ_BUFSZ() {
        return AQ_BUFSZ;
    }

    private static final byte AUDIT_CTLMODE_NORMAL = (byte) 1L;
    /**
     * {@snippet lang=c :
     * #define AUDIT_CTLMODE_NORMAL 1
     * }
     */
    public static byte AUDIT_CTLMODE_NORMAL() {
        return AUDIT_CTLMODE_NORMAL;
    }

    private static final byte AUDIT_CTLMODE_EXTERNAL = (byte) 2L;
    /**
     * {@snippet lang=c :
     * #define AUDIT_CTLMODE_EXTERNAL 2
     * }
     */
    public static byte AUDIT_CTLMODE_EXTERNAL() {
        return AUDIT_CTLMODE_EXTERNAL;
    }

    private static final byte AUDIT_EXPIRE_OP_AND = (byte) 0L;
    /**
     * {@snippet lang=c :
     * #define AUDIT_EXPIRE_OP_AND 0
     * }
     */
    public static byte AUDIT_EXPIRE_OP_AND() {
        return AUDIT_EXPIRE_OP_AND;
    }

    private static final byte AUDIT_EXPIRE_OP_OR = (byte) 1L;
    /**
     * {@snippet lang=c :
     * #define AUDIT_EXPIRE_OP_OR 1
     * }
     */
    public static byte AUDIT_EXPIRE_OP_OR() {
        return AUDIT_EXPIRE_OP_OR;
    }

    private static final int MACH_PORT_DEAD = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_DEAD 4294967295
     * }
     */
    public static int MACH_PORT_DEAD() {
        return MACH_PORT_DEAD;
    }

    private static final int MACH_PORT_RIGHT_SEND = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_SEND 0
     * }
     */
    public static int MACH_PORT_RIGHT_SEND() {
        return MACH_PORT_RIGHT_SEND;
    }

    private static final int MACH_PORT_RIGHT_RECEIVE = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_RECEIVE 1
     * }
     */
    public static int MACH_PORT_RIGHT_RECEIVE() {
        return MACH_PORT_RIGHT_RECEIVE;
    }

    private static final int MACH_PORT_RIGHT_SEND_ONCE = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_SEND_ONCE 2
     * }
     */
    public static int MACH_PORT_RIGHT_SEND_ONCE() {
        return MACH_PORT_RIGHT_SEND_ONCE;
    }

    private static final int MACH_PORT_RIGHT_PORT_SET = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_PORT_SET 3
     * }
     */
    public static int MACH_PORT_RIGHT_PORT_SET() {
        return MACH_PORT_RIGHT_PORT_SET;
    }

    private static final int MACH_PORT_RIGHT_DEAD_NAME = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_DEAD_NAME 4
     * }
     */
    public static int MACH_PORT_RIGHT_DEAD_NAME() {
        return MACH_PORT_RIGHT_DEAD_NAME;
    }

    private static final int MACH_PORT_RIGHT_LABELH = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_LABELH 5
     * }
     */
    public static int MACH_PORT_RIGHT_LABELH() {
        return MACH_PORT_RIGHT_LABELH;
    }

    private static final int MACH_PORT_RIGHT_NUMBER = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_NUMBER 6
     * }
     */
    public static int MACH_PORT_RIGHT_NUMBER() {
        return MACH_PORT_RIGHT_NUMBER;
    }

    private static final int MACH_PORT_TYPE_NONE = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_NONE 0
     * }
     */
    public static int MACH_PORT_TYPE_NONE() {
        return MACH_PORT_TYPE_NONE;
    }

    private static final int MACH_PORT_TYPE_SEND = (int) 65536L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND 65536
     * }
     */
    public static int MACH_PORT_TYPE_SEND() {
        return MACH_PORT_TYPE_SEND;
    }

    private static final int MACH_PORT_TYPE_RECEIVE = (int) 131072L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_RECEIVE 131072
     * }
     */
    public static int MACH_PORT_TYPE_RECEIVE() {
        return MACH_PORT_TYPE_RECEIVE;
    }

    private static final int MACH_PORT_TYPE_SEND_ONCE = (int) 262144L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND_ONCE 262144
     * }
     */
    public static int MACH_PORT_TYPE_SEND_ONCE() {
        return MACH_PORT_TYPE_SEND_ONCE;
    }

    private static final int MACH_PORT_TYPE_PORT_SET = (int) 524288L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_PORT_SET 524288
     * }
     */
    public static int MACH_PORT_TYPE_PORT_SET() {
        return MACH_PORT_TYPE_PORT_SET;
    }

    private static final int MACH_PORT_TYPE_DEAD_NAME = (int) 1048576L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_DEAD_NAME 1048576
     * }
     */
    public static int MACH_PORT_TYPE_DEAD_NAME() {
        return MACH_PORT_TYPE_DEAD_NAME;
    }

    private static final int MACH_PORT_TYPE_LABELH = (int) 2097152L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_LABELH 2097152
     * }
     */
    public static int MACH_PORT_TYPE_LABELH() {
        return MACH_PORT_TYPE_LABELH;
    }

    private static final int MACH_PORT_TYPE_SEND_RECEIVE = (int) 196608L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND_RECEIVE 196608
     * }
     */
    public static int MACH_PORT_TYPE_SEND_RECEIVE() {
        return MACH_PORT_TYPE_SEND_RECEIVE;
    }

    private static final int MACH_PORT_TYPE_SEND_RIGHTS = (int) 327680L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND_RIGHTS 327680
     * }
     */
    public static int MACH_PORT_TYPE_SEND_RIGHTS() {
        return MACH_PORT_TYPE_SEND_RIGHTS;
    }

    private static final int MACH_PORT_TYPE_PORT_RIGHTS = (int) 458752L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_PORT_RIGHTS 458752
     * }
     */
    public static int MACH_PORT_TYPE_PORT_RIGHTS() {
        return MACH_PORT_TYPE_PORT_RIGHTS;
    }

    private static final int MACH_PORT_TYPE_PORT_OR_DEAD = (int) 1507328L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_PORT_OR_DEAD 1507328
     * }
     */
    public static int MACH_PORT_TYPE_PORT_OR_DEAD() {
        return MACH_PORT_TYPE_PORT_OR_DEAD;
    }

    private static final int MACH_PORT_TYPE_ALL_RIGHTS = (int) 2031616L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_ALL_RIGHTS 2031616
     * }
     */
    public static int MACH_PORT_TYPE_ALL_RIGHTS() {
        return MACH_PORT_TYPE_ALL_RIGHTS;
    }

    private static final int MACH_PORT_TYPE_DNREQUEST = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_DNREQUEST 2147483648
     * }
     */
    public static int MACH_PORT_TYPE_DNREQUEST() {
        return MACH_PORT_TYPE_DNREQUEST;
    }

    private static final int MACH_PORT_QLIMIT_ZERO = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_ZERO 0
     * }
     */
    public static int MACH_PORT_QLIMIT_ZERO() {
        return MACH_PORT_QLIMIT_ZERO;
    }

    private static final int MACH_PORT_QLIMIT_BASIC = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_BASIC 5
     * }
     */
    public static int MACH_PORT_QLIMIT_BASIC() {
        return MACH_PORT_QLIMIT_BASIC;
    }

    private static final int MACH_PORT_QLIMIT_SMALL = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_SMALL 16
     * }
     */
    public static int MACH_PORT_QLIMIT_SMALL() {
        return MACH_PORT_QLIMIT_SMALL;
    }

    private static final int MACH_PORT_QLIMIT_LARGE = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_LARGE 1024
     * }
     */
    public static int MACH_PORT_QLIMIT_LARGE() {
        return MACH_PORT_QLIMIT_LARGE;
    }

    private static final int MACH_PORT_QLIMIT_KERNEL = (int) 65534L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_KERNEL 65534
     * }
     */
    public static int MACH_PORT_QLIMIT_KERNEL() {
        return MACH_PORT_QLIMIT_KERNEL;
    }

    private static final int MACH_PORT_QLIMIT_MIN = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_MIN 0
     * }
     */
    public static int MACH_PORT_QLIMIT_MIN() {
        return MACH_PORT_QLIMIT_MIN;
    }

    private static final int MACH_PORT_QLIMIT_DEFAULT = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_DEFAULT 5
     * }
     */
    public static int MACH_PORT_QLIMIT_DEFAULT() {
        return MACH_PORT_QLIMIT_DEFAULT;
    }

    private static final int MACH_PORT_QLIMIT_MAX = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_MAX 1024
     * }
     */
    public static int MACH_PORT_QLIMIT_MAX() {
        return MACH_PORT_QLIMIT_MAX;
    }

    private static final int MACH_PORT_LIMITS_INFO_COUNT = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_LIMITS_INFO_COUNT 1
     * }
     */
    public static int MACH_PORT_LIMITS_INFO_COUNT() {
        return MACH_PORT_LIMITS_INFO_COUNT;
    }

    private static final int MACH_PORT_RECEIVE_STATUS_COUNT = (int) 10L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RECEIVE_STATUS_COUNT 10
     * }
     */
    public static int MACH_PORT_RECEIVE_STATUS_COUNT() {
        return MACH_PORT_RECEIVE_STATUS_COUNT;
    }

    private static final int MACH_PORT_INFO_EXT_COUNT = (int) 17L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_INFO_EXT_COUNT 17
     * }
     */
    public static int MACH_PORT_INFO_EXT_COUNT() {
        return MACH_PORT_INFO_EXT_COUNT;
    }

    private static final int MACH_PORT_GUARD_INFO_COUNT = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_GUARD_INFO_COUNT 2
     * }
     */
    public static int MACH_PORT_GUARD_INFO_COUNT() {
        return MACH_PORT_GUARD_INFO_COUNT;
    }

    private static final byte MACH_SERVICE_PORT_INFO_COUNT = (byte) 0L;
    /**
     * {@snippet lang=c :
     * #define MACH_SERVICE_PORT_INFO_COUNT 0
     * }
     */
    public static byte MACH_SERVICE_PORT_INFO_COUNT() {
        return MACH_SERVICE_PORT_INFO_COUNT;
    }

    private static final int MAX_FATAL_kGUARD_EXC_CODE = (int) 128L;
    /**
     * {@snippet lang=c :
     * #define MAX_FATAL_kGUARD_EXC_CODE 128
     * }
     */
    public static int MAX_FATAL_kGUARD_EXC_CODE() {
        return MAX_FATAL_kGUARD_EXC_CODE;
    }

    private static final long MPG_FLAGS_NONE = 0L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_NONE 0
     * }
     */
    public static long MPG_FLAGS_NONE() {
        return MPG_FLAGS_NONE;
    }

    private static final int MAX_OPTIONAL_kGUARD_EXC_CODE = (int) 524288L;
    /**
     * {@snippet lang=c :
     * #define MAX_OPTIONAL_kGUARD_EXC_CODE 524288
     * }
     */
    public static int MAX_OPTIONAL_kGUARD_EXC_CODE() {
        return MAX_OPTIONAL_kGUARD_EXC_CODE;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP = 72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP 72057594037927936
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP() {
        return MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT = 144115188075855872L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT 144115188075855872
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT() {
        return MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER = 288230376151711744L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER 288230376151711744
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER() {
        return MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR = 576460752303423488L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR 576460752303423488
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR() {
        return MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA = 1152921504606846976L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA 1152921504606846976
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA() {
        return MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_MASK = -72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_MASK -72057594037927936
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_MASK() {
        return MPG_FLAGS_STRICT_REPLY_MASK;
    }

    private static final long MPG_FLAGS_MOD_REFS_PINNED_DEALLOC = 72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_MOD_REFS_PINNED_DEALLOC 72057594037927936
     * }
     */
    public static long MPG_FLAGS_MOD_REFS_PINNED_DEALLOC() {
        return MPG_FLAGS_MOD_REFS_PINNED_DEALLOC;
    }

    private static final long MPG_FLAGS_MOD_REFS_PINNED_DESTROY = 144115188075855872L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_MOD_REFS_PINNED_DESTROY 144115188075855872
     * }
     */
    public static long MPG_FLAGS_MOD_REFS_PINNED_DESTROY() {
        return MPG_FLAGS_MOD_REFS_PINNED_DESTROY;
    }

    private static final long MPG_FLAGS_MOD_REFS_PINNED_COPYIN = 288230376151711744L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_MOD_REFS_PINNED_COPYIN 288230376151711744
     * }
     */
    public static long MPG_FLAGS_MOD_REFS_PINNED_COPYIN() {
        return MPG_FLAGS_MOD_REFS_PINNED_COPYIN;
    }

    private static final long MPG_FLAGS_IMMOVABLE_PINNED = 72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_IMMOVABLE_PINNED 72057594037927936
     * }
     */
    public static long MPG_FLAGS_IMMOVABLE_PINNED() {
        return MPG_FLAGS_IMMOVABLE_PINNED;
    }

    private static final MemorySegment NOCRED = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NOCRED (void*) 0
     * }
     */
    public static MemorySegment NOCRED() {
        return NOCRED;
    }

    private static final MemorySegment FSCRED = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define FSCRED (void*) -1
     * }
     */
    public static MemorySegment FSCRED() {
        return FSCRED;
    }

    private static final int __DARWIN_WCHAR_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MAX 2147483647
     * }
     */
    public static int __DARWIN_WCHAR_MAX() {
        return __DARWIN_WCHAR_MAX;
    }

    private static final int __DARWIN_WCHAR_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MIN -2147483648
     * }
     */
    public static int __DARWIN_WCHAR_MIN() {
        return __DARWIN_WCHAR_MIN;
    }

    private static final int __DARWIN_WEOF = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WEOF -1
     * }
     */
    public static int __DARWIN_WEOF() {
        return __DARWIN_WEOF;
    }

    private static final long CLOCKS_PER_SEC = 1000000L;
    /**
     * {@snippet lang=c :
     * #define CLOCKS_PER_SEC 1000000
     * }
     */
    public static long CLOCKS_PER_SEC() {
        return CLOCKS_PER_SEC;
    }

    private static final int CLOCK_REALTIME = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME 0
     * }
     */
    public static int CLOCK_REALTIME() {
        return CLOCK_REALTIME;
    }

    private static final int CLOCK_MONOTONIC = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC 6
     * }
     */
    public static int CLOCK_MONOTONIC() {
        return CLOCK_MONOTONIC;
    }

    private static final int CLOCK_MONOTONIC_RAW = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_RAW 4
     * }
     */
    public static int CLOCK_MONOTONIC_RAW() {
        return CLOCK_MONOTONIC_RAW;
    }

    private static final int CLOCK_MONOTONIC_RAW_APPROX = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_RAW_APPROX 5
     * }
     */
    public static int CLOCK_MONOTONIC_RAW_APPROX() {
        return CLOCK_MONOTONIC_RAW_APPROX;
    }

    private static final int CLOCK_UPTIME_RAW = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_UPTIME_RAW 8
     * }
     */
    public static int CLOCK_UPTIME_RAW() {
        return CLOCK_UPTIME_RAW;
    }

    private static final int CLOCK_UPTIME_RAW_APPROX = (int) 9L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_UPTIME_RAW_APPROX 9
     * }
     */
    public static int CLOCK_UPTIME_RAW_APPROX() {
        return CLOCK_UPTIME_RAW_APPROX;
    }

    private static final int CLOCK_PROCESS_CPUTIME_ID = (int) 12L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_PROCESS_CPUTIME_ID 12
     * }
     */
    public static int CLOCK_PROCESS_CPUTIME_ID() {
        return CLOCK_PROCESS_CPUTIME_ID;
    }

    private static final int CLOCK_THREAD_CPUTIME_ID = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_THREAD_CPUTIME_ID 16
     * }
     */
    public static int CLOCK_THREAD_CPUTIME_ID() {
        return CLOCK_THREAD_CPUTIME_ID;
    }

    private static final int ATTR_CMN_RETURNED_ATTRS = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define ATTR_CMN_RETURNED_ATTRS 2147483648
     * }
     */
    public static int ATTR_CMN_RETURNED_ATTRS() {
        return ATTR_CMN_RETURNED_ATTRS;
    }
}
