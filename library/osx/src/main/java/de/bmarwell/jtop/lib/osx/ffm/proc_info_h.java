/*
 * Copyright (C) 2024.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.bmarwell.jtop.lib.osx.ffm; // Generated by jextract

import static java.lang.foreign.ValueLayout.*;

import java.lang.foreign.AddressLayout;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.GroupLayout;
import java.lang.foreign.Linker;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.SequenceLayout;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;

public class proc_info_h extends proc_info_h_1 {

    proc_info_h() {
        // Should not be called directly
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = proc_info_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = proc_info_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = proc_info_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = proc_info_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = proc_info_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = proc_info_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = proc_info_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t register_t
     * }
     */
    public static final OfLong register_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = proc_info_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = proc_info_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_addr_t
     * }
     */
    public static final OfLong user_addr_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_size_t
     * }
     */
    public static final OfLong user_size_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_ssize_t
     * }
     */
    public static final OfLong user_ssize_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_long_t
     * }
     */
    public static final OfLong user_long_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_ulong_t
     * }
     */
    public static final OfLong user_ulong_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_time_t
     * }
     */
    public static final OfLong user_time_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_off_t
     * }
     */
    public static final OfLong user_off_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t syscall_arg_t
     * }
     */
    public static final OfLong syscall_arg_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = proc_info_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = proc_info_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = proc_info_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = proc_info_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = proc_info_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = proc_info_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = proc_info_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = proc_info_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = proc_info_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = proc_info_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = proc_info_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = proc_info_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_char
     * }
     */
    public static final OfByte u_char = proc_info_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_short
     * }
     */
    public static final OfShort u_short = proc_info_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int
     * }
     */
    public static final OfInt u_int = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long u_long
     * }
     */
    public static final OfLong u_long = proc_info_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = proc_info_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t quad_t
     * }
     */
    public static final OfLong quad_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef quad_t *qaddr_t
     * }
     */
    public static final AddressLayout qaddr_t = proc_info_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef char *caddr_t
     * }
     */
    public static final AddressLayout caddr_t = proc_info_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int32_t daddr_t
     * }
     */
    public static final OfInt daddr_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_dev_t dev_t
     * }
     */
    public static final OfInt dev_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fixpt_t
     * }
     */
    public static final OfInt fixpt_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blksize_t blksize_t
     * }
     */
    public static final OfInt blksize_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_gid_t gid_t
     * }
     */
    public static final OfInt gid_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t in_addr_t
     * }
     */
    public static final OfInt in_addr_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t in_port_t
     * }
     */
    public static final OfShort in_port_t = proc_info_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino_t ino_t
     * }
     */
    public static final OfLong ino_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t ino64_t
     * }
     */
    public static final OfLong ino64_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t key_t
     * }
     */
    public static final OfInt key_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mode_t mode_t
     * }
     */
    public static final OfShort mode_t = proc_info_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t nlink_t
     * }
     */
    public static final OfShort nlink_t = proc_info_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_id_t id_t
     * }
     */
    public static final OfInt id_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pid_t pid_t
     * }
     */
    public static final OfInt pid_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t off_t
     * }
     */
    public static final OfLong off_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int32_t segsz_t
     * }
     */
    public static final OfInt segsz_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t swblk_t
     * }
     */
    public static final OfInt swblk_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_uid_t uid_t
     * }
     */
    public static final OfInt uid_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_clock_t clock_t
     * }
     */
    public static final OfLong clock_t = proc_info_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t size_t
     * }
     */
    public static final OfLong size_t = proc_info_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = proc_info_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_time_t time_t
     * }
     */
    public static final OfLong time_t = proc_info_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_useconds_t useconds_t
     * }
     */
    public static final OfInt useconds_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_suseconds_t suseconds_t
     * }
     */
    public static final OfInt suseconds_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = proc_info_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = proc_info_h.C_INT;

    private static class __darwin_check_fd_set_overflow {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("__darwin_check_fd_set_overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static FunctionDescriptor __darwin_check_fd_set_overflow$descriptor() {
        return __darwin_check_fd_set_overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MethodHandle __darwin_check_fd_set_overflow$handle() {
        return __darwin_check_fd_set_overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MemorySegment __darwin_check_fd_set_overflow$address() {
        return __darwin_check_fd_set_overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static int __darwin_check_fd_set_overflow(int x0, MemorySegment x1, int x2) {
        var mh$ = __darwin_check_fd_set_overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__darwin_check_fd_set_overflow", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __int32_t fd_mask
     * }
     */
    public static final OfInt fd_mask = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_t pthread_t
     * }
     */
    public static final AddressLayout pthread_t = proc_info_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_key_t pthread_key_t
     * }
     */
    public static final OfLong pthread_key_t = proc_info_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfInt fsblkcnt_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfInt fsfilcnt_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int sig_atomic_t
     * }
     */
    public static final OfInt sig_atomic_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct __darwin_mcontext64 {
     *     struct __darwin_arm_exception_state64 __es;
     *     struct __darwin_arm_thread_state64 __ss;
     *     struct __darwin_arm_neon_state64 __ns;
     * } *mcontext_t
     * }
     */
    public static final AddressLayout mcontext_t = proc_info_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_sigset_t sigset_t
     * }
     */
    public static final OfInt sigset_t = proc_info_h.C_INT;

    private static class signal {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_POINTER, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal(int x0, MemorySegment x1) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chmod {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_SHORT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("chmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor chmod$descriptor() {
        return chmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static MethodHandle chmod$handle() {
        return chmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static MemorySegment chmod$address() {
        return chmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static int chmod(MemorySegment x0, short x1) {
        var mh$ = chmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chmod", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmod {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_SHORT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("fchmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static FunctionDescriptor fchmod$descriptor() {
        return fchmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static MethodHandle fchmod$handle() {
        return fchmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static MemorySegment fchmod$address() {
        return fchmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static int fchmod(int x0, short x1) {
        var mh$ = fchmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmod", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstat {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("fstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static FunctionDescriptor fstat$descriptor() {
        return fstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static MethodHandle fstat$handle() {
        return fstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static MemorySegment fstat$address() {
        return fstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static int fstat(int x0, MemorySegment x1) {
        var mh$ = fstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstat", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstat {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("lstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static FunctionDescriptor lstat$descriptor() {
        return lstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static MethodHandle lstat$handle() {
        return lstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static MemorySegment lstat$address() {
        return lstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static int lstat(MemorySegment x0, MemorySegment x1) {
        var mh$ = lstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstat", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdir {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_SHORT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("mkdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkdir$descriptor() {
        return mkdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static MethodHandle mkdir$handle() {
        return mkdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static MemorySegment mkdir$address() {
        return mkdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static int mkdir(MemorySegment x0, short x1) {
        var mh$ = mkdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdir", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifo {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_SHORT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("mkfifo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkfifo$descriptor() {
        return mkfifo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static MethodHandle mkfifo$handle() {
        return mkfifo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static MemorySegment mkfifo$address() {
        return mkfifo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static int mkfifo(MemorySegment x0, short x1) {
        var mh$ = mkfifo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifo", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stat {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("stat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static FunctionDescriptor stat$descriptor() {
        return stat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static MethodHandle stat$handle() {
        return stat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static MemorySegment stat$address() {
        return stat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static int stat(MemorySegment x0, MemorySegment x1) {
        var mh$ = stat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stat", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mknod {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_SHORT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("mknod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static FunctionDescriptor mknod$descriptor() {
        return mknod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static MethodHandle mknod$handle() {
        return mknod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static MemorySegment mknod$address() {
        return mknod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static int mknod(MemorySegment x0, short x1, int x2) {
        var mh$ = mknod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mknod", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_SHORT, proc_info_h.C_SHORT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("umask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static FunctionDescriptor umask$descriptor() {
        return umask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static MethodHandle umask$handle() {
        return umask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static MemorySegment umask$address() {
        return umask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static short umask(short x0) {
        var mh$ = umask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umask", x0);
            }
            return (short) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmodat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_SHORT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("fchmodat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static FunctionDescriptor fchmodat$descriptor() {
        return fchmodat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static MethodHandle fchmodat$handle() {
        return fchmodat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static MemorySegment fchmodat$address() {
        return fchmodat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static int fchmodat(int x0, MemorySegment x1, short x2, int x3) {
        var mh$ = fchmodat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmodat", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstatat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("fstatat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static FunctionDescriptor fstatat$descriptor() {
        return fstatat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static MethodHandle fstatat$handle() {
        return fstatat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static MemorySegment fstatat$address() {
        return fstatat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static int fstatat(int x0, MemorySegment x1, MemorySegment x2, int x3) {
        var mh$ = fstatat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstatat", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdirat {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_SHORT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("mkdirat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkdirat$descriptor() {
        return mkdirat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static MethodHandle mkdirat$handle() {
        return mkdirat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static MemorySegment mkdirat$address() {
        return mkdirat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static int mkdirat(int x0, MemorySegment x1, short x2) {
        var mh$ = mkdirat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdirat", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifoat {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_SHORT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("mkfifoat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkfifoat$descriptor() {
        return mkfifoat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static MethodHandle mkfifoat$handle() {
        return mkfifoat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static MemorySegment mkfifoat$address() {
        return mkfifoat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static int mkfifoat(int x0, MemorySegment x1, short x2) {
        var mh$ = mkfifoat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifoat", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mknodat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_SHORT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("mknodat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static FunctionDescriptor mknodat$descriptor() {
        return mknodat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static MethodHandle mknodat$handle() {
        return mknodat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static MemorySegment mknodat$address() {
        return mknodat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static int mknodat(int x0, MemorySegment x1, short x2, int x3) {
        var mh$ = mknodat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mknodat", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class futimens {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("futimens");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static FunctionDescriptor futimens$descriptor() {
        return futimens.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static MethodHandle futimens$handle() {
        return futimens.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static MemorySegment futimens$address() {
        return futimens.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static int futimens(int __fd, MemorySegment __times) {
        var mh$ = futimens.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("futimens", __fd, __times);
            }
            return (int) mh$.invokeExact(__fd, __times);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class utimensat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("utimensat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static FunctionDescriptor utimensat$descriptor() {
        return utimensat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static MethodHandle utimensat$handle() {
        return utimensat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static MemorySegment utimensat$address() {
        return utimensat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static int utimensat(int __fd, MemorySegment __path, MemorySegment __times, int __flag) {
        var mh$ = utimensat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("utimensat", __fd, __path, __times, __flag);
            }
            return (int) mh$.invokeExact(__fd, __path, __times, __flag);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _filesec *filesec_t
     * }
     */
    public static final AddressLayout filesec_t = proc_info_h.C_POINTER;

    private static class chflags {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("chflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static FunctionDescriptor chflags$descriptor() {
        return chflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static MethodHandle chflags$handle() {
        return chflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static MemorySegment chflags$address() {
        return chflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static int chflags(MemorySegment x0, int x1) {
        var mh$ = chflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chflags", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chmodx_np {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("chmodx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static FunctionDescriptor chmodx_np$descriptor() {
        return chmodx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static MethodHandle chmodx_np$handle() {
        return chmodx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static MemorySegment chmodx_np$address() {
        return chmodx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static int chmodx_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = chmodx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chmodx_np", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchflags {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("fchflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static FunctionDescriptor fchflags$descriptor() {
        return fchflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static MethodHandle fchflags$handle() {
        return fchflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static MemorySegment fchflags$address() {
        return fchflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static int fchflags(int x0, int x1) {
        var mh$ = fchflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchflags", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmodx_np {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("fchmodx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static FunctionDescriptor fchmodx_np$descriptor() {
        return fchmodx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static MethodHandle fchmodx_np$handle() {
        return fchmodx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static MemorySegment fchmodx_np$address() {
        return fchmodx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static int fchmodx_np(int x0, MemorySegment x1) {
        var mh$ = fchmodx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmodx_np", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstatx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("fstatx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static FunctionDescriptor fstatx_np$descriptor() {
        return fstatx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static MethodHandle fstatx_np$handle() {
        return fstatx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static MemorySegment fstatx_np$address() {
        return fstatx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static int fstatx_np(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = fstatx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstatx_np", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchflags {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("lchflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static FunctionDescriptor lchflags$descriptor() {
        return lchflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static MethodHandle lchflags$handle() {
        return lchflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static MemorySegment lchflags$address() {
        return lchflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static int lchflags(MemorySegment x0, int x1) {
        var mh$ = lchflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchflags", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchmod {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_SHORT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("lchmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor lchmod$descriptor() {
        return lchmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static MethodHandle lchmod$handle() {
        return lchmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static MemorySegment lchmod$address() {
        return lchmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static int lchmod(MemorySegment x0, short x1) {
        var mh$ = lchmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchmod", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstatx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("lstatx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static FunctionDescriptor lstatx_np$descriptor() {
        return lstatx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MethodHandle lstatx_np$handle() {
        return lstatx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MemorySegment lstatx_np$address() {
        return lstatx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static int lstatx_np(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = lstatx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstatx_np", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdirx_np {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("mkdirx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static FunctionDescriptor mkdirx_np$descriptor() {
        return mkdirx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static MethodHandle mkdirx_np$handle() {
        return mkdirx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static MemorySegment mkdirx_np$address() {
        return mkdirx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static int mkdirx_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = mkdirx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdirx_np", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifox_np {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("mkfifox_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static FunctionDescriptor mkfifox_np$descriptor() {
        return mkfifox_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static MethodHandle mkfifox_np$handle() {
        return mkfifox_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static MemorySegment mkfifox_np$address() {
        return mkfifox_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static int mkfifox_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = mkfifox_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifox_np", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class statx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("statx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static FunctionDescriptor statx_np$descriptor() {
        return statx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MethodHandle statx_np$handle() {
        return statx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MemorySegment statx_np$address() {
        return statx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static int statx_np(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = statx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("statx_np", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umaskx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("umaskx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static FunctionDescriptor umaskx_np$descriptor() {
        return umaskx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static MethodHandle umaskx_np$handle() {
        return umaskx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static MemorySegment umaskx_np$address() {
        return umaskx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static int umaskx_np(MemorySegment x0) {
        var mh$ = umaskx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umaskx_np", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uid_t au_id_t
     * }
     */
    public static final OfInt au_id_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef pid_t au_asid_t
     * }
     */
    public static final OfInt au_asid_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int16_t au_event_t
     * }
     */
    public static final OfShort au_event_t = proc_info_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef u_int16_t au_emod_t
     * }
     */
    public static final OfShort au_emod_t = proc_info_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t au_class_t
     * }
     */
    public static final OfInt au_class_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t au_asflgs_t
     * }
     */
    public static final OfLong au_asflgs_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char au_ctlmode_t
     * }
     */
    public static final OfByte au_ctlmode_t = proc_info_h.C_CHAR;

    private static final int AU_SESSION_FLAG_IS_INITIAL = (int) 1L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_IS_INITIAL = 1
     * }
     */
    public static int AU_SESSION_FLAG_IS_INITIAL() {
        return AU_SESSION_FLAG_IS_INITIAL;
    }

    private static final int AU_SESSION_FLAG_HAS_GRAPHIC_ACCESS = (int) 16L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_HAS_GRAPHIC_ACCESS = 16
     * }
     */
    public static int AU_SESSION_FLAG_HAS_GRAPHIC_ACCESS() {
        return AU_SESSION_FLAG_HAS_GRAPHIC_ACCESS;
    }

    private static final int AU_SESSION_FLAG_HAS_TTY = (int) 32L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_HAS_TTY = 32
     * }
     */
    public static int AU_SESSION_FLAG_HAS_TTY() {
        return AU_SESSION_FLAG_HAS_TTY;
    }

    private static final int AU_SESSION_FLAG_IS_REMOTE = (int) 4096L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_IS_REMOTE = 4096
     * }
     */
    public static int AU_SESSION_FLAG_IS_REMOTE() {
        return AU_SESSION_FLAG_IS_REMOTE;
    }

    private static final int AU_SESSION_FLAG_HAS_CONSOLE_ACCESS = (int) 8192L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_HAS_CONSOLE_ACCESS = 8192
     * }
     */
    public static int AU_SESSION_FLAG_HAS_CONSOLE_ACCESS() {
        return AU_SESSION_FLAG_HAS_CONSOLE_ACCESS;
    }

    private static final int AU_SESSION_FLAG_HAS_AUTHENTICATED = (int) 16384L;
    /**
     * {@snippet lang=c :
     * enum audit_session_flags.AU_SESSION_FLAG_HAS_AUTHENTICATED = 16384
     * }
     */
    public static int AU_SESSION_FLAG_HAS_AUTHENTICATED() {
        return AU_SESSION_FLAG_HAS_AUTHENTICATED;
    }

    private static class audit {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("audit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int audit(const void *, int)
     * }
     */
    public static FunctionDescriptor audit$descriptor() {
        return audit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int audit(const void *, int)
     * }
     */
    public static MethodHandle audit$handle() {
        return audit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int audit(const void *, int)
     * }
     */
    public static MemorySegment audit$address() {
        return audit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int audit(const void *, int)
     * }
     */
    public static int audit(MemorySegment x0, int x1) {
        var mh$ = audit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("audit", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class auditon {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("auditon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int auditon(int, void *, int)
     * }
     */
    public static FunctionDescriptor auditon$descriptor() {
        return auditon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int auditon(int, void *, int)
     * }
     */
    public static MethodHandle auditon$handle() {
        return auditon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int auditon(int, void *, int)
     * }
     */
    public static MemorySegment auditon$address() {
        return auditon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int auditon(int, void *, int)
     * }
     */
    public static int auditon(int x0, MemorySegment x1, int x2) {
        var mh$ = auditon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("auditon", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class auditctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("auditctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int auditctl(const char *)
     * }
     */
    public static FunctionDescriptor auditctl$descriptor() {
        return auditctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int auditctl(const char *)
     * }
     */
    public static MethodHandle auditctl$handle() {
        return auditctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int auditctl(const char *)
     * }
     */
    public static MemorySegment auditctl$address() {
        return auditctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int auditctl(const char *)
     * }
     */
    public static int auditctl(MemorySegment x0) {
        var mh$ = auditctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("auditctl", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getauid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("getauid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getauid(au_id_t *)
     * }
     */
    public static FunctionDescriptor getauid$descriptor() {
        return getauid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getauid(au_id_t *)
     * }
     */
    public static MethodHandle getauid$handle() {
        return getauid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getauid(au_id_t *)
     * }
     */
    public static MemorySegment getauid$address() {
        return getauid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getauid(au_id_t *)
     * }
     */
    public static int getauid(MemorySegment x0) {
        var mh$ = getauid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getauid", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setauid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("setauid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setauid(const au_id_t *)
     * }
     */
    public static FunctionDescriptor setauid$descriptor() {
        return setauid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setauid(const au_id_t *)
     * }
     */
    public static MethodHandle setauid$handle() {
        return setauid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setauid(const au_id_t *)
     * }
     */
    public static MemorySegment setauid$address() {
        return setauid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setauid(const au_id_t *)
     * }
     */
    public static int setauid(MemorySegment x0) {
        var mh$ = setauid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setauid", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getaudit_addr {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("getaudit_addr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getaudit_addr(struct auditinfo_addr *, int)
     * }
     */
    public static FunctionDescriptor getaudit_addr$descriptor() {
        return getaudit_addr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getaudit_addr(struct auditinfo_addr *, int)
     * }
     */
    public static MethodHandle getaudit_addr$handle() {
        return getaudit_addr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getaudit_addr(struct auditinfo_addr *, int)
     * }
     */
    public static MemorySegment getaudit_addr$address() {
        return getaudit_addr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getaudit_addr(struct auditinfo_addr *, int)
     * }
     */
    public static int getaudit_addr(MemorySegment x0, int x1) {
        var mh$ = getaudit_addr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getaudit_addr", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setaudit_addr {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("setaudit_addr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setaudit_addr(const struct auditinfo_addr *, int)
     * }
     */
    public static FunctionDescriptor setaudit_addr$descriptor() {
        return setaudit_addr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setaudit_addr(const struct auditinfo_addr *, int)
     * }
     */
    public static MethodHandle setaudit_addr$handle() {
        return setaudit_addr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setaudit_addr(const struct auditinfo_addr *, int)
     * }
     */
    public static MemorySegment setaudit_addr$address() {
        return setaudit_addr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setaudit_addr(const struct auditinfo_addr *, int)
     * }
     */
    public static int setaudit_addr(MemorySegment x0, int x1) {
        var mh$ = setaudit_addr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setaudit_addr", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getaudit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("getaudit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getaudit(struct auditinfo *)
     * }
     */
    public static FunctionDescriptor getaudit$descriptor() {
        return getaudit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getaudit(struct auditinfo *)
     * }
     */
    public static MethodHandle getaudit$handle() {
        return getaudit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getaudit(struct auditinfo *)
     * }
     */
    public static MemorySegment getaudit$address() {
        return getaudit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getaudit(struct auditinfo *)
     * }
     */
    public static int getaudit(MemorySegment x0) {
        var mh$ = getaudit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getaudit", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setaudit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("setaudit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setaudit(const struct auditinfo *)
     * }
     */
    public static FunctionDescriptor setaudit$descriptor() {
        return setaudit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setaudit(const struct auditinfo *)
     * }
     */
    public static MethodHandle setaudit$handle() {
        return setaudit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setaudit(const struct auditinfo *)
     * }
     */
    public static MemorySegment setaudit$address() {
        return setaudit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setaudit(const struct auditinfo *)
     * }
     */
    public static int setaudit(MemorySegment x0) {
        var mh$ = setaudit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setaudit", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int boolean_t
     * }
     */
    public static final OfInt boolean_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t natural_t
     * }
     */
    public static final OfInt natural_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int integer_t
     * }
     */
    public static final OfInt integer_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t vm_offset_t
     * }
     */
    public static final OfLong vm_offset_t = proc_info_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t vm_size_t
     * }
     */
    public static final OfLong vm_size_t = proc_info_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t mach_vm_address_t
     * }
     */
    public static final OfLong mach_vm_address_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t mach_vm_offset_t
     * }
     */
    public static final OfLong mach_vm_offset_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t mach_vm_size_t
     * }
     */
    public static final OfLong mach_vm_size_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_map_offset_t
     * }
     */
    public static final OfLong vm_map_offset_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_map_address_t
     * }
     */
    public static final OfLong vm_map_address_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_map_size_t
     * }
     */
    public static final OfLong vm_map_size_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_offset_t
     * }
     */
    public static final OfInt vm32_offset_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_address_t
     * }
     */
    public static final OfInt vm32_address_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_size_t
     * }
     */
    public static final OfInt vm32_size_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef vm_offset_t mach_port_context_t
     * }
     */
    public static final OfLong mach_port_context_t = proc_info_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_name_t
     * }
     */
    public static final OfInt mach_port_name_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_name_t *mach_port_name_array_t
     * }
     */
    public static final AddressLayout mach_port_name_array_t = proc_info_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_t mach_port_t
     * }
     */
    public static final OfInt mach_port_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t *mach_port_array_t
     * }
     */
    public static final AddressLayout mach_port_array_t = proc_info_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_right_t
     * }
     */
    public static final OfInt mach_port_right_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_type_t
     * }
     */
    public static final OfInt mach_port_type_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_type_t *mach_port_type_array_t
     * }
     */
    public static final AddressLayout mach_port_type_array_t = proc_info_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_urefs_t
     * }
     */
    public static final OfInt mach_port_urefs_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_port_delta_t
     * }
     */
    public static final OfInt mach_port_delta_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_seqno_t
     * }
     */
    public static final OfInt mach_port_seqno_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_mscount_t
     * }
     */
    public static final OfInt mach_port_mscount_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_msgcount_t
     * }
     */
    public static final OfInt mach_port_msgcount_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_rights_t
     * }
     */
    public static final OfInt mach_port_rights_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_port_srights_t
     * }
     */
    public static final OfInt mach_port_srights_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *mach_port_info_t
     * }
     */
    public static final AddressLayout mach_port_info_t = proc_info_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int mach_port_flavor_t
     * }
     */
    public static final OfInt mach_port_flavor_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct mach_service_port_info {
     *     char mspi_string_name[255];
     *     uint8_t mspi_domain_type;
     * } *mach_service_port_info_t
     * }
     */
    public static final AddressLayout mach_service_port_info_t = proc_info_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef mach_port_options_t *mach_port_options_ptr_t
     * }
     */
    public static final AddressLayout mach_port_options_ptr_t = proc_info_h.C_POINTER;

    private static final int kGUARD_EXC_DESTROY = (int) 1L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_DESTROY = 1
     * }
     */
    public static int kGUARD_EXC_DESTROY() {
        return kGUARD_EXC_DESTROY;
    }

    private static final int kGUARD_EXC_MOD_REFS = (int) 2L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MOD_REFS = 2
     * }
     */
    public static int kGUARD_EXC_MOD_REFS() {
        return kGUARD_EXC_MOD_REFS;
    }

    private static final int kGUARD_EXC_INVALID_OPTIONS = (int) 3L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_OPTIONS = 3
     * }
     */
    public static int kGUARD_EXC_INVALID_OPTIONS() {
        return kGUARD_EXC_INVALID_OPTIONS;
    }

    private static final int kGUARD_EXC_SET_CONTEXT = (int) 4L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SET_CONTEXT = 4
     * }
     */
    public static int kGUARD_EXC_SET_CONTEXT() {
        return kGUARD_EXC_SET_CONTEXT;
    }

    private static final int kGUARD_EXC_THREAD_SET_STATE = (int) 5L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_THREAD_SET_STATE = 5
     * }
     */
    public static int kGUARD_EXC_THREAD_SET_STATE() {
        return kGUARD_EXC_THREAD_SET_STATE;
    }

    private static final int kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE = (int) 6L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE = 6
     * }
     */
    public static int kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE() {
        return kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE;
    }

    private static final int kGUARD_EXC_UNGUARDED = (int) 8L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_UNGUARDED = 8
     * }
     */
    public static int kGUARD_EXC_UNGUARDED() {
        return kGUARD_EXC_UNGUARDED;
    }

    private static final int kGUARD_EXC_INCORRECT_GUARD = (int) 16L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INCORRECT_GUARD = 16
     * }
     */
    public static int kGUARD_EXC_INCORRECT_GUARD() {
        return kGUARD_EXC_INCORRECT_GUARD;
    }

    private static final int kGUARD_EXC_IMMOVABLE = (int) 32L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_IMMOVABLE = 32
     * }
     */
    public static int kGUARD_EXC_IMMOVABLE() {
        return kGUARD_EXC_IMMOVABLE;
    }

    private static final int kGUARD_EXC_STRICT_REPLY = (int) 64L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_STRICT_REPLY = 64
     * }
     */
    public static int kGUARD_EXC_STRICT_REPLY() {
        return kGUARD_EXC_STRICT_REPLY;
    }

    private static final int kGUARD_EXC_MSG_FILTERED = (int) 128L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MSG_FILTERED = 128
     * }
     */
    public static int kGUARD_EXC_MSG_FILTERED() {
        return kGUARD_EXC_MSG_FILTERED;
    }

    private static final int kGUARD_EXC_INVALID_RIGHT = (int) 256L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_RIGHT = 256
     * }
     */
    public static int kGUARD_EXC_INVALID_RIGHT() {
        return kGUARD_EXC_INVALID_RIGHT;
    }

    private static final int kGUARD_EXC_INVALID_NAME = (int) 512L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_NAME = 512
     * }
     */
    public static int kGUARD_EXC_INVALID_NAME() {
        return kGUARD_EXC_INVALID_NAME;
    }

    private static final int kGUARD_EXC_INVALID_VALUE = (int) 1024L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_VALUE = 1024
     * }
     */
    public static int kGUARD_EXC_INVALID_VALUE() {
        return kGUARD_EXC_INVALID_VALUE;
    }

    private static final int kGUARD_EXC_INVALID_ARGUMENT = (int) 2048L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_ARGUMENT = 2048
     * }
     */
    public static int kGUARD_EXC_INVALID_ARGUMENT() {
        return kGUARD_EXC_INVALID_ARGUMENT;
    }

    private static final int kGUARD_EXC_RIGHT_EXISTS = (int) 4096L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RIGHT_EXISTS = 4096
     * }
     */
    public static int kGUARD_EXC_RIGHT_EXISTS() {
        return kGUARD_EXC_RIGHT_EXISTS;
    }

    private static final int kGUARD_EXC_KERN_NO_SPACE = (int) 8192L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_NO_SPACE = 8192
     * }
     */
    public static int kGUARD_EXC_KERN_NO_SPACE() {
        return kGUARD_EXC_KERN_NO_SPACE;
    }

    private static final int kGUARD_EXC_KERN_FAILURE = (int) 16384L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_FAILURE = 16384
     * }
     */
    public static int kGUARD_EXC_KERN_FAILURE() {
        return kGUARD_EXC_KERN_FAILURE;
    }

    private static final int kGUARD_EXC_KERN_RESOURCE = (int) 32768L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_RESOURCE = 32768
     * }
     */
    public static int kGUARD_EXC_KERN_RESOURCE() {
        return kGUARD_EXC_KERN_RESOURCE;
    }

    private static final int kGUARD_EXC_SEND_INVALID_REPLY = (int) 65536L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_REPLY = 65536
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_REPLY() {
        return kGUARD_EXC_SEND_INVALID_REPLY;
    }

    private static final int kGUARD_EXC_SEND_INVALID_VOUCHER = (int) 131072L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_VOUCHER = 131072
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_VOUCHER() {
        return kGUARD_EXC_SEND_INVALID_VOUCHER;
    }

    private static final int kGUARD_EXC_SEND_INVALID_RIGHT = (int) 262144L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_RIGHT = 262144
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_RIGHT() {
        return kGUARD_EXC_SEND_INVALID_RIGHT;
    }

    private static final int kGUARD_EXC_RCV_INVALID_NAME = (int) 524288L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RCV_INVALID_NAME = 524288
     * }
     */
    public static int kGUARD_EXC_RCV_INVALID_NAME() {
        return kGUARD_EXC_RCV_INVALID_NAME;
    }

    private static final int kGUARD_EXC_RCV_GUARDED_DESC = (int) 1048576L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RCV_GUARDED_DESC = 1048576
     * }
     */
    public static int kGUARD_EXC_RCV_GUARDED_DESC() {
        return kGUARD_EXC_RCV_GUARDED_DESC;
    }

    private static final int kGUARD_EXC_MOD_REFS_NON_FATAL = (int) 2097152L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MOD_REFS_NON_FATAL = 2097152
     * }
     */
    public static int kGUARD_EXC_MOD_REFS_NON_FATAL() {
        return kGUARD_EXC_MOD_REFS_NON_FATAL;
    }

    private static final int kGUARD_EXC_IMMOVABLE_NON_FATAL = (int) 4194304L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_IMMOVABLE_NON_FATAL = 4194304
     * }
     */
    public static int kGUARD_EXC_IMMOVABLE_NON_FATAL() {
        return kGUARD_EXC_IMMOVABLE_NON_FATAL;
    }

    private static final int kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS = (int) 8388608L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS = 8388608
     * }
     */
    public static int kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS() {
        return kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS;
    }

    private static class audit_session_self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("audit_session_self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mach_port_name_t audit_session_self()
     * }
     */
    public static FunctionDescriptor audit_session_self$descriptor() {
        return audit_session_self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mach_port_name_t audit_session_self()
     * }
     */
    public static MethodHandle audit_session_self$handle() {
        return audit_session_self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mach_port_name_t audit_session_self()
     * }
     */
    public static MemorySegment audit_session_self$address() {
        return audit_session_self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mach_port_name_t audit_session_self()
     * }
     */
    public static int audit_session_self() {
        var mh$ = audit_session_self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("audit_session_self");
            }
            return (int) mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class audit_session_join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("audit_session_join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * au_asid_t audit_session_join(mach_port_name_t port)
     * }
     */
    public static FunctionDescriptor audit_session_join$descriptor() {
        return audit_session_join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * au_asid_t audit_session_join(mach_port_name_t port)
     * }
     */
    public static MethodHandle audit_session_join$handle() {
        return audit_session_join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * au_asid_t audit_session_join(mach_port_name_t port)
     * }
     */
    public static MemorySegment audit_session_join$address() {
        return audit_session_join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * au_asid_t audit_session_join(mach_port_name_t port)
     * }
     */
    public static int audit_session_join(int port) {
        var mh$ = audit_session_join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("audit_session_join", port);
            }
            return (int) mh$.invokeExact(port);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class audit_session_port {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("audit_session_port");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int audit_session_port(au_asid_t asid, mach_port_name_t *portname)
     * }
     */
    public static FunctionDescriptor audit_session_port$descriptor() {
        return audit_session_port.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int audit_session_port(au_asid_t asid, mach_port_name_t *portname)
     * }
     */
    public static MethodHandle audit_session_port$handle() {
        return audit_session_port.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int audit_session_port(au_asid_t asid, mach_port_name_t *portname)
     * }
     */
    public static MemorySegment audit_session_port$address() {
        return audit_session_port.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int audit_session_port(au_asid_t asid, mach_port_name_t *portname)
     * }
     */
    public static int audit_session_port(int asid, MemorySegment portname) {
        var mh$ = audit_session_port.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("audit_session_port", asid, portname);
            }
            return (int) mh$.invokeExact(asid, portname);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ucred *kauth_cred_t
     * }
     */
    public static final AddressLayout kauth_cred_t = proc_info_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct posix_cred *posix_cred_t
     * }
     */
    public static final AddressLayout posix_cred_t = proc_info_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_nl_item
     * }
     */
    public static final OfInt __darwin_nl_item = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wctrans_t
     * }
     */
    public static final OfInt __darwin_wctrans_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_wctype_t
     * }
     */
    public static final OfInt __darwin_wctype_t = proc_info_h.C_INT;

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, proc_info_h.C_POINTER);
        public static final MemorySegment SEGMENT =
                proc_info_h.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {};
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    private static class getdate_err$constants {
        public static final OfInt LAYOUT = proc_info_h.C_INT;
        public static final MemorySegment SEGMENT =
                proc_info_h.findOrThrow("getdate_err").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static OfInt getdate_err$layout() {
        return getdate_err$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static MemorySegment getdate_err$segment() {
        return getdate_err$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static int getdate_err() {
        return getdate_err$constants.SEGMENT.get(getdate_err$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static void getdate_err(int varValue) {
        getdate_err$constants.SEGMENT.set(getdate_err$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = proc_info_h.C_LONG;
        public static final MemorySegment SEGMENT =
                proc_info_h.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = proc_info_h.C_INT;
        public static final MemorySegment SEGMENT =
                proc_info_h.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class asctime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MemorySegment asctime(MemorySegment x0) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", x0);
            }
            return (MemorySegment) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_LONG);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long) mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MemorySegment ctime(MemorySegment x0) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", x0);
            }
            return (MemorySegment) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_DOUBLE, proc_info_h.C_LONG, proc_info_h.C_LONG);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static double difftime(long x0, long x1) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", x0, x1);
            }
            return (double) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdate {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("getdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static FunctionDescriptor getdate$descriptor() {
        return getdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MethodHandle getdate$handle() {
        return getdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MemorySegment getdate$address() {
        return getdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MemorySegment getdate(MemorySegment x0) {
        var mh$ = getdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdate", x0);
            }
            return (MemorySegment) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MemorySegment gmtime(MemorySegment x0) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", x0);
            }
            return (MemorySegment) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MemorySegment localtime(MemorySegment x0) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", x0);
            }
            return (MemorySegment) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_LONG, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static long mktime(MemorySegment x0) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_LONG,
                proc_info_h.C_POINTER,
                proc_info_h.C_LONG,
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static long strftime(MemorySegment x0, long x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", x0, x1, x2, x3);
            }
            return (long) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strptime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("strptime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor strptime$descriptor() {
        return strptime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle strptime$handle() {
        return strptime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment strptime$address() {
        return strptime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment strptime(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = strptime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strptime", x0, x1, x2);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_LONG, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static long time(MemorySegment x0) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid();

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix2time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_LONG, proc_info_h.C_LONG);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("posix2time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static FunctionDescriptor posix2time$descriptor() {
        return posix2time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static MethodHandle posix2time$handle() {
        return posix2time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static MemorySegment posix2time$address() {
        return posix2time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static long posix2time(long x0) {
        var mh$ = posix2time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix2time", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tzsetwall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid();

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("tzsetwall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static FunctionDescriptor tzsetwall$descriptor() {
        return tzsetwall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static MethodHandle tzsetwall$handle() {
        return tzsetwall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static MemorySegment tzsetwall$address() {
        return tzsetwall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static void tzsetwall() {
        var mh$ = tzsetwall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzsetwall");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time2posix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_LONG, proc_info_h.C_LONG);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("time2posix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static FunctionDescriptor time2posix$descriptor() {
        return time2posix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static MethodHandle time2posix$handle() {
        return time2posix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static MemorySegment time2posix$address() {
        return time2posix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static long time2posix(long x0) {
        var mh$ = time2posix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time2posix", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_LONG, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static long timelocal(MemorySegment x0) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_LONG, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static long timegm(MemorySegment x0) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", x0);
            }
            return (long) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static int nanosleep(MemorySegment __rqtp, MemorySegment __rmtp) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __rqtp, __rmtp);
            }
            return (int) mh$.invokeExact(__rqtp, __rmtp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static final int _CLOCK_REALTIME = (int) 0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_REALTIME = 0
     * }
     */
    public static int _CLOCK_REALTIME() {
        return _CLOCK_REALTIME;
    }

    private static final int _CLOCK_MONOTONIC = (int) 6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC = 6
     * }
     */
    public static int _CLOCK_MONOTONIC() {
        return _CLOCK_MONOTONIC;
    }

    private static final int _CLOCK_MONOTONIC_RAW = (int) 4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC_RAW = 4
     * }
     */
    public static int _CLOCK_MONOTONIC_RAW() {
        return _CLOCK_MONOTONIC_RAW;
    }

    private static final int _CLOCK_MONOTONIC_RAW_APPROX = (int) 5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC_RAW_APPROX = 5
     * }
     */
    public static int _CLOCK_MONOTONIC_RAW_APPROX() {
        return _CLOCK_MONOTONIC_RAW_APPROX;
    }

    private static final int _CLOCK_UPTIME_RAW = (int) 8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_UPTIME_RAW = 8
     * }
     */
    public static int _CLOCK_UPTIME_RAW() {
        return _CLOCK_UPTIME_RAW;
    }

    private static final int _CLOCK_UPTIME_RAW_APPROX = (int) 9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_UPTIME_RAW_APPROX = 9
     * }
     */
    public static int _CLOCK_UPTIME_RAW_APPROX() {
        return _CLOCK_UPTIME_RAW_APPROX;
    }

    private static final int _CLOCK_PROCESS_CPUTIME_ID = (int) 12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_PROCESS_CPUTIME_ID = 12
     * }
     */
    public static int _CLOCK_PROCESS_CPUTIME_ID() {
        return _CLOCK_PROCESS_CPUTIME_ID;
    }

    private static final int _CLOCK_THREAD_CPUTIME_ID = (int) 16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_THREAD_CPUTIME_ID = 16
     * }
     */
    public static int _CLOCK_THREAD_CPUTIME_ID() {
        return _CLOCK_THREAD_CPUTIME_ID;
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int) mh$.invokeExact(__clock_id, __res);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int) mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime_nsec_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_LONG_LONG, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("clock_gettime_nsec_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static FunctionDescriptor clock_gettime_nsec_np$descriptor() {
        return clock_gettime_nsec_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static MethodHandle clock_gettime_nsec_np$handle() {
        return clock_gettime_nsec_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static MemorySegment clock_gettime_nsec_np$address() {
        return clock_gettime_nsec_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static long clock_gettime_nsec_np(int __clock_id) {
        var mh$ = clock_gettime_nsec_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime_nsec_np", __clock_id);
            }
            return (long) mh$.invokeExact(__clock_id);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int) mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static int timespec_get(MemorySegment ts, int base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", ts, base);
            }
            return (int) mh$.invokeExact(ts, base);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class adjtime {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("adjtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static FunctionDescriptor adjtime$descriptor() {
        return adjtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static MethodHandle adjtime$handle() {
        return adjtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static MemorySegment adjtime$address() {
        return adjtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static int adjtime(MemorySegment x0, MemorySegment x1) {
        var mh$ = adjtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("adjtime", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class futimes {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("futimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static FunctionDescriptor futimes$descriptor() {
        return futimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static MethodHandle futimes$handle() {
        return futimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static MemorySegment futimes$address() {
        return futimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static int futimes(int x0, MemorySegment x1) {
        var mh$ = futimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("futimes", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lutimes {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("lutimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static FunctionDescriptor lutimes$descriptor() {
        return lutimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static MethodHandle lutimes$handle() {
        return lutimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static MemorySegment lutimes$address() {
        return lutimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static int lutimes(MemorySegment x0, MemorySegment x1) {
        var mh$ = lutimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lutimes", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class settimeofday {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("settimeofday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static FunctionDescriptor settimeofday$descriptor() {
        return settimeofday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static MethodHandle settimeofday$handle() {
        return settimeofday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static MemorySegment settimeofday$address() {
        return settimeofday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static int settimeofday(MemorySegment x0, MemorySegment x1) {
        var mh$ = settimeofday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("settimeofday", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getitimer {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("getitimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static FunctionDescriptor getitimer$descriptor() {
        return getitimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static MethodHandle getitimer$handle() {
        return getitimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static MemorySegment getitimer$address() {
        return getitimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static int getitimer(int x0, MemorySegment x1) {
        var mh$ = getitimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getitimer", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gettimeofday {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("gettimeofday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static FunctionDescriptor gettimeofday$descriptor() {
        return gettimeofday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static MethodHandle gettimeofday$handle() {
        return gettimeofday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static MemorySegment gettimeofday$address() {
        return gettimeofday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static int gettimeofday(MemorySegment x0, MemorySegment x1) {
        var mh$ = gettimeofday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gettimeofday", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static int select(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", x0, x1, x2, x3, x4);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setitimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("setitimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static FunctionDescriptor setitimer$descriptor() {
        return setitimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static MethodHandle setitimer$handle() {
        return setitimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static MemorySegment setitimer$address() {
        return setitimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static int setitimer(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = setitimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setitimer", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class utimes {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("utimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static FunctionDescriptor utimes$descriptor() {
        return utimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static MethodHandle utimes$handle() {
        return utimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static MemorySegment utimes$address() {
        return utimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static int utimes(MemorySegment x0, MemorySegment x1) {
        var mh$ = utimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("utimes", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef u_int32_t text_encoding_t
     * }
     */
    public static final OfInt text_encoding_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fsobj_type_t
     * }
     */
    public static final OfInt fsobj_type_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fsobj_tag_t
     * }
     */
    public static final OfInt fsobj_tag_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fsfile_type_t
     * }
     */
    public static final OfInt fsfile_type_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fsvolid_t
     * }
     */
    public static final OfInt fsvolid_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t attrgroup_t
     * }
     */
    public static final OfInt attrgroup_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct mount *mount_t
     * }
     */
    public static final AddressLayout mount_t = proc_info_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct vnode *vnode_t
     * }
     */
    public static final AddressLayout vnode_t = proc_info_h.C_POINTER;

    private static final int GRAFTDMG_CRYPTEX_BOOT = (int) 1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GRAFTDMG_CRYPTEX_BOOT = 1
     * }
     */
    public static int GRAFTDMG_CRYPTEX_BOOT() {
        return GRAFTDMG_CRYPTEX_BOOT;
    }

    private static final int GRAFTDMG_CRYPTEX_PREBOOT = (int) 2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GRAFTDMG_CRYPTEX_PREBOOT = 2
     * }
     */
    public static int GRAFTDMG_CRYPTEX_PREBOOT() {
        return GRAFTDMG_CRYPTEX_PREBOOT;
    }

    private static final int GRAFTDMG_CRYPTEX_DOWNLEVEL = (int) 3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GRAFTDMG_CRYPTEX_DOWNLEVEL = 3
     * }
     */
    public static int GRAFTDMG_CRYPTEX_DOWNLEVEL() {
        return GRAFTDMG_CRYPTEX_DOWNLEVEL;
    }

    private static final int GRAFTDMG_CRYPTEX_PDI_NONCE = (int) 6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GRAFTDMG_CRYPTEX_PDI_NONCE = 6
     * }
     */
    public static int GRAFTDMG_CRYPTEX_PDI_NONCE() {
        return GRAFTDMG_CRYPTEX_PDI_NONCE;
    }

    private static final int GRAFTDMG_CRYPTEX_EFFECTIVE_AP = (int) 7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GRAFTDMG_CRYPTEX_EFFECTIVE_AP = 7
     * }
     */
    public static int GRAFTDMG_CRYPTEX_EFFECTIVE_AP() {
        return GRAFTDMG_CRYPTEX_EFFECTIVE_AP;
    }

    private static final int GRAFTDMG_CRYPTEX_MAX = (int) 7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GRAFTDMG_CRYPTEX_MAX = 7
     * }
     */
    public static int GRAFTDMG_CRYPTEX_MAX() {
        return GRAFTDMG_CRYPTEX_MAX;
    }

    private static final int CRYPTEX1_AUTH_ENV_GENERIC = (int) 4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CRYPTEX1_AUTH_ENV_GENERIC = 4
     * }
     */
    public static int CRYPTEX1_AUTH_ENV_GENERIC() {
        return CRYPTEX1_AUTH_ENV_GENERIC;
    }

    private static final int CRYPTEX1_AUTH_ENV_GENERIC_SUPPLEMENTAL = (int) 5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CRYPTEX1_AUTH_ENV_GENERIC_SUPPLEMENTAL = 5
     * }
     */
    public static int CRYPTEX1_AUTH_ENV_GENERIC_SUPPLEMENTAL() {
        return CRYPTEX1_AUTH_ENV_GENERIC_SUPPLEMENTAL;
    }

    private static final int CRYPTEX_AUTH_PDI_NONCE = (int) 6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CRYPTEX_AUTH_PDI_NONCE = 6
     * }
     */
    public static int CRYPTEX_AUTH_PDI_NONCE() {
        return CRYPTEX_AUTH_PDI_NONCE;
    }

    private static final int CRYPTEX_AUTH_MAX = (int) 7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CRYPTEX_AUTH_MAX = 7
     * }
     */
    public static int CRYPTEX_AUTH_MAX() {
        return CRYPTEX_AUTH_MAX;
    }

    private static class fhopen {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("fhopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fhopen(const struct fhandle *, int)
     * }
     */
    public static FunctionDescriptor fhopen$descriptor() {
        return fhopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fhopen(const struct fhandle *, int)
     * }
     */
    public static MethodHandle fhopen$handle() {
        return fhopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fhopen(const struct fhandle *, int)
     * }
     */
    public static MemorySegment fhopen$address() {
        return fhopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fhopen(const struct fhandle *, int)
     * }
     */
    public static int fhopen(MemorySegment x0, int x1) {
        var mh$ = fhopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fhopen", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstatfs {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("fstatfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fstatfs(int, struct statfs *)
     * }
     */
    public static FunctionDescriptor fstatfs$descriptor() {
        return fstatfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fstatfs(int, struct statfs *)
     * }
     */
    public static MethodHandle fstatfs$handle() {
        return fstatfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fstatfs(int, struct statfs *)
     * }
     */
    public static MemorySegment fstatfs$address() {
        return fstatfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fstatfs(int, struct statfs *)
     * }
     */
    public static int fstatfs(int x0, MemorySegment x1) {
        var mh$ = fstatfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstatfs", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getfh {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("getfh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getfh(const char *, fhandle_t *)
     * }
     */
    public static FunctionDescriptor getfh$descriptor() {
        return getfh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getfh(const char *, fhandle_t *)
     * }
     */
    public static MethodHandle getfh$handle() {
        return getfh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getfh(const char *, fhandle_t *)
     * }
     */
    public static MemorySegment getfh$address() {
        return getfh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getfh(const char *, fhandle_t *)
     * }
     */
    public static int getfh(MemorySegment x0, MemorySegment x1) {
        var mh$ = getfh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getfh", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getfsstat {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("getfsstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getfsstat(struct statfs *, int, int)
     * }
     */
    public static FunctionDescriptor getfsstat$descriptor() {
        return getfsstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getfsstat(struct statfs *, int, int)
     * }
     */
    public static MethodHandle getfsstat$handle() {
        return getfsstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getfsstat(struct statfs *, int, int)
     * }
     */
    public static MemorySegment getfsstat$address() {
        return getfsstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getfsstat(struct statfs *, int, int)
     * }
     */
    public static int getfsstat(MemorySegment x0, int x1, int x2) {
        var mh$ = getfsstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getfsstat", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getmntinfo {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("getmntinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getmntinfo(struct statfs **, int)
     * }
     */
    public static FunctionDescriptor getmntinfo$descriptor() {
        return getmntinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getmntinfo(struct statfs **, int)
     * }
     */
    public static MethodHandle getmntinfo$handle() {
        return getmntinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getmntinfo(struct statfs **, int)
     * }
     */
    public static MemorySegment getmntinfo$address() {
        return getmntinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getmntinfo(struct statfs **, int)
     * }
     */
    public static int getmntinfo(MemorySegment x0, int x1) {
        var mh$ = getmntinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getmntinfo", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getmntinfo_r_np {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("getmntinfo_r_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getmntinfo_r_np(struct statfs **, int)
     * }
     */
    public static FunctionDescriptor getmntinfo_r_np$descriptor() {
        return getmntinfo_r_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getmntinfo_r_np(struct statfs **, int)
     * }
     */
    public static MethodHandle getmntinfo_r_np$handle() {
        return getmntinfo_r_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getmntinfo_r_np(struct statfs **, int)
     * }
     */
    public static MemorySegment getmntinfo_r_np$address() {
        return getmntinfo_r_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getmntinfo_r_np(struct statfs **, int)
     * }
     */
    public static int getmntinfo_r_np(MemorySegment x0, int x1) {
        var mh$ = getmntinfo_r_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getmntinfo_r_np", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("mount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mount(const char *, const char *, int, void *)
     * }
     */
    public static FunctionDescriptor mount$descriptor() {
        return mount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mount(const char *, const char *, int, void *)
     * }
     */
    public static MethodHandle mount$handle() {
        return mount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mount(const char *, const char *, int, void *)
     * }
     */
    public static MemorySegment mount$address() {
        return mount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mount(const char *, const char *, int, void *)
     * }
     */
    public static int mount(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = mount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mount", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("fmount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fmount(const char *, int, int, void *)
     * }
     */
    public static FunctionDescriptor fmount$descriptor() {
        return fmount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fmount(const char *, int, int, void *)
     * }
     */
    public static MethodHandle fmount$handle() {
        return fmount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fmount(const char *, int, int, void *)
     * }
     */
    public static MemorySegment fmount$address() {
        return fmount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fmount(const char *, int, int, void *)
     * }
     */
    public static int fmount(MemorySegment x0, int x1, int x2, MemorySegment x3) {
        var mh$ = fmount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmount", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class statfs {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("statfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int statfs(const char *, struct statfs *)
     * }
     */
    public static FunctionDescriptor statfs$descriptor() {
        return statfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int statfs(const char *, struct statfs *)
     * }
     */
    public static MethodHandle statfs$handle() {
        return statfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int statfs(const char *, struct statfs *)
     * }
     */
    public static MemorySegment statfs$address() {
        return statfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int statfs(const char *, struct statfs *)
     * }
     */
    public static int statfs(MemorySegment x0, MemorySegment x1) {
        var mh$ = statfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("statfs", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unmount {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("unmount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unmount(const char *, int)
     * }
     */
    public static FunctionDescriptor unmount$descriptor() {
        return unmount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unmount(const char *, int)
     * }
     */
    public static MethodHandle unmount$handle() {
        return unmount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unmount(const char *, int)
     * }
     */
    public static MemorySegment unmount$address() {
        return unmount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unmount(const char *, int)
     * }
     */
    public static int unmount(MemorySegment x0, int x1) {
        var mh$ = unmount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unmount", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getvfsbyname {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("getvfsbyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getvfsbyname(const char *, struct vfsconf *)
     * }
     */
    public static FunctionDescriptor getvfsbyname$descriptor() {
        return getvfsbyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getvfsbyname(const char *, struct vfsconf *)
     * }
     */
    public static MethodHandle getvfsbyname$handle() {
        return getvfsbyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getvfsbyname(const char *, struct vfsconf *)
     * }
     */
    public static MemorySegment getvfsbyname$address() {
        return getvfsbyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getvfsbyname(const char *, struct vfsconf *)
     * }
     */
    public static int getvfsbyname(MemorySegment x0, MemorySegment x1) {
        var mh$ = getvfsbyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getvfsbyname", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint8_t sa_family_t
     * }
     */
    public static final OfByte sa_family_t = proc_info_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __darwin_socklen_t socklen_t
     * }
     */
    public static final OfInt socklen_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t sae_associd_t
     * }
     */
    public static final OfInt sae_associd_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t sae_connid_t
     * }
     */
    public static final OfInt sae_connid_t = proc_info_h.C_INT;

    private static class accept {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("accept");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int accept(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static FunctionDescriptor accept$descriptor() {
        return accept.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int accept(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MethodHandle accept$handle() {
        return accept.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int accept(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MemorySegment accept$address() {
        return accept.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int accept(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static int accept(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = accept.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("accept", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bind {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("bind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bind(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static FunctionDescriptor bind$descriptor() {
        return bind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bind(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static MethodHandle bind$handle() {
        return bind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int bind(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static MemorySegment bind$address() {
        return bind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int bind(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static int bind(int x0, MemorySegment x1, int x2) {
        var mh$ = bind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bind", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class connect {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("connect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int connect(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static FunctionDescriptor connect$descriptor() {
        return connect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int connect(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static MethodHandle connect$handle() {
        return connect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int connect(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static MemorySegment connect$address() {
        return connect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int connect(int, const struct sockaddr *, socklen_t)
     * }
     */
    public static int connect(int x0, MemorySegment x1, int x2) {
        var mh$ = connect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("connect", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpeername {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("getpeername");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpeername(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static FunctionDescriptor getpeername$descriptor() {
        return getpeername.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpeername(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MethodHandle getpeername$handle() {
        return getpeername.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpeername(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MemorySegment getpeername$address() {
        return getpeername.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpeername(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static int getpeername(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getpeername.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpeername", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("getsockname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsockname(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static FunctionDescriptor getsockname$descriptor() {
        return getsockname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsockname(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MethodHandle getsockname$handle() {
        return getsockname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsockname(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MemorySegment getsockname$address() {
        return getsockname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsockname(int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static int getsockname(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getsockname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockname", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("getsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsockopt(int, int, int, void *restrict, socklen_t *restrict)
     * }
     */
    public static FunctionDescriptor getsockopt$descriptor() {
        return getsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsockopt(int, int, int, void *restrict, socklen_t *restrict)
     * }
     */
    public static MethodHandle getsockopt$handle() {
        return getsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsockopt(int, int, int, void *restrict, socklen_t *restrict)
     * }
     */
    public static MemorySegment getsockopt$address() {
        return getsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsockopt(int, int, int, void *restrict, socklen_t *restrict)
     * }
     */
    public static int getsockopt(int x0, int x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = getsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockopt", x0, x1, x2, x3, x4);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class listen {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("listen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int listen(int, int)
     * }
     */
    public static FunctionDescriptor listen$descriptor() {
        return listen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int listen(int, int)
     * }
     */
    public static MethodHandle listen$handle() {
        return listen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int listen(int, int)
     * }
     */
    public static MemorySegment listen$address() {
        return listen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int listen(int, int)
     * }
     */
    public static int listen(int x0, int x1) {
        var mh$ = listen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("listen", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_LONG, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_LONG, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("recv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t recv(int, void *, size_t, int)
     * }
     */
    public static FunctionDescriptor recv$descriptor() {
        return recv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t recv(int, void *, size_t, int)
     * }
     */
    public static MethodHandle recv$handle() {
        return recv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t recv(int, void *, size_t, int)
     * }
     */
    public static MemorySegment recv$address() {
        return recv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t recv(int, void *, size_t, int)
     * }
     */
    public static long recv(int x0, MemorySegment x1, long x2, int x3) {
        var mh$ = recv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recv", x0, x1, x2, x3);
            }
            return (long) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvfrom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_LONG,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_LONG,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("recvfrom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t recvfrom(int, void *, size_t, int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static FunctionDescriptor recvfrom$descriptor() {
        return recvfrom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t recvfrom(int, void *, size_t, int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MethodHandle recvfrom$handle() {
        return recvfrom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t recvfrom(int, void *, size_t, int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static MemorySegment recvfrom$address() {
        return recvfrom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t recvfrom(int, void *, size_t, int, struct sockaddr *restrict, socklen_t *restrict)
     * }
     */
    public static long recvfrom(int x0, MemorySegment x1, long x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = recvfrom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvfrom", x0, x1, x2, x3, x4, x5);
            }
            return (long) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvmsg {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_LONG, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("recvmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t recvmsg(int, struct msghdr *, int)
     * }
     */
    public static FunctionDescriptor recvmsg$descriptor() {
        return recvmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t recvmsg(int, struct msghdr *, int)
     * }
     */
    public static MethodHandle recvmsg$handle() {
        return recvmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t recvmsg(int, struct msghdr *, int)
     * }
     */
    public static MemorySegment recvmsg$address() {
        return recvmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t recvmsg(int, struct msghdr *, int)
     * }
     */
    public static long recvmsg(int x0, MemorySegment x1, int x2) {
        var mh$ = recvmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvmsg", x0, x1, x2);
            }
            return (long) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class send {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_LONG, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_LONG, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("send");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t send(int, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor send$descriptor() {
        return send.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t send(int, const void *, size_t, int)
     * }
     */
    public static MethodHandle send$handle() {
        return send.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t send(int, const void *, size_t, int)
     * }
     */
    public static MemorySegment send$address() {
        return send.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t send(int, const void *, size_t, int)
     * }
     */
    public static long send(int x0, MemorySegment x1, long x2, int x3) {
        var mh$ = send.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("send", x0, x1, x2, x3);
            }
            return (long) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendmsg {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_LONG, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("sendmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t sendmsg(int, const struct msghdr *, int)
     * }
     */
    public static FunctionDescriptor sendmsg$descriptor() {
        return sendmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t sendmsg(int, const struct msghdr *, int)
     * }
     */
    public static MethodHandle sendmsg$handle() {
        return sendmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t sendmsg(int, const struct msghdr *, int)
     * }
     */
    public static MemorySegment sendmsg$address() {
        return sendmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t sendmsg(int, const struct msghdr *, int)
     * }
     */
    public static long sendmsg(int x0, MemorySegment x1, int x2) {
        var mh$ = sendmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendmsg", x0, x1, x2);
            }
            return (long) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_LONG,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_LONG,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("sendto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t sendto(int, const void *, size_t, int, const struct sockaddr *, socklen_t)
     * }
     */
    public static FunctionDescriptor sendto$descriptor() {
        return sendto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t sendto(int, const void *, size_t, int, const struct sockaddr *, socklen_t)
     * }
     */
    public static MethodHandle sendto$handle() {
        return sendto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t sendto(int, const void *, size_t, int, const struct sockaddr *, socklen_t)
     * }
     */
    public static MemorySegment sendto$address() {
        return sendto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t sendto(int, const void *, size_t, int, const struct sockaddr *, socklen_t)
     * }
     */
    public static long sendto(int x0, MemorySegment x1, long x2, int x3, MemorySegment x4, int x5) {
        var mh$ = sendto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendto", x0, x1, x2, x3, x4, x5);
            }
            return (long) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("setsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setsockopt(int, int, int, const void *, socklen_t)
     * }
     */
    public static FunctionDescriptor setsockopt$descriptor() {
        return setsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setsockopt(int, int, int, const void *, socklen_t)
     * }
     */
    public static MethodHandle setsockopt$handle() {
        return setsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setsockopt(int, int, int, const void *, socklen_t)
     * }
     */
    public static MemorySegment setsockopt$address() {
        return setsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setsockopt(int, int, int, const void *, socklen_t)
     * }
     */
    public static int setsockopt(int x0, int x1, int x2, MemorySegment x3, int x4) {
        var mh$ = setsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsockopt", x0, x1, x2, x3, x4);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shutdown {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("shutdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int shutdown(int, int)
     * }
     */
    public static FunctionDescriptor shutdown$descriptor() {
        return shutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int shutdown(int, int)
     * }
     */
    public static MethodHandle shutdown$handle() {
        return shutdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int shutdown(int, int)
     * }
     */
    public static MemorySegment shutdown$address() {
        return shutdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int shutdown(int, int)
     * }
     */
    public static int shutdown(int x0, int x1) {
        var mh$ = shutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shutdown", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sockatmark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("sockatmark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sockatmark(int)
     * }
     */
    public static FunctionDescriptor sockatmark$descriptor() {
        return sockatmark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sockatmark(int)
     * }
     */
    public static MethodHandle sockatmark$handle() {
        return sockatmark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sockatmark(int)
     * }
     */
    public static MemorySegment sockatmark$address() {
        return sockatmark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sockatmark(int)
     * }
     */
    public static int sockatmark(int x0) {
        var mh$ = sockatmark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sockatmark", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class socket {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("socket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int socket(int, int, int)
     * }
     */
    public static FunctionDescriptor socket$descriptor() {
        return socket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int socket(int, int, int)
     * }
     */
    public static MethodHandle socket$handle() {
        return socket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int socket(int, int, int)
     * }
     */
    public static MemorySegment socket$address() {
        return socket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int socket(int, int, int)
     * }
     */
    public static int socket(int x0, int x1, int x2) {
        var mh$ = socket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socket", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class socketpair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("socketpair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int socketpair(int, int, int, int *)
     * }
     */
    public static FunctionDescriptor socketpair$descriptor() {
        return socketpair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int socketpair(int, int, int, int *)
     * }
     */
    public static MethodHandle socketpair$handle() {
        return socketpair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int socketpair(int, int, int, int *)
     * }
     */
    public static MemorySegment socketpair$address() {
        return socketpair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int socketpair(int, int, int, int *)
     * }
     */
    public static int socketpair(int x0, int x1, int x2, MemorySegment x3) {
        var mh$ = socketpair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socketpair", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_LONG_LONG,
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER,
                proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("sendfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sendfile(int, int, off_t, off_t *, struct sf_hdtr *, int)
     * }
     */
    public static FunctionDescriptor sendfile$descriptor() {
        return sendfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sendfile(int, int, off_t, off_t *, struct sf_hdtr *, int)
     * }
     */
    public static MethodHandle sendfile$handle() {
        return sendfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sendfile(int, int, off_t, off_t *, struct sf_hdtr *, int)
     * }
     */
    public static MemorySegment sendfile$address() {
        return sendfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sendfile(int, int, off_t, off_t *, struct sf_hdtr *, int)
     * }
     */
    public static int sendfile(int x0, int x1, long x2, MemorySegment x3, MemorySegment x4, int x5) {
        var mh$ = sendfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendfile", x0, x1, x2, x3, x4, x5);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pfctlinput {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.ofVoid(proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("pfctlinput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pfctlinput(int, struct sockaddr *)
     * }
     */
    public static FunctionDescriptor pfctlinput$descriptor() {
        return pfctlinput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pfctlinput(int, struct sockaddr *)
     * }
     */
    public static MethodHandle pfctlinput$handle() {
        return pfctlinput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pfctlinput(int, struct sockaddr *)
     * }
     */
    public static MemorySegment pfctlinput$address() {
        return pfctlinput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pfctlinput(int, struct sockaddr *)
     * }
     */
    public static void pfctlinput(int x0, MemorySegment x1) {
        var mh$ = pfctlinput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pfctlinput", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class connectx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("connectx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int connectx(int, const sa_endpoints_t *, sae_associd_t, unsigned int, const struct iovec *, unsigned int, size_t *, sae_connid_t *)
     * }
     */
    public static FunctionDescriptor connectx$descriptor() {
        return connectx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int connectx(int, const sa_endpoints_t *, sae_associd_t, unsigned int, const struct iovec *, unsigned int, size_t *, sae_connid_t *)
     * }
     */
    public static MethodHandle connectx$handle() {
        return connectx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int connectx(int, const sa_endpoints_t *, sae_associd_t, unsigned int, const struct iovec *, unsigned int, size_t *, sae_connid_t *)
     * }
     */
    public static MemorySegment connectx$address() {
        return connectx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int connectx(int, const sa_endpoints_t *, sae_associd_t, unsigned int, const struct iovec *, unsigned int, size_t *, sae_connid_t *)
     * }
     */
    public static int connectx(
            int x0, MemorySegment x1, int x2, int x3, MemorySegment x4, int x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = connectx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("connectx", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class disconnectx {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("disconnectx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int disconnectx(int, sae_associd_t, sae_connid_t)
     * }
     */
    public static FunctionDescriptor disconnectx$descriptor() {
        return disconnectx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int disconnectx(int, sae_associd_t, sae_connid_t)
     * }
     */
    public static MethodHandle disconnectx$handle() {
        return disconnectx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int disconnectx(int, sae_associd_t, sae_connid_t)
     * }
     */
    public static MemorySegment disconnectx$address() {
        return disconnectx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int disconnectx(int, sae_associd_t, sae_connid_t)
     * }
     */
    public static int disconnectx(int x0, int x1, int x2) {
        var mh$ = disconnectx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("disconnectx", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static final int eNoteReapDeprecated = (int) 268435456L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.eNoteReapDeprecated = 268435456
     * }
     */
    public static int eNoteReapDeprecated() {
        return eNoteReapDeprecated;
    }

    private static final int eNoteExitReparentedDeprecated = (int) 524288L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.eNoteExitReparentedDeprecated = 524288
     * }
     */
    public static int eNoteExitReparentedDeprecated() {
        return eNoteExitReparentedDeprecated;
    }

    private static class kqueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("kqueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int kqueue()
     * }
     */
    public static FunctionDescriptor kqueue$descriptor() {
        return kqueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int kqueue()
     * }
     */
    public static MethodHandle kqueue$handle() {
        return kqueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int kqueue()
     * }
     */
    public static MemorySegment kqueue$address() {
        return kqueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int kqueue()
     * }
     */
    public static int kqueue() {
        var mh$ = kqueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("kqueue");
            }
            return (int) mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class kevent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("kevent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)
     * }
     */
    public static FunctionDescriptor kevent$descriptor() {
        return kevent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)
     * }
     */
    public static MethodHandle kevent$handle() {
        return kevent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)
     * }
     */
    public static MemorySegment kevent$address() {
        return kevent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)
     * }
     */
    public static int kevent(
            int kq,
            MemorySegment changelist,
            int nchanges,
            MemorySegment eventlist,
            int nevents,
            MemorySegment timeout) {
        var mh$ = kevent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("kevent", kq, changelist, nchanges, eventlist, nevents, timeout);
            }
            return (int) mh$.invokeExact(kq, changelist, nchanges, eventlist, nevents, timeout);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class kevent64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("kevent64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int kevent64(int kq, const struct kevent64_s *changelist, int nchanges, struct kevent64_s *eventlist, int nevents, unsigned int flags, const struct timespec *timeout)
     * }
     */
    public static FunctionDescriptor kevent64$descriptor() {
        return kevent64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int kevent64(int kq, const struct kevent64_s *changelist, int nchanges, struct kevent64_s *eventlist, int nevents, unsigned int flags, const struct timespec *timeout)
     * }
     */
    public static MethodHandle kevent64$handle() {
        return kevent64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int kevent64(int kq, const struct kevent64_s *changelist, int nchanges, struct kevent64_s *eventlist, int nevents, unsigned int flags, const struct timespec *timeout)
     * }
     */
    public static MemorySegment kevent64$address() {
        return kevent64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int kevent64(int kq, const struct kevent64_s *changelist, int nchanges, struct kevent64_s *eventlist, int nevents, unsigned int flags, const struct timespec *timeout)
     * }
     */
    public static int kevent64(
            int kq,
            MemorySegment changelist,
            int nchanges,
            MemorySegment eventlist,
            int nevents,
            int flags,
            MemorySegment timeout) {
        var mh$ = kevent64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("kevent64", kq, changelist, nchanges, eventlist, nevents, flags, timeout);
            }
            return (int) mh$.invokeExact(kq, changelist, nchanges, eventlist, nevents, flags, timeout);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class if_nametoindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("if_nametoindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int if_nametoindex(const char *)
     * }
     */
    public static FunctionDescriptor if_nametoindex$descriptor() {
        return if_nametoindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int if_nametoindex(const char *)
     * }
     */
    public static MethodHandle if_nametoindex$handle() {
        return if_nametoindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int if_nametoindex(const char *)
     * }
     */
    public static MemorySegment if_nametoindex$address() {
        return if_nametoindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int if_nametoindex(const char *)
     * }
     */
    public static int if_nametoindex(MemorySegment x0) {
        var mh$ = if_nametoindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("if_nametoindex", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class if_indextoname {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_POINTER, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("if_indextoname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *if_indextoname(unsigned int, char *)
     * }
     */
    public static FunctionDescriptor if_indextoname$descriptor() {
        return if_indextoname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *if_indextoname(unsigned int, char *)
     * }
     */
    public static MethodHandle if_indextoname$handle() {
        return if_indextoname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *if_indextoname(unsigned int, char *)
     * }
     */
    public static MemorySegment if_indextoname$address() {
        return if_indextoname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *if_indextoname(unsigned int, char *)
     * }
     */
    public static MemorySegment if_indextoname(int x0, MemorySegment x1) {
        var mh$ = if_indextoname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("if_indextoname", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class if_nameindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("if_nameindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct if_nameindex *if_nameindex()
     * }
     */
    public static FunctionDescriptor if_nameindex$descriptor() {
        return if_nameindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct if_nameindex *if_nameindex()
     * }
     */
    public static MethodHandle if_nameindex$handle() {
        return if_nameindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct if_nameindex *if_nameindex()
     * }
     */
    public static MemorySegment if_nameindex$address() {
        return if_nameindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct if_nameindex *if_nameindex()
     * }
     */
    public static MemorySegment if_nameindex() {
        var mh$ = if_nameindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("if_nameindex");
            }
            return (MemorySegment) mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class if_freenameindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("if_freenameindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void if_freenameindex(struct if_nameindex *)
     * }
     */
    public static FunctionDescriptor if_freenameindex$descriptor() {
        return if_freenameindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void if_freenameindex(struct if_nameindex *)
     * }
     */
    public static MethodHandle if_freenameindex$handle() {
        return if_freenameindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void if_freenameindex(struct if_nameindex *)
     * }
     */
    public static MemorySegment if_freenameindex$address() {
        return if_freenameindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void if_freenameindex(struct if_nameindex *)
     * }
     */
    public static void if_freenameindex(MemorySegment x0) {
        var mh$ = if_freenameindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("if_freenameindex", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setipv4sourcefilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                in_addr.layout(),
                in_addr.layout(),
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("setipv4sourcefilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t, uint32_t, struct in_addr *)
     * }
     */
    public static FunctionDescriptor setipv4sourcefilter$descriptor() {
        return setipv4sourcefilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t, uint32_t, struct in_addr *)
     * }
     */
    public static MethodHandle setipv4sourcefilter$handle() {
        return setipv4sourcefilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t, uint32_t, struct in_addr *)
     * }
     */
    public static MemorySegment setipv4sourcefilter$address() {
        return setipv4sourcefilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t, uint32_t, struct in_addr *)
     * }
     */
    public static int setipv4sourcefilter(
            int x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5) {
        var mh$ = setipv4sourcefilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setipv4sourcefilter", x0, x1, x2, x3, x4, x5);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getipv4sourcefilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                in_addr.layout(),
                in_addr.layout(),
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("getipv4sourcefilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t *, uint32_t *, struct in_addr *)
     * }
     */
    public static FunctionDescriptor getipv4sourcefilter$descriptor() {
        return getipv4sourcefilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t *, uint32_t *, struct in_addr *)
     * }
     */
    public static MethodHandle getipv4sourcefilter$handle() {
        return getipv4sourcefilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t *, uint32_t *, struct in_addr *)
     * }
     */
    public static MemorySegment getipv4sourcefilter$address() {
        return getipv4sourcefilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t *, uint32_t *, struct in_addr *)
     * }
     */
    public static int getipv4sourcefilter(
            int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = getipv4sourcefilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getipv4sourcefilter", x0, x1, x2, x3, x4, x5);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsourcefilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("setsourcefilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t, uint32_t, struct sockaddr_storage *)
     * }
     */
    public static FunctionDescriptor setsourcefilter$descriptor() {
        return setsourcefilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t, uint32_t, struct sockaddr_storage *)
     * }
     */
    public static MethodHandle setsourcefilter$handle() {
        return setsourcefilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t, uint32_t, struct sockaddr_storage *)
     * }
     */
    public static MemorySegment setsourcefilter$address() {
        return setsourcefilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t, uint32_t, struct sockaddr_storage *)
     * }
     */
    public static int setsourcefilter(int x0, int x1, MemorySegment x2, int x3, int x4, int x5, MemorySegment x6) {
        var mh$ = setsourcefilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsourcefilter", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsourcefilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("getsourcefilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t *, uint32_t *, struct sockaddr_storage *)
     * }
     */
    public static FunctionDescriptor getsourcefilter$descriptor() {
        return getsourcefilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t *, uint32_t *, struct sockaddr_storage *)
     * }
     */
    public static MethodHandle getsourcefilter$handle() {
        return getsourcefilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t *, uint32_t *, struct sockaddr_storage *)
     * }
     */
    public static MemorySegment getsourcefilter$address() {
        return getsourcefilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t *, uint32_t *, struct sockaddr_storage *)
     * }
     */
    public static int getsourcefilter(
            int x0, int x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = getsourcefilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsourcefilter", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class in6addr_any$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT =
                proc_info_h.findOrThrow("in6addr_any").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_any
     * }
     */
    public static GroupLayout in6addr_any$layout() {
        return in6addr_any$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_any
     * }
     */
    public static MemorySegment in6addr_any() {
        return in6addr_any$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_any
     * }
     */
    public static void in6addr_any(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, in6addr_any$constants.SEGMENT, 0L, in6addr_any$constants.LAYOUT.byteSize());
    }

    private static class in6addr_loopback$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT =
                proc_info_h.findOrThrow("in6addr_loopback").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_loopback
     * }
     */
    public static GroupLayout in6addr_loopback$layout() {
        return in6addr_loopback$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_loopback
     * }
     */
    public static MemorySegment in6addr_loopback() {
        return in6addr_loopback$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_loopback
     * }
     */
    public static void in6addr_loopback(MemorySegment varValue) {
        MemorySegment.copy(
                varValue, 0L, in6addr_loopback$constants.SEGMENT, 0L, in6addr_loopback$constants.LAYOUT.byteSize());
    }

    private static class in6addr_nodelocal_allnodes$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT =
                proc_info_h.findOrThrow("in6addr_nodelocal_allnodes").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_nodelocal_allnodes
     * }
     */
    public static GroupLayout in6addr_nodelocal_allnodes$layout() {
        return in6addr_nodelocal_allnodes$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_nodelocal_allnodes
     * }
     */
    public static MemorySegment in6addr_nodelocal_allnodes() {
        return in6addr_nodelocal_allnodes$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_nodelocal_allnodes
     * }
     */
    public static void in6addr_nodelocal_allnodes(MemorySegment varValue) {
        MemorySegment.copy(
                varValue,
                0L,
                in6addr_nodelocal_allnodes$constants.SEGMENT,
                0L,
                in6addr_nodelocal_allnodes$constants.LAYOUT.byteSize());
    }

    private static class in6addr_linklocal_allnodes$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT =
                proc_info_h.findOrThrow("in6addr_linklocal_allnodes").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allnodes
     * }
     */
    public static GroupLayout in6addr_linklocal_allnodes$layout() {
        return in6addr_linklocal_allnodes$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allnodes
     * }
     */
    public static MemorySegment in6addr_linklocal_allnodes() {
        return in6addr_linklocal_allnodes$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allnodes
     * }
     */
    public static void in6addr_linklocal_allnodes(MemorySegment varValue) {
        MemorySegment.copy(
                varValue,
                0L,
                in6addr_linklocal_allnodes$constants.SEGMENT,
                0L,
                in6addr_linklocal_allnodes$constants.LAYOUT.byteSize());
    }

    private static class in6addr_linklocal_allrouters$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT =
                proc_info_h.findOrThrow("in6addr_linklocal_allrouters").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allrouters
     * }
     */
    public static GroupLayout in6addr_linklocal_allrouters$layout() {
        return in6addr_linklocal_allrouters$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allrouters
     * }
     */
    public static MemorySegment in6addr_linklocal_allrouters() {
        return in6addr_linklocal_allrouters$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allrouters
     * }
     */
    public static void in6addr_linklocal_allrouters(MemorySegment varValue) {
        MemorySegment.copy(
                varValue,
                0L,
                in6addr_linklocal_allrouters$constants.SEGMENT,
                0L,
                in6addr_linklocal_allrouters$constants.LAYOUT.byteSize());
    }

    private static class in6addr_linklocal_allv2routers$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT =
                proc_info_h.findOrThrow("in6addr_linklocal_allv2routers").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allv2routers
     * }
     */
    public static GroupLayout in6addr_linklocal_allv2routers$layout() {
        return in6addr_linklocal_allv2routers$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allv2routers
     * }
     */
    public static MemorySegment in6addr_linklocal_allv2routers() {
        return in6addr_linklocal_allv2routers$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_linklocal_allv2routers
     * }
     */
    public static void in6addr_linklocal_allv2routers(MemorySegment varValue) {
        MemorySegment.copy(
                varValue,
                0L,
                in6addr_linklocal_allv2routers$constants.SEGMENT,
                0L,
                in6addr_linklocal_allv2routers$constants.LAYOUT.byteSize());
    }

    private static class inet6_option_space {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_option_space");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_option_space(int)
     * }
     */
    public static FunctionDescriptor inet6_option_space$descriptor() {
        return inet6_option_space.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_option_space(int)
     * }
     */
    public static MethodHandle inet6_option_space$handle() {
        return inet6_option_space.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_option_space(int)
     * }
     */
    public static MemorySegment inet6_option_space$address() {
        return inet6_option_space.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_option_space(int)
     * }
     */
    public static int inet6_option_space(int x0) {
        var mh$ = inet6_option_space.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_option_space", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_option_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_option_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_option_init(void *, struct cmsghdr **, int)
     * }
     */
    public static FunctionDescriptor inet6_option_init$descriptor() {
        return inet6_option_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_option_init(void *, struct cmsghdr **, int)
     * }
     */
    public static MethodHandle inet6_option_init$handle() {
        return inet6_option_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_option_init(void *, struct cmsghdr **, int)
     * }
     */
    public static MemorySegment inet6_option_init$address() {
        return inet6_option_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_option_init(void *, struct cmsghdr **, int)
     * }
     */
    public static int inet6_option_init(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = inet6_option_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_option_init", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_option_append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_INT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_option_append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_option_append(struct cmsghdr *, const __uint8_t *, int, int)
     * }
     */
    public static FunctionDescriptor inet6_option_append$descriptor() {
        return inet6_option_append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_option_append(struct cmsghdr *, const __uint8_t *, int, int)
     * }
     */
    public static MethodHandle inet6_option_append$handle() {
        return inet6_option_append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_option_append(struct cmsghdr *, const __uint8_t *, int, int)
     * }
     */
    public static MemorySegment inet6_option_append$address() {
        return inet6_option_append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_option_append(struct cmsghdr *, const __uint8_t *, int, int)
     * }
     */
    public static int inet6_option_append(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = inet6_option_append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_option_append", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_option_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_option_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint8_t *inet6_option_alloc(struct cmsghdr *, int, int, int)
     * }
     */
    public static FunctionDescriptor inet6_option_alloc$descriptor() {
        return inet6_option_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint8_t *inet6_option_alloc(struct cmsghdr *, int, int, int)
     * }
     */
    public static MethodHandle inet6_option_alloc$handle() {
        return inet6_option_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uint8_t *inet6_option_alloc(struct cmsghdr *, int, int, int)
     * }
     */
    public static MemorySegment inet6_option_alloc$address() {
        return inet6_option_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uint8_t *inet6_option_alloc(struct cmsghdr *, int, int, int)
     * }
     */
    public static MemorySegment inet6_option_alloc(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = inet6_option_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_option_alloc", x0, x1, x2, x3);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_option_next {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_option_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_option_next(const struct cmsghdr *, __uint8_t **)
     * }
     */
    public static FunctionDescriptor inet6_option_next$descriptor() {
        return inet6_option_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_option_next(const struct cmsghdr *, __uint8_t **)
     * }
     */
    public static MethodHandle inet6_option_next$handle() {
        return inet6_option_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_option_next(const struct cmsghdr *, __uint8_t **)
     * }
     */
    public static MemorySegment inet6_option_next$address() {
        return inet6_option_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_option_next(const struct cmsghdr *, __uint8_t **)
     * }
     */
    public static int inet6_option_next(MemorySegment x0, MemorySegment x1) {
        var mh$ = inet6_option_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_option_next", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_option_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_option_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_option_find(const struct cmsghdr *, __uint8_t **, int)
     * }
     */
    public static FunctionDescriptor inet6_option_find$descriptor() {
        return inet6_option_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_option_find(const struct cmsghdr *, __uint8_t **, int)
     * }
     */
    public static MethodHandle inet6_option_find$handle() {
        return inet6_option_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_option_find(const struct cmsghdr *, __uint8_t **, int)
     * }
     */
    public static MemorySegment inet6_option_find$address() {
        return inet6_option_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_option_find(const struct cmsghdr *, __uint8_t **, int)
     * }
     */
    public static int inet6_option_find(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = inet6_option_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_option_find", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rthdr_space {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_LONG, proc_info_h.C_INT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_rthdr_space");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t inet6_rthdr_space(int, int)
     * }
     */
    public static FunctionDescriptor inet6_rthdr_space$descriptor() {
        return inet6_rthdr_space.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t inet6_rthdr_space(int, int)
     * }
     */
    public static MethodHandle inet6_rthdr_space$handle() {
        return inet6_rthdr_space.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t inet6_rthdr_space(int, int)
     * }
     */
    public static MemorySegment inet6_rthdr_space$address() {
        return inet6_rthdr_space.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t inet6_rthdr_space(int, int)
     * }
     */
    public static long inet6_rthdr_space(int x0, int x1) {
        var mh$ = inet6_rthdr_space.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rthdr_space", x0, x1);
            }
            return (long) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rthdr_init {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_rthdr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct cmsghdr *inet6_rthdr_init(void *, int)
     * }
     */
    public static FunctionDescriptor inet6_rthdr_init$descriptor() {
        return inet6_rthdr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct cmsghdr *inet6_rthdr_init(void *, int)
     * }
     */
    public static MethodHandle inet6_rthdr_init$handle() {
        return inet6_rthdr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct cmsghdr *inet6_rthdr_init(void *, int)
     * }
     */
    public static MemorySegment inet6_rthdr_init$address() {
        return inet6_rthdr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct cmsghdr *inet6_rthdr_init(void *, int)
     * }
     */
    public static MemorySegment inet6_rthdr_init(MemorySegment x0, int x1) {
        var mh$ = inet6_rthdr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rthdr_init", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rthdr_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_rthdr_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_add(struct cmsghdr *, const struct in6_addr *, unsigned int)
     * }
     */
    public static FunctionDescriptor inet6_rthdr_add$descriptor() {
        return inet6_rthdr_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_add(struct cmsghdr *, const struct in6_addr *, unsigned int)
     * }
     */
    public static MethodHandle inet6_rthdr_add$handle() {
        return inet6_rthdr_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_add(struct cmsghdr *, const struct in6_addr *, unsigned int)
     * }
     */
    public static MemorySegment inet6_rthdr_add$address() {
        return inet6_rthdr_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_rthdr_add(struct cmsghdr *, const struct in6_addr *, unsigned int)
     * }
     */
    public static int inet6_rthdr_add(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = inet6_rthdr_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rthdr_add", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rthdr_lasthop {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_rthdr_lasthop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_lasthop(struct cmsghdr *, unsigned int)
     * }
     */
    public static FunctionDescriptor inet6_rthdr_lasthop$descriptor() {
        return inet6_rthdr_lasthop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_lasthop(struct cmsghdr *, unsigned int)
     * }
     */
    public static MethodHandle inet6_rthdr_lasthop$handle() {
        return inet6_rthdr_lasthop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_lasthop(struct cmsghdr *, unsigned int)
     * }
     */
    public static MemorySegment inet6_rthdr_lasthop$address() {
        return inet6_rthdr_lasthop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_rthdr_lasthop(struct cmsghdr *, unsigned int)
     * }
     */
    public static int inet6_rthdr_lasthop(MemorySegment x0, int x1) {
        var mh$ = inet6_rthdr_lasthop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rthdr_lasthop", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rthdr_segments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_rthdr_segments");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_segments(const struct cmsghdr *)
     * }
     */
    public static FunctionDescriptor inet6_rthdr_segments$descriptor() {
        return inet6_rthdr_segments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_segments(const struct cmsghdr *)
     * }
     */
    public static MethodHandle inet6_rthdr_segments$handle() {
        return inet6_rthdr_segments.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_segments(const struct cmsghdr *)
     * }
     */
    public static MemorySegment inet6_rthdr_segments$address() {
        return inet6_rthdr_segments.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_rthdr_segments(const struct cmsghdr *)
     * }
     */
    public static int inet6_rthdr_segments(MemorySegment x0) {
        var mh$ = inet6_rthdr_segments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rthdr_segments", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rthdr_getaddr {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_rthdr_getaddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr *, int)
     * }
     */
    public static FunctionDescriptor inet6_rthdr_getaddr$descriptor() {
        return inet6_rthdr_getaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr *, int)
     * }
     */
    public static MethodHandle inet6_rthdr_getaddr$handle() {
        return inet6_rthdr_getaddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr *, int)
     * }
     */
    public static MemorySegment inet6_rthdr_getaddr$address() {
        return inet6_rthdr_getaddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr *, int)
     * }
     */
    public static MemorySegment inet6_rthdr_getaddr(MemorySegment x0, int x1) {
        var mh$ = inet6_rthdr_getaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rthdr_getaddr", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rthdr_getflags {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_rthdr_getflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_getflags(const struct cmsghdr *, int)
     * }
     */
    public static FunctionDescriptor inet6_rthdr_getflags$descriptor() {
        return inet6_rthdr_getflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_getflags(const struct cmsghdr *, int)
     * }
     */
    public static MethodHandle inet6_rthdr_getflags$handle() {
        return inet6_rthdr_getflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_rthdr_getflags(const struct cmsghdr *, int)
     * }
     */
    public static MemorySegment inet6_rthdr_getflags$address() {
        return inet6_rthdr_getflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_rthdr_getflags(const struct cmsghdr *, int)
     * }
     */
    public static int inet6_rthdr_getflags(MemorySegment x0, int x1) {
        var mh$ = inet6_rthdr_getflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rthdr_getflags", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_opt_init {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_opt_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_opt_init(void *, socklen_t)
     * }
     */
    public static FunctionDescriptor inet6_opt_init$descriptor() {
        return inet6_opt_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_opt_init(void *, socklen_t)
     * }
     */
    public static MethodHandle inet6_opt_init$handle() {
        return inet6_opt_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_opt_init(void *, socklen_t)
     * }
     */
    public static MemorySegment inet6_opt_init$address() {
        return inet6_opt_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_opt_init(void *, socklen_t)
     * }
     */
    public static int inet6_opt_init(MemorySegment x0, int x1) {
        var mh$ = inet6_opt_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_opt_init", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_opt_append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_CHAR,
                proc_info_h.C_INT,
                proc_info_h.C_CHAR,
                proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_opt_append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_opt_append(void *, socklen_t, int, __uint8_t, socklen_t, __uint8_t, void **)
     * }
     */
    public static FunctionDescriptor inet6_opt_append$descriptor() {
        return inet6_opt_append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_opt_append(void *, socklen_t, int, __uint8_t, socklen_t, __uint8_t, void **)
     * }
     */
    public static MethodHandle inet6_opt_append$handle() {
        return inet6_opt_append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_opt_append(void *, socklen_t, int, __uint8_t, socklen_t, __uint8_t, void **)
     * }
     */
    public static MemorySegment inet6_opt_append$address() {
        return inet6_opt_append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_opt_append(void *, socklen_t, int, __uint8_t, socklen_t, __uint8_t, void **)
     * }
     */
    public static int inet6_opt_append(MemorySegment x0, int x1, int x2, byte x3, int x4, byte x5, MemorySegment x6) {
        var mh$ = inet6_opt_append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_opt_append", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_opt_finish {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_opt_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_opt_finish(void *, socklen_t, int)
     * }
     */
    public static FunctionDescriptor inet6_opt_finish$descriptor() {
        return inet6_opt_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_opt_finish(void *, socklen_t, int)
     * }
     */
    public static MethodHandle inet6_opt_finish$handle() {
        return inet6_opt_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_opt_finish(void *, socklen_t, int)
     * }
     */
    public static MemorySegment inet6_opt_finish$address() {
        return inet6_opt_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_opt_finish(void *, socklen_t, int)
     * }
     */
    public static int inet6_opt_finish(MemorySegment x0, int x1, int x2) {
        var mh$ = inet6_opt_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_opt_finish", x0, x1, x2);
            }
            return (int) mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_opt_set_val {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_opt_set_val");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_opt_set_val(void *, int, void *, socklen_t)
     * }
     */
    public static FunctionDescriptor inet6_opt_set_val$descriptor() {
        return inet6_opt_set_val.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_opt_set_val(void *, int, void *, socklen_t)
     * }
     */
    public static MethodHandle inet6_opt_set_val$handle() {
        return inet6_opt_set_val.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_opt_set_val(void *, int, void *, socklen_t)
     * }
     */
    public static MemorySegment inet6_opt_set_val$address() {
        return inet6_opt_set_val.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_opt_set_val(void *, int, void *, socklen_t)
     * }
     */
    public static int inet6_opt_set_val(MemorySegment x0, int x1, MemorySegment x2, int x3) {
        var mh$ = inet6_opt_set_val.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_opt_set_val", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_opt_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_opt_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_opt_next(void *, socklen_t, int, __uint8_t *, socklen_t *, void **)
     * }
     */
    public static FunctionDescriptor inet6_opt_next$descriptor() {
        return inet6_opt_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_opt_next(void *, socklen_t, int, __uint8_t *, socklen_t *, void **)
     * }
     */
    public static MethodHandle inet6_opt_next$handle() {
        return inet6_opt_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_opt_next(void *, socklen_t, int, __uint8_t *, socklen_t *, void **)
     * }
     */
    public static MemorySegment inet6_opt_next$address() {
        return inet6_opt_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_opt_next(void *, socklen_t, int, __uint8_t *, socklen_t *, void **)
     * }
     */
    public static int inet6_opt_next(
            MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = inet6_opt_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_opt_next", x0, x1, x2, x3, x4, x5);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_opt_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT,
                proc_info_h.C_POINTER,
                proc_info_h.C_INT,
                proc_info_h.C_INT,
                proc_info_h.C_CHAR,
                proc_info_h.C_POINTER,
                proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_opt_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_opt_find(void *, socklen_t, int, __uint8_t, socklen_t *, void **)
     * }
     */
    public static FunctionDescriptor inet6_opt_find$descriptor() {
        return inet6_opt_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_opt_find(void *, socklen_t, int, __uint8_t, socklen_t *, void **)
     * }
     */
    public static MethodHandle inet6_opt_find$handle() {
        return inet6_opt_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_opt_find(void *, socklen_t, int, __uint8_t, socklen_t *, void **)
     * }
     */
    public static MemorySegment inet6_opt_find$address() {
        return inet6_opt_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_opt_find(void *, socklen_t, int, __uint8_t, socklen_t *, void **)
     * }
     */
    public static int inet6_opt_find(MemorySegment x0, int x1, int x2, byte x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = inet6_opt_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_opt_find", x0, x1, x2, x3, x4, x5);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_opt_get_val {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_opt_get_val");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_opt_get_val(void *, int, void *, socklen_t)
     * }
     */
    public static FunctionDescriptor inet6_opt_get_val$descriptor() {
        return inet6_opt_get_val.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_opt_get_val(void *, int, void *, socklen_t)
     * }
     */
    public static MethodHandle inet6_opt_get_val$handle() {
        return inet6_opt_get_val.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_opt_get_val(void *, int, void *, socklen_t)
     * }
     */
    public static MemorySegment inet6_opt_get_val$address() {
        return inet6_opt_get_val.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_opt_get_val(void *, int, void *, socklen_t)
     * }
     */
    public static int inet6_opt_get_val(MemorySegment x0, int x1, MemorySegment x2, int x3) {
        var mh$ = inet6_opt_get_val.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_opt_get_val", x0, x1, x2, x3);
            }
            return (int) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rth_space {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_rth_space");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern socklen_t inet6_rth_space(int, int)
     * }
     */
    public static FunctionDescriptor inet6_rth_space$descriptor() {
        return inet6_rth_space.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern socklen_t inet6_rth_space(int, int)
     * }
     */
    public static MethodHandle inet6_rth_space$handle() {
        return inet6_rth_space.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern socklen_t inet6_rth_space(int, int)
     * }
     */
    public static MemorySegment inet6_rth_space$address() {
        return inet6_rth_space.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern socklen_t inet6_rth_space(int, int)
     * }
     */
    public static int inet6_rth_space(int x0, int x1) {
        var mh$ = inet6_rth_space.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rth_space", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rth_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_rth_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *inet6_rth_init(void *, socklen_t, int, int)
     * }
     */
    public static FunctionDescriptor inet6_rth_init$descriptor() {
        return inet6_rth_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *inet6_rth_init(void *, socklen_t, int, int)
     * }
     */
    public static MethodHandle inet6_rth_init$handle() {
        return inet6_rth_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *inet6_rth_init(void *, socklen_t, int, int)
     * }
     */
    public static MemorySegment inet6_rth_init$address() {
        return inet6_rth_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *inet6_rth_init(void *, socklen_t, int, int)
     * }
     */
    public static MemorySegment inet6_rth_init(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = inet6_rth_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rth_init", x0, x1, x2, x3);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rth_add {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_rth_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_rth_add(void *, const struct in6_addr *)
     * }
     */
    public static FunctionDescriptor inet6_rth_add$descriptor() {
        return inet6_rth_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_rth_add(void *, const struct in6_addr *)
     * }
     */
    public static MethodHandle inet6_rth_add$handle() {
        return inet6_rth_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_rth_add(void *, const struct in6_addr *)
     * }
     */
    public static MemorySegment inet6_rth_add$address() {
        return inet6_rth_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_rth_add(void *, const struct in6_addr *)
     * }
     */
    public static int inet6_rth_add(MemorySegment x0, MemorySegment x1) {
        var mh$ = inet6_rth_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rth_add", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rth_reverse {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_rth_reverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_rth_reverse(const void *, void *)
     * }
     */
    public static FunctionDescriptor inet6_rth_reverse$descriptor() {
        return inet6_rth_reverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_rth_reverse(const void *, void *)
     * }
     */
    public static MethodHandle inet6_rth_reverse$handle() {
        return inet6_rth_reverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_rth_reverse(const void *, void *)
     * }
     */
    public static MemorySegment inet6_rth_reverse$address() {
        return inet6_rth_reverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_rth_reverse(const void *, void *)
     * }
     */
    public static int inet6_rth_reverse(MemorySegment x0, MemorySegment x1) {
        var mh$ = inet6_rth_reverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rth_reverse", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rth_segments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_rth_segments");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int inet6_rth_segments(const void *)
     * }
     */
    public static FunctionDescriptor inet6_rth_segments$descriptor() {
        return inet6_rth_segments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int inet6_rth_segments(const void *)
     * }
     */
    public static MethodHandle inet6_rth_segments$handle() {
        return inet6_rth_segments.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int inet6_rth_segments(const void *)
     * }
     */
    public static MemorySegment inet6_rth_segments$address() {
        return inet6_rth_segments.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int inet6_rth_segments(const void *)
     * }
     */
    public static int inet6_rth_segments(MemorySegment x0) {
        var mh$ = inet6_rth_segments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rth_segments", x0);
            }
            return (int) mh$.invokeExact(x0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet6_rth_getaddr {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_POINTER, proc_info_h.C_POINTER, proc_info_h.C_INT);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("inet6_rth_getaddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rth_getaddr(const void *, int)
     * }
     */
    public static FunctionDescriptor inet6_rth_getaddr$descriptor() {
        return inet6_rth_getaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rth_getaddr(const void *, int)
     * }
     */
    public static MethodHandle inet6_rth_getaddr$handle() {
        return inet6_rth_getaddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rth_getaddr(const void *, int)
     * }
     */
    public static MemorySegment inet6_rth_getaddr$address() {
        return inet6_rth_getaddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct in6_addr *inet6_rth_getaddr(const void *, int)
     * }
     */
    public static MemorySegment inet6_rth_getaddr(MemorySegment x0, int x1) {
        var mh$ = inet6_rth_getaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet6_rth_getaddr", x0, x1);
            }
            return (MemorySegment) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bindresvport {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("bindresvport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bindresvport(int, struct sockaddr_in *)
     * }
     */
    public static FunctionDescriptor bindresvport$descriptor() {
        return bindresvport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bindresvport(int, struct sockaddr_in *)
     * }
     */
    public static MethodHandle bindresvport$handle() {
        return bindresvport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int bindresvport(int, struct sockaddr_in *)
     * }
     */
    public static MemorySegment bindresvport$address() {
        return bindresvport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int bindresvport(int, struct sockaddr_in *)
     * }
     */
    public static int bindresvport(int x0, MemorySegment x1) {
        var mh$ = bindresvport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bindresvport", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bindresvport_sa {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("bindresvport_sa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bindresvport_sa(int, struct sockaddr *)
     * }
     */
    public static FunctionDescriptor bindresvport_sa$descriptor() {
        return bindresvport_sa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bindresvport_sa(int, struct sockaddr *)
     * }
     */
    public static MethodHandle bindresvport_sa$handle() {
        return bindresvport_sa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int bindresvport_sa(int, struct sockaddr *)
     * }
     */
    public static MemorySegment bindresvport_sa$address() {
        return bindresvport_sa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int bindresvport_sa(int, struct sockaddr *)
     * }
     */
    public static int bindresvport_sa(int x0, MemorySegment x1) {
        var mh$ = bindresvport_sa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bindresvport_sa", x0, x1);
            }
            return (int) mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint32_t tcp_seq
     * }
     */
    public static final OfInt tcp_seq = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t tcp_cc
     * }
     */
    public static final OfInt tcp_cc = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t cpu_type_t
     * }
     */
    public static final OfInt cpu_type_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t cpu_subtype_t
     * }
     */
    public static final OfInt cpu_subtype_t = proc_info_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t cpu_threadtype_t
     * }
     */
    public static final OfInt cpu_threadtype_t = proc_info_h.C_INT;

    private static class uuid_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("uuid_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_clear(uuid_t uu)
     * }
     */
    public static FunctionDescriptor uuid_clear$descriptor() {
        return uuid_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_clear(uuid_t uu)
     * }
     */
    public static MethodHandle uuid_clear$handle() {
        return uuid_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_clear(uuid_t uu)
     * }
     */
    public static MemorySegment uuid_clear$address() {
        return uuid_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_clear(uuid_t uu)
     * }
     */
    public static void uuid_clear(MemorySegment uu) {
        var mh$ = uuid_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_clear", uu);
            }
            mh$.invokeExact(uu);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_compare {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("uuid_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uuid_compare(const uuid_t uu1, const uuid_t uu2)
     * }
     */
    public static FunctionDescriptor uuid_compare$descriptor() {
        return uuid_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uuid_compare(const uuid_t uu1, const uuid_t uu2)
     * }
     */
    public static MethodHandle uuid_compare$handle() {
        return uuid_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uuid_compare(const uuid_t uu1, const uuid_t uu2)
     * }
     */
    public static MemorySegment uuid_compare$address() {
        return uuid_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uuid_compare(const uuid_t uu1, const uuid_t uu2)
     * }
     */
    public static int uuid_compare(MemorySegment uu1, MemorySegment uu2) {
        var mh$ = uuid_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_compare", uu1, uu2);
            }
            return (int) mh$.invokeExact(uu1, uu2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_copy {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.ofVoid(proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("uuid_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_copy(uuid_t dst, const uuid_t src)
     * }
     */
    public static FunctionDescriptor uuid_copy$descriptor() {
        return uuid_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_copy(uuid_t dst, const uuid_t src)
     * }
     */
    public static MethodHandle uuid_copy$handle() {
        return uuid_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_copy(uuid_t dst, const uuid_t src)
     * }
     */
    public static MemorySegment uuid_copy$address() {
        return uuid_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_copy(uuid_t dst, const uuid_t src)
     * }
     */
    public static void uuid_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = uuid_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_copy", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_generate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("uuid_generate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_generate(uuid_t out)
     * }
     */
    public static FunctionDescriptor uuid_generate$descriptor() {
        return uuid_generate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_generate(uuid_t out)
     * }
     */
    public static MethodHandle uuid_generate$handle() {
        return uuid_generate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_generate(uuid_t out)
     * }
     */
    public static MemorySegment uuid_generate$address() {
        return uuid_generate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_generate(uuid_t out)
     * }
     */
    public static void uuid_generate(MemorySegment out) {
        var mh$ = uuid_generate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_generate", out);
            }
            mh$.invokeExact(out);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_generate_random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("uuid_generate_random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_generate_random(uuid_t out)
     * }
     */
    public static FunctionDescriptor uuid_generate_random$descriptor() {
        return uuid_generate_random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_generate_random(uuid_t out)
     * }
     */
    public static MethodHandle uuid_generate_random$handle() {
        return uuid_generate_random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_generate_random(uuid_t out)
     * }
     */
    public static MemorySegment uuid_generate_random$address() {
        return uuid_generate_random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_generate_random(uuid_t out)
     * }
     */
    public static void uuid_generate_random(MemorySegment out) {
        var mh$ = uuid_generate_random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_generate_random", out);
            }
            mh$.invokeExact(out);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_generate_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("uuid_generate_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_generate_time(uuid_t out)
     * }
     */
    public static FunctionDescriptor uuid_generate_time$descriptor() {
        return uuid_generate_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_generate_time(uuid_t out)
     * }
     */
    public static MethodHandle uuid_generate_time$handle() {
        return uuid_generate_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_generate_time(uuid_t out)
     * }
     */
    public static MemorySegment uuid_generate_time$address() {
        return uuid_generate_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_generate_time(uuid_t out)
     * }
     */
    public static void uuid_generate_time(MemorySegment out) {
        var mh$ = uuid_generate_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_generate_time", out);
            }
            mh$.invokeExact(out);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_is_null {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("uuid_is_null");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uuid_is_null(const uuid_t uu)
     * }
     */
    public static FunctionDescriptor uuid_is_null$descriptor() {
        return uuid_is_null.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uuid_is_null(const uuid_t uu)
     * }
     */
    public static MethodHandle uuid_is_null$handle() {
        return uuid_is_null.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uuid_is_null(const uuid_t uu)
     * }
     */
    public static MemorySegment uuid_is_null$address() {
        return uuid_is_null.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uuid_is_null(const uuid_t uu)
     * }
     */
    public static int uuid_is_null(MemorySegment uu) {
        var mh$ = uuid_is_null.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_is_null", uu);
            }
            return (int) mh$.invokeExact(uu);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_parse {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.of(proc_info_h.C_INT, proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("uuid_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uuid_parse(const uuid_string_t in, uuid_t uu)
     * }
     */
    public static FunctionDescriptor uuid_parse$descriptor() {
        return uuid_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uuid_parse(const uuid_string_t in, uuid_t uu)
     * }
     */
    public static MethodHandle uuid_parse$handle() {
        return uuid_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uuid_parse(const uuid_string_t in, uuid_t uu)
     * }
     */
    public static MemorySegment uuid_parse$address() {
        return uuid_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uuid_parse(const uuid_string_t in, uuid_t uu)
     * }
     */
    public static int uuid_parse(MemorySegment in, MemorySegment uu) {
        var mh$ = uuid_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_parse", in, uu);
            }
            return (int) mh$.invokeExact(in, uu);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_unparse {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.ofVoid(proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("uuid_unparse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_unparse(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static FunctionDescriptor uuid_unparse$descriptor() {
        return uuid_unparse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_unparse(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static MethodHandle uuid_unparse$handle() {
        return uuid_unparse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_unparse(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static MemorySegment uuid_unparse$address() {
        return uuid_unparse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_unparse(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static void uuid_unparse(MemorySegment uu, MemorySegment out) {
        var mh$ = uuid_unparse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_unparse", uu, out);
            }
            mh$.invokeExact(uu, out);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_unparse_lower {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.ofVoid(proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("uuid_unparse_lower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_unparse_lower(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static FunctionDescriptor uuid_unparse_lower$descriptor() {
        return uuid_unparse_lower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_unparse_lower(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static MethodHandle uuid_unparse_lower$handle() {
        return uuid_unparse_lower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_unparse_lower(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static MemorySegment uuid_unparse_lower$address() {
        return uuid_unparse_lower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_unparse_lower(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static void uuid_unparse_lower(MemorySegment uu, MemorySegment out) {
        var mh$ = uuid_unparse_lower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_unparse_lower", uu, out);
            }
            mh$.invokeExact(uu, out);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uuid_unparse_upper {
        public static final FunctionDescriptor DESC =
                FunctionDescriptor.ofVoid(proc_info_h.C_POINTER, proc_info_h.C_POINTER);

        public static final MemorySegment ADDR = proc_info_h.findOrThrow("uuid_unparse_upper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static FunctionDescriptor uuid_unparse_upper$descriptor() {
        return uuid_unparse_upper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static MethodHandle uuid_unparse_upper$handle() {
        return uuid_unparse_upper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static MemorySegment uuid_unparse_upper$address() {
        return uuid_unparse_upper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
     * }
     */
    public static void uuid_unparse_upper(MemorySegment uu, MemorySegment out) {
        var mh$ = uuid_unparse_upper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uuid_unparse_upper", uu, out);
            }
            mh$.invokeExact(uu, out);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static final int SOCKINFO_GENERIC = (int) 0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_GENERIC = 0
     * }
     */
    public static int SOCKINFO_GENERIC() {
        return SOCKINFO_GENERIC;
    }

    private static final int SOCKINFO_IN = (int) 1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_IN = 1
     * }
     */
    public static int SOCKINFO_IN() {
        return SOCKINFO_IN;
    }

    private static final int SOCKINFO_TCP = (int) 2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_TCP = 2
     * }
     */
    public static int SOCKINFO_TCP() {
        return SOCKINFO_TCP;
    }

    private static final int SOCKINFO_UN = (int) 3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_UN = 3
     * }
     */
    public static int SOCKINFO_UN() {
        return SOCKINFO_UN;
    }

    private static final int SOCKINFO_NDRV = (int) 4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_NDRV = 4
     * }
     */
    public static int SOCKINFO_NDRV() {
        return SOCKINFO_NDRV;
    }

    private static final int SOCKINFO_KERN_EVENT = (int) 5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_KERN_EVENT = 5
     * }
     */
    public static int SOCKINFO_KERN_EVENT() {
        return SOCKINFO_KERN_EVENT;
    }

    private static final int SOCKINFO_KERN_CTL = (int) 6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_KERN_CTL = 6
     * }
     */
    public static int SOCKINFO_KERN_CTL() {
        return SOCKINFO_KERN_CTL;
    }

    private static final int SOCKINFO_VSOCK = (int) 7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SOCKINFO_VSOCK = 7
     * }
     */
    public static int SOCKINFO_VSOCK() {
        return SOCKINFO_VSOCK;
    }
    /**
     * {@snippet lang=c :
     * typedef uint64_t proc_info_udata_t
     * }
     */
    public static final OfLong proc_info_udata_t = proc_info_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN = proc_info_h.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }

    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }

    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }

    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }

    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }

    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }

    private static final long USER_ADDR_NULL = 0L;
    /**
     * {@snippet lang=c :
     * #define USER_ADDR_NULL 0
     * }
     */
    public static long USER_ADDR_NULL() {
        return USER_ADDR_NULL;
    }

    private static final int __DARWIN_BYTE_ORDER = (int) 1234L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_BYTE_ORDER 1234
     * }
     */
    public static int __DARWIN_BYTE_ORDER() {
        return __DARWIN_BYTE_ORDER;
    }

    private static final int LITTLE_ENDIAN = (int) 1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }

    private static final int BIG_ENDIAN = (int) 4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }

    private static final int PDP_ENDIAN = (int) 3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }

    private static final int BYTE_ORDER = (int) 1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }

    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }

    private static final int INT8_MIN = (int) -128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }

    private static final int INT16_MIN = (int) -32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }

    private static final int INT32_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }

    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }

    private static final int UINT32_MAX = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }

    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }

    private static final int INT_LEAST8_MIN = (int) -128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }

    private static final int INT_LEAST16_MIN = (int) -32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }

    private static final int INT_LEAST32_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }

    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }

    private static final int INT_LEAST8_MAX = (int) 127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }

    private static final int INT_LEAST16_MAX = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }

    private static final int INT_LEAST32_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }

    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }

    private static final int UINT_LEAST8_MAX = (int) 255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }

    private static final int UINT_LEAST16_MAX = (int) 65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }

    private static final int UINT_LEAST32_MAX = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }

    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }

    private static final int INT_FAST8_MIN = (int) -128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }

    private static final int INT_FAST16_MIN = (int) -32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }

    private static final int INT_FAST32_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }

    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }

    private static final int INT_FAST8_MAX = (int) 127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }

    private static final int INT_FAST16_MAX = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }

    private static final int INT_FAST32_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }

    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }

    private static final int UINT_FAST8_MAX = (int) 255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }

    private static final int UINT_FAST16_MAX = (int) 65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }

    private static final int UINT_FAST32_MAX = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }

    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }

    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }

    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }

    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }

    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }

    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }

    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }

    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }

    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }

    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }

    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }

    private static final int WCHAR_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }

    private static final int WCHAR_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }

    private static final int WINT_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }

    private static final int WINT_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }

    private static final int SIG_ATOMIC_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }

    private static final int SIG_ATOMIC_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }

    private static final int MAC_OS_X_VERSION_10_0 = (int) 1000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_0 1000
     * }
     */
    public static int MAC_OS_X_VERSION_10_0() {
        return MAC_OS_X_VERSION_10_0;
    }

    private static final int MAC_OS_X_VERSION_10_1 = (int) 1010L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_1 1010
     * }
     */
    public static int MAC_OS_X_VERSION_10_1() {
        return MAC_OS_X_VERSION_10_1;
    }

    private static final int MAC_OS_X_VERSION_10_2 = (int) 1020L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_2 1020
     * }
     */
    public static int MAC_OS_X_VERSION_10_2() {
        return MAC_OS_X_VERSION_10_2;
    }

    private static final int MAC_OS_X_VERSION_10_3 = (int) 1030L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_3 1030
     * }
     */
    public static int MAC_OS_X_VERSION_10_3() {
        return MAC_OS_X_VERSION_10_3;
    }

    private static final int MAC_OS_X_VERSION_10_4 = (int) 1040L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_4 1040
     * }
     */
    public static int MAC_OS_X_VERSION_10_4() {
        return MAC_OS_X_VERSION_10_4;
    }

    private static final int MAC_OS_X_VERSION_10_5 = (int) 1050L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_5 1050
     * }
     */
    public static int MAC_OS_X_VERSION_10_5() {
        return MAC_OS_X_VERSION_10_5;
    }

    private static final int MAC_OS_X_VERSION_10_6 = (int) 1060L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_6 1060
     * }
     */
    public static int MAC_OS_X_VERSION_10_6() {
        return MAC_OS_X_VERSION_10_6;
    }

    private static final int MAC_OS_X_VERSION_10_7 = (int) 1070L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_7 1070
     * }
     */
    public static int MAC_OS_X_VERSION_10_7() {
        return MAC_OS_X_VERSION_10_7;
    }

    private static final int MAC_OS_X_VERSION_10_8 = (int) 1080L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_8 1080
     * }
     */
    public static int MAC_OS_X_VERSION_10_8() {
        return MAC_OS_X_VERSION_10_8;
    }

    private static final int MAC_OS_X_VERSION_10_9 = (int) 1090L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_9 1090
     * }
     */
    public static int MAC_OS_X_VERSION_10_9() {
        return MAC_OS_X_VERSION_10_9;
    }

    private static final int MAC_OS_X_VERSION_10_10 = (int) 101000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10 101000
     * }
     */
    public static int MAC_OS_X_VERSION_10_10() {
        return MAC_OS_X_VERSION_10_10;
    }

    private static final int MAC_OS_X_VERSION_10_10_2 = (int) 101002L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_2 101002
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_2() {
        return MAC_OS_X_VERSION_10_10_2;
    }

    private static final int MAC_OS_X_VERSION_10_10_3 = (int) 101003L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_3 101003
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_3() {
        return MAC_OS_X_VERSION_10_10_3;
    }

    private static final int MAC_OS_X_VERSION_10_11 = (int) 101100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11 101100
     * }
     */
    public static int MAC_OS_X_VERSION_10_11() {
        return MAC_OS_X_VERSION_10_11;
    }

    private static final int MAC_OS_X_VERSION_10_11_2 = (int) 101102L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_2 101102
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_2() {
        return MAC_OS_X_VERSION_10_11_2;
    }

    private static final int MAC_OS_X_VERSION_10_11_3 = (int) 101103L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_3 101103
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_3() {
        return MAC_OS_X_VERSION_10_11_3;
    }

    private static final int MAC_OS_X_VERSION_10_11_4 = (int) 101104L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_4 101104
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_4() {
        return MAC_OS_X_VERSION_10_11_4;
    }

    private static final int MAC_OS_X_VERSION_10_12 = (int) 101200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12 101200
     * }
     */
    public static int MAC_OS_X_VERSION_10_12() {
        return MAC_OS_X_VERSION_10_12;
    }

    private static final int MAC_OS_X_VERSION_10_12_1 = (int) 101201L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_1 101201
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_1() {
        return MAC_OS_X_VERSION_10_12_1;
    }

    private static final int MAC_OS_X_VERSION_10_12_2 = (int) 101202L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_2 101202
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_2() {
        return MAC_OS_X_VERSION_10_12_2;
    }

    private static final int MAC_OS_X_VERSION_10_12_4 = (int) 101204L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_4 101204
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_4() {
        return MAC_OS_X_VERSION_10_12_4;
    }

    private static final int MAC_OS_X_VERSION_10_13 = (int) 101300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13 101300
     * }
     */
    public static int MAC_OS_X_VERSION_10_13() {
        return MAC_OS_X_VERSION_10_13;
    }

    private static final int MAC_OS_X_VERSION_10_13_1 = (int) 101301L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_1 101301
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_1() {
        return MAC_OS_X_VERSION_10_13_1;
    }

    private static final int MAC_OS_X_VERSION_10_13_2 = (int) 101302L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_2 101302
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_2() {
        return MAC_OS_X_VERSION_10_13_2;
    }

    private static final int MAC_OS_X_VERSION_10_13_4 = (int) 101304L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_4 101304
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_4() {
        return MAC_OS_X_VERSION_10_13_4;
    }

    private static final int MAC_OS_X_VERSION_10_14 = (int) 101400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14 101400
     * }
     */
    public static int MAC_OS_X_VERSION_10_14() {
        return MAC_OS_X_VERSION_10_14;
    }

    private static final int MAC_OS_X_VERSION_10_14_1 = (int) 101401L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_1 101401
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_1() {
        return MAC_OS_X_VERSION_10_14_1;
    }

    private static final int MAC_OS_X_VERSION_10_14_4 = (int) 101404L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_4 101404
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_4() {
        return MAC_OS_X_VERSION_10_14_4;
    }

    private static final int MAC_OS_X_VERSION_10_14_5 = (int) 101405L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_5 101405
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_5() {
        return MAC_OS_X_VERSION_10_14_5;
    }

    private static final int MAC_OS_X_VERSION_10_14_6 = (int) 101406L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_6 101406
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_6() {
        return MAC_OS_X_VERSION_10_14_6;
    }

    private static final int MAC_OS_X_VERSION_10_15 = (int) 101500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15 101500
     * }
     */
    public static int MAC_OS_X_VERSION_10_15() {
        return MAC_OS_X_VERSION_10_15;
    }

    private static final int MAC_OS_X_VERSION_10_15_1 = (int) 101501L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_1 101501
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_1() {
        return MAC_OS_X_VERSION_10_15_1;
    }

    private static final int MAC_OS_X_VERSION_10_15_4 = (int) 101504L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_4 101504
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_4() {
        return MAC_OS_X_VERSION_10_15_4;
    }

    private static final int MAC_OS_X_VERSION_10_16 = (int) 101600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_16 101600
     * }
     */
    public static int MAC_OS_X_VERSION_10_16() {
        return MAC_OS_X_VERSION_10_16;
    }

    private static final int MAC_OS_VERSION_11_0 = (int) 110000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_0 110000
     * }
     */
    public static int MAC_OS_VERSION_11_0() {
        return MAC_OS_VERSION_11_0;
    }

    private static final int MAC_OS_VERSION_11_1 = (int) 110100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_1 110100
     * }
     */
    public static int MAC_OS_VERSION_11_1() {
        return MAC_OS_VERSION_11_1;
    }

    private static final int MAC_OS_VERSION_11_3 = (int) 110300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_3 110300
     * }
     */
    public static int MAC_OS_VERSION_11_3() {
        return MAC_OS_VERSION_11_3;
    }

    private static final int MAC_OS_VERSION_11_4 = (int) 110400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_4 110400
     * }
     */
    public static int MAC_OS_VERSION_11_4() {
        return MAC_OS_VERSION_11_4;
    }

    private static final int MAC_OS_VERSION_11_5 = (int) 110500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_5 110500
     * }
     */
    public static int MAC_OS_VERSION_11_5() {
        return MAC_OS_VERSION_11_5;
    }

    private static final int MAC_OS_VERSION_11_6 = (int) 110600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_6 110600
     * }
     */
    public static int MAC_OS_VERSION_11_6() {
        return MAC_OS_VERSION_11_6;
    }

    private static final int MAC_OS_VERSION_12_0 = (int) 120000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_0 120000
     * }
     */
    public static int MAC_OS_VERSION_12_0() {
        return MAC_OS_VERSION_12_0;
    }

    private static final int MAC_OS_VERSION_12_1 = (int) 120100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_1 120100
     * }
     */
    public static int MAC_OS_VERSION_12_1() {
        return MAC_OS_VERSION_12_1;
    }

    private static final int MAC_OS_VERSION_12_2 = (int) 120200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_2 120200
     * }
     */
    public static int MAC_OS_VERSION_12_2() {
        return MAC_OS_VERSION_12_2;
    }

    private static final int MAC_OS_VERSION_12_3 = (int) 120300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_3 120300
     * }
     */
    public static int MAC_OS_VERSION_12_3() {
        return MAC_OS_VERSION_12_3;
    }

    private static final int MAC_OS_VERSION_12_4 = (int) 120400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_4 120400
     * }
     */
    public static int MAC_OS_VERSION_12_4() {
        return MAC_OS_VERSION_12_4;
    }

    private static final int MAC_OS_VERSION_12_5 = (int) 120500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_5 120500
     * }
     */
    public static int MAC_OS_VERSION_12_5() {
        return MAC_OS_VERSION_12_5;
    }

    private static final int MAC_OS_VERSION_12_6 = (int) 120600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_6 120600
     * }
     */
    public static int MAC_OS_VERSION_12_6() {
        return MAC_OS_VERSION_12_6;
    }

    private static final int MAC_OS_VERSION_12_7 = (int) 120700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_7 120700
     * }
     */
    public static int MAC_OS_VERSION_12_7() {
        return MAC_OS_VERSION_12_7;
    }

    private static final int MAC_OS_VERSION_13_0 = (int) 130000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_0 130000
     * }
     */
    public static int MAC_OS_VERSION_13_0() {
        return MAC_OS_VERSION_13_0;
    }

    private static final int MAC_OS_VERSION_13_1 = (int) 130100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_1 130100
     * }
     */
    public static int MAC_OS_VERSION_13_1() {
        return MAC_OS_VERSION_13_1;
    }

    private static final int MAC_OS_VERSION_13_2 = (int) 130200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_2 130200
     * }
     */
    public static int MAC_OS_VERSION_13_2() {
        return MAC_OS_VERSION_13_2;
    }

    private static final int MAC_OS_VERSION_13_3 = (int) 130300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_3 130300
     * }
     */
    public static int MAC_OS_VERSION_13_3() {
        return MAC_OS_VERSION_13_3;
    }

    private static final int MAC_OS_VERSION_13_4 = (int) 130400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_4 130400
     * }
     */
    public static int MAC_OS_VERSION_13_4() {
        return MAC_OS_VERSION_13_4;
    }

    private static final int MAC_OS_VERSION_13_5 = (int) 130500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_5 130500
     * }
     */
    public static int MAC_OS_VERSION_13_5() {
        return MAC_OS_VERSION_13_5;
    }

    private static final int MAC_OS_VERSION_13_6 = (int) 130600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_6 130600
     * }
     */
    public static int MAC_OS_VERSION_13_6() {
        return MAC_OS_VERSION_13_6;
    }

    private static final int MAC_OS_VERSION_14_0 = (int) 140000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_0 140000
     * }
     */
    public static int MAC_OS_VERSION_14_0() {
        return MAC_OS_VERSION_14_0;
    }

    private static final int MAC_OS_VERSION_14_1 = (int) 140100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_1 140100
     * }
     */
    public static int MAC_OS_VERSION_14_1() {
        return MAC_OS_VERSION_14_1;
    }

    private static final int MAC_OS_VERSION_14_2 = (int) 140200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_2 140200
     * }
     */
    public static int MAC_OS_VERSION_14_2() {
        return MAC_OS_VERSION_14_2;
    }

    private static final int MAC_OS_VERSION_14_3 = (int) 140300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_3 140300
     * }
     */
    public static int MAC_OS_VERSION_14_3() {
        return MAC_OS_VERSION_14_3;
    }

    private static final int MAC_OS_VERSION_14_4 = (int) 140400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_4 140400
     * }
     */
    public static int MAC_OS_VERSION_14_4() {
        return MAC_OS_VERSION_14_4;
    }

    private static final int __MAC_OS_X_VERSION_MAX_ALLOWED = (int) 140400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_OS_X_VERSION_MAX_ALLOWED 140400
     * }
     */
    public static int __MAC_OS_X_VERSION_MAX_ALLOWED() {
        return __MAC_OS_X_VERSION_MAX_ALLOWED;
    }

    private static final long __DARWIN_NFDBITS = 32L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NFDBITS 32
     * }
     */
    public static long __DARWIN_NFDBITS() {
        return __DARWIN_NFDBITS;
    }

    private static final int NBBY = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define NBBY 8
     * }
     */
    public static int NBBY() {
        return NBBY;
    }

    private static final long NFDBITS = 32L;
    /**
     * {@snippet lang=c :
     * #define NFDBITS 32
     * }
     */
    public static long NFDBITS() {
        return NFDBITS;
    }

    private static final int FD_SETSIZE = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define FD_SETSIZE 1024
     * }
     */
    public static int FD_SETSIZE() {
        return FD_SETSIZE;
    }

    private static final int ARG_MAX = (int) 1048576L;
    /**
     * {@snippet lang=c :
     * #define ARG_MAX 1048576
     * }
     */
    public static int ARG_MAX() {
        return ARG_MAX;
    }

    private static final int GID_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define GID_MAX 2147483647
     * }
     */
    public static int GID_MAX() {
        return GID_MAX;
    }

    private static final int UID_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define UID_MAX 2147483647
     * }
     */
    public static int UID_MAX() {
        return UID_MAX;
    }

    private static final int MAXUPRC = (int) 266L;
    /**
     * {@snippet lang=c :
     * #define MAXUPRC 266
     * }
     */
    public static int MAXUPRC() {
        return MAXUPRC;
    }

    private static final int NCARGS = (int) 1048576L;
    /**
     * {@snippet lang=c :
     * #define NCARGS 1048576
     * }
     */
    public static int NCARGS() {
        return NCARGS;
    }

    private static final int NGROUPS = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define NGROUPS 16
     * }
     */
    public static int NGROUPS() {
        return NGROUPS;
    }

    private static final long __DARWIN_ALIGNBYTES = 7L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ALIGNBYTES 7
     * }
     */
    public static long __DARWIN_ALIGNBYTES() {
        return __DARWIN_ALIGNBYTES;
    }

    private static final long __DARWIN_ALIGNBYTES32 = 3L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ALIGNBYTES32 3
     * }
     */
    public static long __DARWIN_ALIGNBYTES32() {
        return __DARWIN_ALIGNBYTES32;
    }

    private static final long ALIGNBYTES = 7L;
    /**
     * {@snippet lang=c :
     * #define ALIGNBYTES 7
     * }
     */
    public static long ALIGNBYTES() {
        return ALIGNBYTES;
    }

    private static final int PGOFSET = (int) 4095L;
    /**
     * {@snippet lang=c :
     * #define PGOFSET 4095
     * }
     */
    public static int PGOFSET() {
        return PGOFSET;
    }

    private static final int MAXPHYS = (int) 65536L;
    /**
     * {@snippet lang=c :
     * #define MAXPHYS 65536
     * }
     */
    public static int MAXPHYS() {
        return MAXPHYS;
    }

    private static final int MSIZE = (int) 256L;
    /**
     * {@snippet lang=c :
     * #define MSIZE 256
     * }
     */
    public static int MSIZE() {
        return MSIZE;
    }

    private static final int MCLBYTES = (int) 2048L;
    /**
     * {@snippet lang=c :
     * #define MCLBYTES 2048
     * }
     */
    public static int MCLBYTES() {
        return MCLBYTES;
    }

    private static final int MBIGCLBYTES = (int) 4096L;
    /**
     * {@snippet lang=c :
     * #define MBIGCLBYTES 4096
     * }
     */
    public static int MBIGCLBYTES() {
        return MBIGCLBYTES;
    }

    private static final int M16KCLBYTES = (int) 16384L;
    /**
     * {@snippet lang=c :
     * #define M16KCLBYTES 16384
     * }
     */
    public static int M16KCLBYTES() {
        return M16KCLBYTES;
    }

    private static final int MCLOFSET = (int) 2047L;
    /**
     * {@snippet lang=c :
     * #define MCLOFSET 2047
     * }
     */
    public static int MCLOFSET() {
        return MCLOFSET;
    }

    private static final int CLK_TCK = (int) 100L;
    /**
     * {@snippet lang=c :
     * #define CLK_TCK 100
     * }
     */
    public static int CLK_TCK() {
        return CLK_TCK;
    }

    private static final int SCHAR_MIN = (int) -128L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MIN -128
     * }
     */
    public static int SCHAR_MIN() {
        return SCHAR_MIN;
    }

    private static final int CHAR_MIN = (int) -128L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MIN -128
     * }
     */
    public static int CHAR_MIN() {
        return CHAR_MIN;
    }

    private static final int SHRT_MIN = (int) -32768L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MIN -32768
     * }
     */
    public static int SHRT_MIN() {
        return SHRT_MIN;
    }

    private static final int UINT_MAX = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_MAX 4294967295
     * }
     */
    public static int UINT_MAX() {
        return UINT_MAX;
    }

    private static final int INT_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_MIN -2147483648
     * }
     */
    public static int INT_MIN() {
        return INT_MIN;
    }

    private static final long ULONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_MAX -1
     * }
     */
    public static long ULONG_MAX() {
        return ULONG_MAX;
    }

    private static final long LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_MAX() {
        return LONG_MAX;
    }

    private static final long LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_MIN() {
        return LONG_MIN;
    }

    private static final long ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULLONG_MAX -1
     * }
     */
    public static long ULLONG_MAX() {
        return ULLONG_MAX;
    }

    private static final long LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MAX 9223372036854775807
     * }
     */
    public static long LLONG_MAX() {
        return LLONG_MAX;
    }

    private static final long LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MIN -9223372036854775808
     * }
     */
    public static long LLONG_MIN() {
        return LLONG_MIN;
    }

    private static final long SSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define SSIZE_MAX 9223372036854775807
     * }
     */
    public static long SSIZE_MAX() {
        return SSIZE_MAX;
    }

    private static final long SIZE_T_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_T_MAX -1
     * }
     */
    public static long SIZE_T_MAX() {
        return SIZE_T_MAX;
    }

    private static final long UQUAD_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UQUAD_MAX -1
     * }
     */
    public static long UQUAD_MAX() {
        return UQUAD_MAX;
    }

    private static final long QUAD_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define QUAD_MAX 9223372036854775807
     * }
     */
    public static long QUAD_MAX() {
        return QUAD_MAX;
    }

    private static final long QUAD_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define QUAD_MIN -9223372036854775808
     * }
     */
    public static long QUAD_MIN() {
        return QUAD_MIN;
    }

    private static final int _POSIX_RE_DUP_MAX = (int) 255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX_RE_DUP_MAX() {
        return _POSIX_RE_DUP_MAX;
    }

    private static final long OFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define OFF_MIN -9223372036854775808
     * }
     */
    public static long OFF_MIN() {
        return OFF_MIN;
    }

    private static final long OFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define OFF_MAX 9223372036854775807
     * }
     */
    public static long OFF_MAX() {
        return OFF_MAX;
    }

    private static final int NSIG = (int) 32L;
    /**
     * {@snippet lang=c :
     * #define NSIG 32
     * }
     */
    public static int NSIG() {
        return NSIG;
    }

    private static final int SIGIOT = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define SIGIOT 6
     * }
     */
    public static int SIGIOT() {
        return SIGIOT;
    }

    private static final MemorySegment SIG_DFL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define SIG_DFL (void*) 0
     * }
     */
    public static MemorySegment SIG_DFL() {
        return SIG_DFL;
    }

    private static final MemorySegment SIG_IGN = MemorySegment.ofAddress(1L);
    /**
     * {@snippet lang=c :
     * #define SIG_IGN (void*) 1
     * }
     */
    public static MemorySegment SIG_IGN() {
        return SIG_IGN;
    }

    private static final MemorySegment SIG_HOLD = MemorySegment.ofAddress(5L);
    /**
     * {@snippet lang=c :
     * #define SIG_HOLD (void*) 5
     * }
     */
    public static MemorySegment SIG_HOLD() {
        return SIG_HOLD;
    }

    private static final MemorySegment SIG_ERR = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define SIG_ERR (void*) -1
     * }
     */
    public static MemorySegment SIG_ERR() {
        return SIG_ERR;
    }

    private static final int SA_USERSPACE_MASK = (int) 127L;
    /**
     * {@snippet lang=c :
     * #define SA_USERSPACE_MASK 127
     * }
     */
    public static int SA_USERSPACE_MASK() {
        return SA_USERSPACE_MASK;
    }

    private static final int SV_ONSTACK = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define SV_ONSTACK 1
     * }
     */
    public static int SV_ONSTACK() {
        return SV_ONSTACK;
    }

    private static final int SV_INTERRUPT = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define SV_INTERRUPT 2
     * }
     */
    public static int SV_INTERRUPT() {
        return SV_INTERRUPT;
    }

    private static final int SV_RESETHAND = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define SV_RESETHAND 4
     * }
     */
    public static int SV_RESETHAND() {
        return SV_RESETHAND;
    }

    private static final int SV_NODEFER = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define SV_NODEFER 16
     * }
     */
    public static int SV_NODEFER() {
        return SV_NODEFER;
    }

    private static final int SV_NOCLDSTOP = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define SV_NOCLDSTOP 8
     * }
     */
    public static int SV_NOCLDSTOP() {
        return SV_NOCLDSTOP;
    }

    private static final int SV_SIGINFO = (int) 64L;
    /**
     * {@snippet lang=c :
     * #define SV_SIGINFO 64
     * }
     */
    public static int SV_SIGINFO() {
        return SV_SIGINFO;
    }

    private static final MemorySegment BADSIG = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define BADSIG (void*) -1
     * }
     */
    public static MemorySegment BADSIG() {
        return BADSIG;
    }

    private static final long NBPW = 4L;
    /**
     * {@snippet lang=c :
     * #define NBPW 4
     * }
     */
    public static long NBPW() {
        return NBPW;
    }

    private static final int NODEV = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define NODEV -1
     * }
     */
    public static int NODEV() {
        return NODEV;
    }

    private static final int CLBYTES = (int) 4096L;
    /**
     * {@snippet lang=c :
     * #define CLBYTES 4096
     * }
     */
    public static int CLBYTES() {
        return CLBYTES;
    }

    private static final int CLOFSET = (int) 4095L;
    /**
     * {@snippet lang=c :
     * #define CLOFSET 4095
     * }
     */
    public static int CLOFSET() {
        return CLOFSET;
    }

    private static final int CLOFF = (int) 4095L;
    /**
     * {@snippet lang=c :
     * #define CLOFF 4095
     * }
     */
    public static int CLOFF() {
        return CLOFF;
    }

    private static final int CLSHIFT = (int) 12L;
    /**
     * {@snippet lang=c :
     * #define CLSHIFT 12
     * }
     */
    public static int CLSHIFT() {
        return CLSHIFT;
    }

    private static final int CBQSIZE = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define CBQSIZE 8
     * }
     */
    public static int CBQSIZE() {
        return CBQSIZE;
    }

    private static final long CBSIZE = 48L;
    /**
     * {@snippet lang=c :
     * #define CBSIZE 48
     * }
     */
    public static long CBSIZE() {
        return CBSIZE;
    }

    private static final int CROUND = (int) 63L;
    /**
     * {@snippet lang=c :
     * #define CROUND 63
     * }
     */
    public static int CROUND() {
        return CROUND;
    }

    private static final int MAXBSIZE = (int) 1048576L;
    /**
     * {@snippet lang=c :
     * #define MAXBSIZE 1048576
     * }
     */
    public static int MAXBSIZE() {
        return MAXBSIZE;
    }

    private static final int MAXPHYSIO = (int) 65536L;
    /**
     * {@snippet lang=c :
     * #define MAXPHYSIO 65536
     * }
     */
    public static int MAXPHYSIO() {
        return MAXPHYSIO;
    }

    private static final int MAXPHYSIO_WIRED = (int) 16777216L;
    /**
     * {@snippet lang=c :
     * #define MAXPHYSIO_WIRED 16777216
     * }
     */
    public static int MAXPHYSIO_WIRED() {
        return MAXPHYSIO_WIRED;
    }

    private static final int MAXPATHLEN = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define MAXPATHLEN 1024
     * }
     */
    public static int MAXPATHLEN() {
        return MAXPATHLEN;
    }

    private static final int FSCALE = (int) 2048L;
    /**
     * {@snippet lang=c :
     * #define FSCALE 2048
     * }
     */
    public static int FSCALE() {
        return FSCALE;
    }

    private static final int S_ISTXT = (int) 512L;
    /**
     * {@snippet lang=c :
     * #define S_ISTXT 512
     * }
     */
    public static int S_ISTXT() {
        return S_ISTXT;
    }

    private static final int S_IREAD = (int) 256L;
    /**
     * {@snippet lang=c :
     * #define S_IREAD 256
     * }
     */
    public static int S_IREAD() {
        return S_IREAD;
    }

    private static final int S_IWRITE = (int) 128L;
    /**
     * {@snippet lang=c :
     * #define S_IWRITE 128
     * }
     */
    public static int S_IWRITE() {
        return S_IWRITE;
    }

    private static final int S_IEXEC = (int) 64L;
    /**
     * {@snippet lang=c :
     * #define S_IEXEC 64
     * }
     */
    public static int S_IEXEC() {
        return S_IEXEC;
    }

    private static final int ACCESSPERMS = (int) 511L;
    /**
     * {@snippet lang=c :
     * #define ACCESSPERMS 511
     * }
     */
    public static int ACCESSPERMS() {
        return ACCESSPERMS;
    }

    private static final int ALLPERMS = (int) 4095L;
    /**
     * {@snippet lang=c :
     * #define ALLPERMS 4095
     * }
     */
    public static int ALLPERMS() {
        return ALLPERMS;
    }

    private static final int DEFFILEMODE = (int) 438L;
    /**
     * {@snippet lang=c :
     * #define DEFFILEMODE 438
     * }
     */
    public static int DEFFILEMODE() {
        return DEFFILEMODE;
    }

    private static final int SF_SYNTHETIC = (int) 3221225472L;
    /**
     * {@snippet lang=c :
     * #define SF_SYNTHETIC 3221225472
     * }
     */
    public static int SF_SYNTHETIC() {
        return SF_SYNTHETIC;
    }

    private static final int UTIME_NOW = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define UTIME_NOW -1
     * }
     */
    public static int UTIME_NOW() {
        return UTIME_NOW;
    }

    private static final int UTIME_OMIT = (int) -2L;
    /**
     * {@snippet lang=c :
     * #define UTIME_OMIT -2
     * }
     */
    public static int UTIME_OMIT() {
        return UTIME_OMIT;
    }

    private static final int AUDIT_RECORD_MAGIC = (int) 2190085915L;
    /**
     * {@snippet lang=c :
     * #define AUDIT_RECORD_MAGIC 2190085915
     * }
     */
    public static int AUDIT_RECORD_MAGIC() {
        return AUDIT_RECORD_MAGIC;
    }

    private static final int MAXAUDITDATA = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define MAXAUDITDATA 32767
     * }
     */
    public static int MAXAUDITDATA() {
        return MAXAUDITDATA;
    }

    private static final int MAX_AUDIT_RECORD_SIZE = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define MAX_AUDIT_RECORD_SIZE 32767
     * }
     */
    public static int MAX_AUDIT_RECORD_SIZE() {
        return MAX_AUDIT_RECORD_SIZE;
    }

    private static final int MIN_AUDIT_FILE_SIZE = (int) 524288L;
    /**
     * {@snippet lang=c :
     * #define MIN_AUDIT_FILE_SIZE 524288
     * }
     */
    public static int MIN_AUDIT_FILE_SIZE() {
        return MIN_AUDIT_FILE_SIZE;
    }
    /**
     * {@snippet lang=c :
     * #define AUDITDEV_FILENAME "audit"
     * }
     */
    public static MemorySegment AUDITDEV_FILENAME() {
        class Holder {
            static final MemorySegment AUDITDEV_FILENAME = proc_info_h.LIBRARY_ARENA.allocateFrom("audit");
        }
        return Holder.AUDITDEV_FILENAME;
    }

    private static final int AU_DEFAUDITID = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define AU_DEFAUDITID 4294967295
     * }
     */
    public static int AU_DEFAUDITID() {
        return AU_DEFAUDITID;
    }

    private static final int AU_ASSIGN_ASID = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define AU_ASSIGN_ASID -1
     * }
     */
    public static int AU_ASSIGN_ASID() {
        return AU_ASSIGN_ASID;
    }

    private static final byte AT_IPC_MSG = (byte) 1L;
    /**
     * {@snippet lang=c :
     * #define AT_IPC_MSG 1
     * }
     */
    public static byte AT_IPC_MSG() {
        return AT_IPC_MSG;
    }

    private static final byte AT_IPC_SEM = (byte) 2L;
    /**
     * {@snippet lang=c :
     * #define AT_IPC_SEM 2
     * }
     */
    public static byte AT_IPC_SEM() {
        return AT_IPC_SEM;
    }

    private static final byte AT_IPC_SHM = (byte) 3L;
    /**
     * {@snippet lang=c :
     * #define AT_IPC_SHM 3
     * }
     */
    public static byte AT_IPC_SHM() {
        return AT_IPC_SHM;
    }

    private static final int AUC_DISABLED = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define AUC_DISABLED -1
     * }
     */
    public static int AUC_DISABLED() {
        return AUC_DISABLED;
    }

    private static final int AQ_BUFSZ = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define AQ_BUFSZ 32767
     * }
     */
    public static int AQ_BUFSZ() {
        return AQ_BUFSZ;
    }

    private static final byte AUDIT_CTLMODE_NORMAL = (byte) 1L;
    /**
     * {@snippet lang=c :
     * #define AUDIT_CTLMODE_NORMAL 1
     * }
     */
    public static byte AUDIT_CTLMODE_NORMAL() {
        return AUDIT_CTLMODE_NORMAL;
    }

    private static final byte AUDIT_CTLMODE_EXTERNAL = (byte) 2L;
    /**
     * {@snippet lang=c :
     * #define AUDIT_CTLMODE_EXTERNAL 2
     * }
     */
    public static byte AUDIT_CTLMODE_EXTERNAL() {
        return AUDIT_CTLMODE_EXTERNAL;
    }

    private static final byte AUDIT_EXPIRE_OP_AND = (byte) 0L;
    /**
     * {@snippet lang=c :
     * #define AUDIT_EXPIRE_OP_AND 0
     * }
     */
    public static byte AUDIT_EXPIRE_OP_AND() {
        return AUDIT_EXPIRE_OP_AND;
    }

    private static final byte AUDIT_EXPIRE_OP_OR = (byte) 1L;
    /**
     * {@snippet lang=c :
     * #define AUDIT_EXPIRE_OP_OR 1
     * }
     */
    public static byte AUDIT_EXPIRE_OP_OR() {
        return AUDIT_EXPIRE_OP_OR;
    }

    private static final int MACH_PORT_DEAD = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_DEAD 4294967295
     * }
     */
    public static int MACH_PORT_DEAD() {
        return MACH_PORT_DEAD;
    }

    private static final int MACH_PORT_RIGHT_SEND = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_SEND 0
     * }
     */
    public static int MACH_PORT_RIGHT_SEND() {
        return MACH_PORT_RIGHT_SEND;
    }

    private static final int MACH_PORT_RIGHT_RECEIVE = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_RECEIVE 1
     * }
     */
    public static int MACH_PORT_RIGHT_RECEIVE() {
        return MACH_PORT_RIGHT_RECEIVE;
    }

    private static final int MACH_PORT_RIGHT_SEND_ONCE = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_SEND_ONCE 2
     * }
     */
    public static int MACH_PORT_RIGHT_SEND_ONCE() {
        return MACH_PORT_RIGHT_SEND_ONCE;
    }

    private static final int MACH_PORT_RIGHT_PORT_SET = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_PORT_SET 3
     * }
     */
    public static int MACH_PORT_RIGHT_PORT_SET() {
        return MACH_PORT_RIGHT_PORT_SET;
    }

    private static final int MACH_PORT_RIGHT_DEAD_NAME = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_DEAD_NAME 4
     * }
     */
    public static int MACH_PORT_RIGHT_DEAD_NAME() {
        return MACH_PORT_RIGHT_DEAD_NAME;
    }

    private static final int MACH_PORT_RIGHT_LABELH = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_LABELH 5
     * }
     */
    public static int MACH_PORT_RIGHT_LABELH() {
        return MACH_PORT_RIGHT_LABELH;
    }

    private static final int MACH_PORT_RIGHT_NUMBER = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_NUMBER 6
     * }
     */
    public static int MACH_PORT_RIGHT_NUMBER() {
        return MACH_PORT_RIGHT_NUMBER;
    }

    private static final int MACH_PORT_TYPE_NONE = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_NONE 0
     * }
     */
    public static int MACH_PORT_TYPE_NONE() {
        return MACH_PORT_TYPE_NONE;
    }

    private static final int MACH_PORT_TYPE_SEND = (int) 65536L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND 65536
     * }
     */
    public static int MACH_PORT_TYPE_SEND() {
        return MACH_PORT_TYPE_SEND;
    }

    private static final int MACH_PORT_TYPE_RECEIVE = (int) 131072L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_RECEIVE 131072
     * }
     */
    public static int MACH_PORT_TYPE_RECEIVE() {
        return MACH_PORT_TYPE_RECEIVE;
    }

    private static final int MACH_PORT_TYPE_SEND_ONCE = (int) 262144L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND_ONCE 262144
     * }
     */
    public static int MACH_PORT_TYPE_SEND_ONCE() {
        return MACH_PORT_TYPE_SEND_ONCE;
    }

    private static final int MACH_PORT_TYPE_PORT_SET = (int) 524288L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_PORT_SET 524288
     * }
     */
    public static int MACH_PORT_TYPE_PORT_SET() {
        return MACH_PORT_TYPE_PORT_SET;
    }

    private static final int MACH_PORT_TYPE_DEAD_NAME = (int) 1048576L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_DEAD_NAME 1048576
     * }
     */
    public static int MACH_PORT_TYPE_DEAD_NAME() {
        return MACH_PORT_TYPE_DEAD_NAME;
    }

    private static final int MACH_PORT_TYPE_LABELH = (int) 2097152L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_LABELH 2097152
     * }
     */
    public static int MACH_PORT_TYPE_LABELH() {
        return MACH_PORT_TYPE_LABELH;
    }

    private static final int MACH_PORT_TYPE_SEND_RECEIVE = (int) 196608L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND_RECEIVE 196608
     * }
     */
    public static int MACH_PORT_TYPE_SEND_RECEIVE() {
        return MACH_PORT_TYPE_SEND_RECEIVE;
    }

    private static final int MACH_PORT_TYPE_SEND_RIGHTS = (int) 327680L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND_RIGHTS 327680
     * }
     */
    public static int MACH_PORT_TYPE_SEND_RIGHTS() {
        return MACH_PORT_TYPE_SEND_RIGHTS;
    }

    private static final int MACH_PORT_TYPE_PORT_RIGHTS = (int) 458752L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_PORT_RIGHTS 458752
     * }
     */
    public static int MACH_PORT_TYPE_PORT_RIGHTS() {
        return MACH_PORT_TYPE_PORT_RIGHTS;
    }

    private static final int MACH_PORT_TYPE_PORT_OR_DEAD = (int) 1507328L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_PORT_OR_DEAD 1507328
     * }
     */
    public static int MACH_PORT_TYPE_PORT_OR_DEAD() {
        return MACH_PORT_TYPE_PORT_OR_DEAD;
    }

    private static final int MACH_PORT_TYPE_ALL_RIGHTS = (int) 2031616L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_ALL_RIGHTS 2031616
     * }
     */
    public static int MACH_PORT_TYPE_ALL_RIGHTS() {
        return MACH_PORT_TYPE_ALL_RIGHTS;
    }

    private static final int MACH_PORT_TYPE_DNREQUEST = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_DNREQUEST 2147483648
     * }
     */
    public static int MACH_PORT_TYPE_DNREQUEST() {
        return MACH_PORT_TYPE_DNREQUEST;
    }

    private static final int MACH_PORT_QLIMIT_ZERO = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_ZERO 0
     * }
     */
    public static int MACH_PORT_QLIMIT_ZERO() {
        return MACH_PORT_QLIMIT_ZERO;
    }

    private static final int MACH_PORT_QLIMIT_BASIC = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_BASIC 5
     * }
     */
    public static int MACH_PORT_QLIMIT_BASIC() {
        return MACH_PORT_QLIMIT_BASIC;
    }

    private static final int MACH_PORT_QLIMIT_SMALL = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_SMALL 16
     * }
     */
    public static int MACH_PORT_QLIMIT_SMALL() {
        return MACH_PORT_QLIMIT_SMALL;
    }

    private static final int MACH_PORT_QLIMIT_LARGE = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_LARGE 1024
     * }
     */
    public static int MACH_PORT_QLIMIT_LARGE() {
        return MACH_PORT_QLIMIT_LARGE;
    }

    private static final int MACH_PORT_QLIMIT_KERNEL = (int) 65534L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_KERNEL 65534
     * }
     */
    public static int MACH_PORT_QLIMIT_KERNEL() {
        return MACH_PORT_QLIMIT_KERNEL;
    }

    private static final int MACH_PORT_QLIMIT_MIN = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_MIN 0
     * }
     */
    public static int MACH_PORT_QLIMIT_MIN() {
        return MACH_PORT_QLIMIT_MIN;
    }

    private static final int MACH_PORT_QLIMIT_DEFAULT = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_DEFAULT 5
     * }
     */
    public static int MACH_PORT_QLIMIT_DEFAULT() {
        return MACH_PORT_QLIMIT_DEFAULT;
    }

    private static final int MACH_PORT_QLIMIT_MAX = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_MAX 1024
     * }
     */
    public static int MACH_PORT_QLIMIT_MAX() {
        return MACH_PORT_QLIMIT_MAX;
    }

    private static final int MACH_PORT_LIMITS_INFO_COUNT = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_LIMITS_INFO_COUNT 1
     * }
     */
    public static int MACH_PORT_LIMITS_INFO_COUNT() {
        return MACH_PORT_LIMITS_INFO_COUNT;
    }

    private static final int MACH_PORT_RECEIVE_STATUS_COUNT = (int) 10L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RECEIVE_STATUS_COUNT 10
     * }
     */
    public static int MACH_PORT_RECEIVE_STATUS_COUNT() {
        return MACH_PORT_RECEIVE_STATUS_COUNT;
    }

    private static final int MACH_PORT_INFO_EXT_COUNT = (int) 17L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_INFO_EXT_COUNT 17
     * }
     */
    public static int MACH_PORT_INFO_EXT_COUNT() {
        return MACH_PORT_INFO_EXT_COUNT;
    }

    private static final int MACH_PORT_GUARD_INFO_COUNT = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_GUARD_INFO_COUNT 2
     * }
     */
    public static int MACH_PORT_GUARD_INFO_COUNT() {
        return MACH_PORT_GUARD_INFO_COUNT;
    }

    private static final byte MACH_SERVICE_PORT_INFO_COUNT = (byte) 0L;
    /**
     * {@snippet lang=c :
     * #define MACH_SERVICE_PORT_INFO_COUNT 0
     * }
     */
    public static byte MACH_SERVICE_PORT_INFO_COUNT() {
        return MACH_SERVICE_PORT_INFO_COUNT;
    }

    private static final int MAX_FATAL_kGUARD_EXC_CODE = (int) 128L;
    /**
     * {@snippet lang=c :
     * #define MAX_FATAL_kGUARD_EXC_CODE 128
     * }
     */
    public static int MAX_FATAL_kGUARD_EXC_CODE() {
        return MAX_FATAL_kGUARD_EXC_CODE;
    }

    private static final long MPG_FLAGS_NONE = 0L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_NONE 0
     * }
     */
    public static long MPG_FLAGS_NONE() {
        return MPG_FLAGS_NONE;
    }

    private static final int MAX_OPTIONAL_kGUARD_EXC_CODE = (int) 524288L;
    /**
     * {@snippet lang=c :
     * #define MAX_OPTIONAL_kGUARD_EXC_CODE 524288
     * }
     */
    public static int MAX_OPTIONAL_kGUARD_EXC_CODE() {
        return MAX_OPTIONAL_kGUARD_EXC_CODE;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP = 72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP 72057594037927936
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP() {
        return MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT = 144115188075855872L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT 144115188075855872
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT() {
        return MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER = 288230376151711744L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER 288230376151711744
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER() {
        return MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR = 576460752303423488L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR 576460752303423488
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR() {
        return MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA = 1152921504606846976L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA 1152921504606846976
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA() {
        return MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA;
    }

    private static final long MPG_FLAGS_STRICT_REPLY_MASK = -72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_MASK -72057594037927936
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_MASK() {
        return MPG_FLAGS_STRICT_REPLY_MASK;
    }

    private static final long MPG_FLAGS_MOD_REFS_PINNED_DEALLOC = 72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_MOD_REFS_PINNED_DEALLOC 72057594037927936
     * }
     */
    public static long MPG_FLAGS_MOD_REFS_PINNED_DEALLOC() {
        return MPG_FLAGS_MOD_REFS_PINNED_DEALLOC;
    }

    private static final long MPG_FLAGS_MOD_REFS_PINNED_DESTROY = 144115188075855872L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_MOD_REFS_PINNED_DESTROY 144115188075855872
     * }
     */
    public static long MPG_FLAGS_MOD_REFS_PINNED_DESTROY() {
        return MPG_FLAGS_MOD_REFS_PINNED_DESTROY;
    }

    private static final long MPG_FLAGS_MOD_REFS_PINNED_COPYIN = 288230376151711744L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_MOD_REFS_PINNED_COPYIN 288230376151711744
     * }
     */
    public static long MPG_FLAGS_MOD_REFS_PINNED_COPYIN() {
        return MPG_FLAGS_MOD_REFS_PINNED_COPYIN;
    }

    private static final long MPG_FLAGS_IMMOVABLE_PINNED = 72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_IMMOVABLE_PINNED 72057594037927936
     * }
     */
    public static long MPG_FLAGS_IMMOVABLE_PINNED() {
        return MPG_FLAGS_IMMOVABLE_PINNED;
    }

    private static final MemorySegment NOCRED = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NOCRED (void*) 0
     * }
     */
    public static MemorySegment NOCRED() {
        return NOCRED;
    }

    private static final MemorySegment FSCRED = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define FSCRED (void*) -1
     * }
     */
    public static MemorySegment FSCRED() {
        return FSCRED;
    }

    private static final int __DARWIN_WCHAR_MAX = (int) 2147483647L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MAX 2147483647
     * }
     */
    public static int __DARWIN_WCHAR_MAX() {
        return __DARWIN_WCHAR_MAX;
    }

    private static final int __DARWIN_WCHAR_MIN = (int) -2147483648L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MIN -2147483648
     * }
     */
    public static int __DARWIN_WCHAR_MIN() {
        return __DARWIN_WCHAR_MIN;
    }

    private static final int __DARWIN_WEOF = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WEOF -1
     * }
     */
    public static int __DARWIN_WEOF() {
        return __DARWIN_WEOF;
    }

    private static final long CLOCKS_PER_SEC = 1000000L;
    /**
     * {@snippet lang=c :
     * #define CLOCKS_PER_SEC 1000000
     * }
     */
    public static long CLOCKS_PER_SEC() {
        return CLOCKS_PER_SEC;
    }

    private static final int CLOCK_REALTIME = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME 0
     * }
     */
    public static int CLOCK_REALTIME() {
        return CLOCK_REALTIME;
    }

    private static final int CLOCK_MONOTONIC = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC 6
     * }
     */
    public static int CLOCK_MONOTONIC() {
        return CLOCK_MONOTONIC;
    }

    private static final int CLOCK_MONOTONIC_RAW = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_RAW 4
     * }
     */
    public static int CLOCK_MONOTONIC_RAW() {
        return CLOCK_MONOTONIC_RAW;
    }

    private static final int CLOCK_MONOTONIC_RAW_APPROX = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_RAW_APPROX 5
     * }
     */
    public static int CLOCK_MONOTONIC_RAW_APPROX() {
        return CLOCK_MONOTONIC_RAW_APPROX;
    }

    private static final int CLOCK_UPTIME_RAW = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_UPTIME_RAW 8
     * }
     */
    public static int CLOCK_UPTIME_RAW() {
        return CLOCK_UPTIME_RAW;
    }

    private static final int CLOCK_UPTIME_RAW_APPROX = (int) 9L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_UPTIME_RAW_APPROX 9
     * }
     */
    public static int CLOCK_UPTIME_RAW_APPROX() {
        return CLOCK_UPTIME_RAW_APPROX;
    }

    private static final int CLOCK_PROCESS_CPUTIME_ID = (int) 12L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_PROCESS_CPUTIME_ID 12
     * }
     */
    public static int CLOCK_PROCESS_CPUTIME_ID() {
        return CLOCK_PROCESS_CPUTIME_ID;
    }

    private static final int CLOCK_THREAD_CPUTIME_ID = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_THREAD_CPUTIME_ID 16
     * }
     */
    public static int CLOCK_THREAD_CPUTIME_ID() {
        return CLOCK_THREAD_CPUTIME_ID;
    }

    private static final int ATTR_CMN_RETURNED_ATTRS = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define ATTR_CMN_RETURNED_ATTRS 2147483648
     * }
     */
    public static int ATTR_CMN_RETURNED_ATTRS() {
        return ATTR_CMN_RETURNED_ATTRS;
    }

    private static final int ATTR_CMN_VALIDMASK = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define ATTR_CMN_VALIDMASK 4294967295
     * }
     */
    public static int ATTR_CMN_VALIDMASK() {
        return ATTR_CMN_VALIDMASK;
    }

    private static final int ATTR_VOL_INFO = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define ATTR_VOL_INFO 2147483648
     * }
     */
    public static int ATTR_VOL_INFO() {
        return ATTR_VOL_INFO;
    }

    private static final int ATTR_VOL_VALIDMASK = (int) 4038590463L;
    /**
     * {@snippet lang=c :
     * #define ATTR_VOL_VALIDMASK 4038590463
     * }
     */
    public static int ATTR_VOL_VALIDMASK() {
        return ATTR_VOL_VALIDMASK;
    }

    private static final int ATTR_VOL_SETMASK = (int) 2147491840L;
    /**
     * {@snippet lang=c :
     * #define ATTR_VOL_SETMASK 2147491840
     * }
     */
    public static int ATTR_VOL_SETMASK() {
        return ATTR_VOL_SETMASK;
    }

    private static final int ATTR_FORK_RESERVED = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define ATTR_FORK_RESERVED 4294967295
     * }
     */
    public static int ATTR_FORK_RESERVED() {
        return ATTR_FORK_RESERVED;
    }

    private static final int ATTR_BULK_REQUIRED = (int) 2147483649L;
    /**
     * {@snippet lang=c :
     * #define ATTR_BULK_REQUIRED 2147483649
     * }
     */
    public static int ATTR_BULK_REQUIRED() {
        return ATTR_BULK_REQUIRED;
    }

    private static final int SRCHFS_NEGATEPARAMS = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define SRCHFS_NEGATEPARAMS 2147483648
     * }
     */
    public static int SRCHFS_NEGATEPARAMS() {
        return SRCHFS_NEGATEPARAMS;
    }

    private static final int SRCHFS_VALIDOPTIONSMASK = (int) 2147483903L;
    /**
     * {@snippet lang=c :
     * #define SRCHFS_VALIDOPTIONSMASK 2147483903
     * }
     */
    public static int SRCHFS_VALIDOPTIONSMASK() {
        return SRCHFS_VALIDOPTIONSMASK;
    }

    private static final int FST_EOF = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define FST_EOF -1
     * }
     */
    public static int FST_EOF() {
        return FST_EOF;
    }

    private static final int MNAMELEN = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define MNAMELEN 1024
     * }
     */
    public static int MNAMELEN() {
        return MNAMELEN;
    }

    private static final int MNT_STRICTATIME = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define MNT_STRICTATIME 2147483648
     * }
     */
    public static int MNT_STRICTATIME() {
        return MNT_STRICTATIME;
    }

    private static final int MNT_UNKNOWNPERMISSIONS = (int) 2097152L;
    /**
     * {@snippet lang=c :
     * #define MNT_UNKNOWNPERMISSIONS 2097152
     * }
     */
    public static int MNT_UNKNOWNPERMISSIONS() {
        return MNT_UNKNOWNPERMISSIONS;
    }

    private static final int MNT_VISFLAGMASK = (int) 3757111295L;
    /**
     * {@snippet lang=c :
     * #define MNT_VISFLAGMASK 3757111295
     * }
     */
    public static int MNT_VISFLAGMASK() {
        return MNT_VISFLAGMASK;
    }

    private static final int MNT_CMDFLAGS = (int) 983040L;
    /**
     * {@snippet lang=c :
     * #define MNT_CMDFLAGS 983040
     * }
     */
    public static int MNT_CMDFLAGS() {
        return MNT_CMDFLAGS;
    }

    private static final int VFS_CTL_STATFS = (int) 65547L;
    /**
     * {@snippet lang=c :
     * #define VFS_CTL_STATFS 65547
     * }
     */
    public static int VFS_CTL_STATFS() {
        return VFS_CTL_STATFS;
    }

    private static final int NFS_MAX_FH_SIZE = (int) 128L;
    /**
     * {@snippet lang=c :
     * #define NFS_MAX_FH_SIZE 128
     * }
     */
    public static int NFS_MAX_FH_SIZE() {
        return NFS_MAX_FH_SIZE;
    }

    private static final int KEV_DL_MASTER_ELECTED = (int) 23L;
    /**
     * {@snippet lang=c :
     * #define KEV_DL_MASTER_ELECTED 23
     * }
     */
    public static int KEV_DL_MASTER_ELECTED() {
        return KEV_DL_MASTER_ELECTED;
    }

    private static final int SAE_ASSOCID_ALL = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define SAE_ASSOCID_ALL 4294967295
     * }
     */
    public static int SAE_ASSOCID_ALL() {
        return SAE_ASSOCID_ALL;
    }

    private static final int SAE_CONNID_ALL = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define SAE_CONNID_ALL 4294967295
     * }
     */
    public static int SAE_CONNID_ALL() {
        return SAE_CONNID_ALL;
    }

    private static final int AF_LOCAL = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define AF_LOCAL 1
     * }
     */
    public static int AF_LOCAL() {
        return AF_LOCAL;
    }

    private static final int AF_OSI = (int) 7L;
    /**
     * {@snippet lang=c :
     * #define AF_OSI 7
     * }
     */
    public static int AF_OSI() {
        return AF_OSI;
    }

    private static final int AF_E164 = (int) 28L;
    /**
     * {@snippet lang=c :
     * #define AF_E164 28
     * }
     */
    public static int AF_E164() {
        return AF_E164;
    }

    private static final long _SS_ALIGNSIZE = 8L;
    /**
     * {@snippet lang=c :
     * #define _SS_ALIGNSIZE 8
     * }
     */
    public static long _SS_ALIGNSIZE() {
        return _SS_ALIGNSIZE;
    }

    private static final long _SS_PAD1SIZE = 6L;
    /**
     * {@snippet lang=c :
     * #define _SS_PAD1SIZE 6
     * }
     */
    public static long _SS_PAD1SIZE() {
        return _SS_PAD1SIZE;
    }

    private static final long _SS_PAD2SIZE = 112L;
    /**
     * {@snippet lang=c :
     * #define _SS_PAD2SIZE 112
     * }
     */
    public static long _SS_PAD2SIZE() {
        return _SS_PAD2SIZE;
    }

    private static final int PF_UNSPEC = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define PF_UNSPEC 0
     * }
     */
    public static int PF_UNSPEC() {
        return PF_UNSPEC;
    }

    private static final int PF_LOCAL = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PF_LOCAL 1
     * }
     */
    public static int PF_LOCAL() {
        return PF_LOCAL;
    }

    private static final int PF_UNIX = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PF_UNIX 1
     * }
     */
    public static int PF_UNIX() {
        return PF_UNIX;
    }

    private static final int PF_INET = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PF_INET 2
     * }
     */
    public static int PF_INET() {
        return PF_INET;
    }

    private static final int PF_IMPLINK = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define PF_IMPLINK 3
     * }
     */
    public static int PF_IMPLINK() {
        return PF_IMPLINK;
    }

    private static final int PF_PUP = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define PF_PUP 4
     * }
     */
    public static int PF_PUP() {
        return PF_PUP;
    }

    private static final int PF_CHAOS = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define PF_CHAOS 5
     * }
     */
    public static int PF_CHAOS() {
        return PF_CHAOS;
    }

    private static final int PF_NS = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define PF_NS 6
     * }
     */
    public static int PF_NS() {
        return PF_NS;
    }

    private static final int PF_ISO = (int) 7L;
    /**
     * {@snippet lang=c :
     * #define PF_ISO 7
     * }
     */
    public static int PF_ISO() {
        return PF_ISO;
    }

    private static final int PF_OSI = (int) 7L;
    /**
     * {@snippet lang=c :
     * #define PF_OSI 7
     * }
     */
    public static int PF_OSI() {
        return PF_OSI;
    }

    private static final int PF_ECMA = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define PF_ECMA 8
     * }
     */
    public static int PF_ECMA() {
        return PF_ECMA;
    }

    private static final int PF_DATAKIT = (int) 9L;
    /**
     * {@snippet lang=c :
     * #define PF_DATAKIT 9
     * }
     */
    public static int PF_DATAKIT() {
        return PF_DATAKIT;
    }

    private static final int PF_CCITT = (int) 10L;
    /**
     * {@snippet lang=c :
     * #define PF_CCITT 10
     * }
     */
    public static int PF_CCITT() {
        return PF_CCITT;
    }

    private static final int PF_SNA = (int) 11L;
    /**
     * {@snippet lang=c :
     * #define PF_SNA 11
     * }
     */
    public static int PF_SNA() {
        return PF_SNA;
    }

    private static final int PF_DECnet = (int) 12L;
    /**
     * {@snippet lang=c :
     * #define PF_DECnet 12
     * }
     */
    public static int PF_DECnet() {
        return PF_DECnet;
    }

    private static final int PF_DLI = (int) 13L;
    /**
     * {@snippet lang=c :
     * #define PF_DLI 13
     * }
     */
    public static int PF_DLI() {
        return PF_DLI;
    }

    private static final int PF_LAT = (int) 14L;
    /**
     * {@snippet lang=c :
     * #define PF_LAT 14
     * }
     */
    public static int PF_LAT() {
        return PF_LAT;
    }

    private static final int PF_HYLINK = (int) 15L;
    /**
     * {@snippet lang=c :
     * #define PF_HYLINK 15
     * }
     */
    public static int PF_HYLINK() {
        return PF_HYLINK;
    }

    private static final int PF_APPLETALK = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define PF_APPLETALK 16
     * }
     */
    public static int PF_APPLETALK() {
        return PF_APPLETALK;
    }

    private static final int PF_ROUTE = (int) 17L;
    /**
     * {@snippet lang=c :
     * #define PF_ROUTE 17
     * }
     */
    public static int PF_ROUTE() {
        return PF_ROUTE;
    }

    private static final int PF_LINK = (int) 18L;
    /**
     * {@snippet lang=c :
     * #define PF_LINK 18
     * }
     */
    public static int PF_LINK() {
        return PF_LINK;
    }

    private static final int PF_XTP = (int) 19L;
    /**
     * {@snippet lang=c :
     * #define PF_XTP 19
     * }
     */
    public static int PF_XTP() {
        return PF_XTP;
    }

    private static final int PF_COIP = (int) 20L;
    /**
     * {@snippet lang=c :
     * #define PF_COIP 20
     * }
     */
    public static int PF_COIP() {
        return PF_COIP;
    }

    private static final int PF_CNT = (int) 21L;
    /**
     * {@snippet lang=c :
     * #define PF_CNT 21
     * }
     */
    public static int PF_CNT() {
        return PF_CNT;
    }

    private static final int PF_SIP = (int) 24L;
    /**
     * {@snippet lang=c :
     * #define PF_SIP 24
     * }
     */
    public static int PF_SIP() {
        return PF_SIP;
    }

    private static final int PF_IPX = (int) 23L;
    /**
     * {@snippet lang=c :
     * #define PF_IPX 23
     * }
     */
    public static int PF_IPX() {
        return PF_IPX;
    }

    private static final int PF_RTIP = (int) 22L;
    /**
     * {@snippet lang=c :
     * #define PF_RTIP 22
     * }
     */
    public static int PF_RTIP() {
        return PF_RTIP;
    }

    private static final int PF_PIP = (int) 25L;
    /**
     * {@snippet lang=c :
     * #define PF_PIP 25
     * }
     */
    public static int PF_PIP() {
        return PF_PIP;
    }

    private static final int PF_NDRV = (int) 27L;
    /**
     * {@snippet lang=c :
     * #define PF_NDRV 27
     * }
     */
    public static int PF_NDRV() {
        return PF_NDRV;
    }

    private static final int PF_ISDN = (int) 28L;
    /**
     * {@snippet lang=c :
     * #define PF_ISDN 28
     * }
     */
    public static int PF_ISDN() {
        return PF_ISDN;
    }

    private static final int PF_KEY = (int) 29L;
    /**
     * {@snippet lang=c :
     * #define PF_KEY 29
     * }
     */
    public static int PF_KEY() {
        return PF_KEY;
    }

    private static final int PF_INET6 = (int) 30L;
    /**
     * {@snippet lang=c :
     * #define PF_INET6 30
     * }
     */
    public static int PF_INET6() {
        return PF_INET6;
    }

    private static final int PF_NATM = (int) 31L;
    /**
     * {@snippet lang=c :
     * #define PF_NATM 31
     * }
     */
    public static int PF_NATM() {
        return PF_NATM;
    }

    private static final int PF_SYSTEM = (int) 32L;
    /**
     * {@snippet lang=c :
     * #define PF_SYSTEM 32
     * }
     */
    public static int PF_SYSTEM() {
        return PF_SYSTEM;
    }

    private static final int PF_NETBIOS = (int) 33L;
    /**
     * {@snippet lang=c :
     * #define PF_NETBIOS 33
     * }
     */
    public static int PF_NETBIOS() {
        return PF_NETBIOS;
    }

    private static final int PF_PPP = (int) 34L;
    /**
     * {@snippet lang=c :
     * #define PF_PPP 34
     * }
     */
    public static int PF_PPP() {
        return PF_PPP;
    }

    private static final int PF_RESERVED_36 = (int) 36L;
    /**
     * {@snippet lang=c :
     * #define PF_RESERVED_36 36
     * }
     */
    public static int PF_RESERVED_36() {
        return PF_RESERVED_36;
    }

    private static final int PF_UTUN = (int) 38L;
    /**
     * {@snippet lang=c :
     * #define PF_UTUN 38
     * }
     */
    public static int PF_UTUN() {
        return PF_UTUN;
    }

    private static final int PF_VSOCK = (int) 40L;
    /**
     * {@snippet lang=c :
     * #define PF_VSOCK 40
     * }
     */
    public static int PF_VSOCK() {
        return PF_VSOCK;
    }

    private static final int PF_MAX = (int) 41L;
    /**
     * {@snippet lang=c :
     * #define PF_MAX 41
     * }
     */
    public static int PF_MAX() {
        return PF_MAX;
    }

    private static final int PF_VLAN = (int) 1986814318L;
    /**
     * {@snippet lang=c :
     * #define PF_VLAN 1986814318
     * }
     */
    public static int PF_VLAN() {
        return PF_VLAN;
    }

    private static final int PF_BOND = (int) 1651469924L;
    /**
     * {@snippet lang=c :
     * #define PF_BOND 1651469924
     * }
     */
    public static int PF_BOND() {
        return PF_BOND;
    }

    private static final int NET_MAXID = (int) 41L;
    /**
     * {@snippet lang=c :
     * #define NET_MAXID 41
     * }
     */
    public static int NET_MAXID() {
        return NET_MAXID;
    }

    private static final int EVFILT_READ = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_READ -1
     * }
     */
    public static int EVFILT_READ() {
        return EVFILT_READ;
    }

    private static final int EVFILT_WRITE = (int) -2L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_WRITE -2
     * }
     */
    public static int EVFILT_WRITE() {
        return EVFILT_WRITE;
    }

    private static final int EVFILT_AIO = (int) -3L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_AIO -3
     * }
     */
    public static int EVFILT_AIO() {
        return EVFILT_AIO;
    }

    private static final int EVFILT_VNODE = (int) -4L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_VNODE -4
     * }
     */
    public static int EVFILT_VNODE() {
        return EVFILT_VNODE;
    }

    private static final int EVFILT_PROC = (int) -5L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_PROC -5
     * }
     */
    public static int EVFILT_PROC() {
        return EVFILT_PROC;
    }

    private static final int EVFILT_SIGNAL = (int) -6L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_SIGNAL -6
     * }
     */
    public static int EVFILT_SIGNAL() {
        return EVFILT_SIGNAL;
    }

    private static final int EVFILT_TIMER = (int) -7L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_TIMER -7
     * }
     */
    public static int EVFILT_TIMER() {
        return EVFILT_TIMER;
    }

    private static final int EVFILT_MACHPORT = (int) -8L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_MACHPORT -8
     * }
     */
    public static int EVFILT_MACHPORT() {
        return EVFILT_MACHPORT;
    }

    private static final int EVFILT_FS = (int) -9L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_FS -9
     * }
     */
    public static int EVFILT_FS() {
        return EVFILT_FS;
    }

    private static final int EVFILT_USER = (int) -10L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_USER -10
     * }
     */
    public static int EVFILT_USER() {
        return EVFILT_USER;
    }

    private static final int EVFILT_VM = (int) -12L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_VM -12
     * }
     */
    public static int EVFILT_VM() {
        return EVFILT_VM;
    }

    private static final int EVFILT_EXCEPT = (int) -15L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_EXCEPT -15
     * }
     */
    public static int EVFILT_EXCEPT() {
        return EVFILT_EXCEPT;
    }

    private static final int EVFILT_THREADMARKER = (int) 18L;
    /**
     * {@snippet lang=c :
     * #define EVFILT_THREADMARKER 18
     * }
     */
    public static int EVFILT_THREADMARKER() {
        return EVFILT_THREADMARKER;
    }

    private static final int EV_DISPATCH2 = (int) 384L;
    /**
     * {@snippet lang=c :
     * #define EV_DISPATCH2 384
     * }
     */
    public static int EV_DISPATCH2() {
        return EV_DISPATCH2;
    }

    private static final int EV_POLL = (int) 4096L;
    /**
     * {@snippet lang=c :
     * #define EV_POLL 4096
     * }
     */
    public static int EV_POLL() {
        return EV_POLL;
    }

    private static final int EV_OOBAND = (int) 8192L;
    /**
     * {@snippet lang=c :
     * #define EV_OOBAND 8192
     * }
     */
    public static int EV_OOBAND() {
        return EV_OOBAND;
    }

    private static final int NOTE_FFOR = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define NOTE_FFOR 2147483648
     * }
     */
    public static int NOTE_FFOR() {
        return NOTE_FFOR;
    }

    private static final int NOTE_FFCOPY = (int) 3221225472L;
    /**
     * {@snippet lang=c :
     * #define NOTE_FFCOPY 3221225472
     * }
     */
    public static int NOTE_FFCOPY() {
        return NOTE_FFCOPY;
    }

    private static final int NOTE_FFCTRLMASK = (int) 3221225472L;
    /**
     * {@snippet lang=c :
     * #define NOTE_FFCTRLMASK 3221225472
     * }
     */
    public static int NOTE_FFCTRLMASK() {
        return NOTE_FFCTRLMASK;
    }

    private static final int NOTE_EXIT = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define NOTE_EXIT 2147483648
     * }
     */
    public static int NOTE_EXIT() {
        return NOTE_EXIT;
    }

    private static final int NOTE_REAP = (int) 268435456L;
    /**
     * {@snippet lang=c :
     * #define NOTE_REAP 268435456
     * }
     */
    public static int NOTE_REAP() {
        return NOTE_REAP;
    }

    private static final int NOTE_PCTRLMASK = (int) -1048576L;
    /**
     * {@snippet lang=c :
     * #define NOTE_PCTRLMASK -1048576
     * }
     */
    public static int NOTE_PCTRLMASK() {
        return NOTE_PCTRLMASK;
    }

    private static final int NOTE_EXIT_REPARENTED = (int) 524288L;
    /**
     * {@snippet lang=c :
     * #define NOTE_EXIT_REPARENTED 524288
     * }
     */
    public static int NOTE_EXIT_REPARENTED() {
        return NOTE_EXIT_REPARENTED;
    }

    private static final int NOTE_VM_PRESSURE = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define NOTE_VM_PRESSURE 2147483648
     * }
     */
    public static int NOTE_VM_PRESSURE() {
        return NOTE_VM_PRESSURE;
    }

    private static final int IFF_ALTPHYS = (int) 16384L;
    /**
     * {@snippet lang=c :
     * #define IFF_ALTPHYS 16384
     * }
     */
    public static int IFF_ALTPHYS() {
        return IFF_ALTPHYS;
    }

    private static final int IFCAP_HWCSUM = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define IFCAP_HWCSUM 3
     * }
     */
    public static int IFCAP_HWCSUM() {
        return IFCAP_HWCSUM;
    }

    private static final int IFCAP_TSO = (int) 96L;
    /**
     * {@snippet lang=c :
     * #define IFCAP_TSO 96
     * }
     */
    public static int IFCAP_TSO() {
        return IFCAP_TSO;
    }

    private static final int IFCAP_VALID = (int) 32767L;
    /**
     * {@snippet lang=c :
     * #define IFCAP_VALID 32767
     * }
     */
    public static int IFCAP_VALID() {
        return IFCAP_VALID;
    }

    private static final long IFQ_DEF_C_TARGET_DELAY = 10000000L;
    /**
     * {@snippet lang=c :
     * #define IFQ_DEF_C_TARGET_DELAY 10000000
     * }
     */
    public static long IFQ_DEF_C_TARGET_DELAY() {
        return IFQ_DEF_C_TARGET_DELAY;
    }

    private static final long IFQ_DEF_C_UPDATE_INTERVAL = 100000000L;
    /**
     * {@snippet lang=c :
     * #define IFQ_DEF_C_UPDATE_INTERVAL 100000000
     * }
     */
    public static long IFQ_DEF_C_UPDATE_INTERVAL() {
        return IFQ_DEF_C_UPDATE_INTERVAL;
    }

    private static final long IFQ_DEF_L4S_TARGET_DELAY = 2000000L;
    /**
     * {@snippet lang=c :
     * #define IFQ_DEF_L4S_TARGET_DELAY 2000000
     * }
     */
    public static long IFQ_DEF_L4S_TARGET_DELAY() {
        return IFQ_DEF_L4S_TARGET_DELAY;
    }

    private static final long IFQ_DEF_L4S_WIRELESS_TARGET_DELAY = 15000000L;
    /**
     * {@snippet lang=c :
     * #define IFQ_DEF_L4S_WIRELESS_TARGET_DELAY 15000000
     * }
     */
    public static long IFQ_DEF_L4S_WIRELESS_TARGET_DELAY() {
        return IFQ_DEF_L4S_WIRELESS_TARGET_DELAY;
    }

    private static final long IFQ_DEF_L4S_UPDATE_INTERVAL = 100000000L;
    /**
     * {@snippet lang=c :
     * #define IFQ_DEF_L4S_UPDATE_INTERVAL 100000000
     * }
     */
    public static long IFQ_DEF_L4S_UPDATE_INTERVAL() {
        return IFQ_DEF_L4S_UPDATE_INTERVAL;
    }

    private static final long IFQ_LL_C_TARGET_DELAY = 10000000L;
    /**
     * {@snippet lang=c :
     * #define IFQ_LL_C_TARGET_DELAY 10000000
     * }
     */
    public static long IFQ_LL_C_TARGET_DELAY() {
        return IFQ_LL_C_TARGET_DELAY;
    }

    private static final long IFQ_LL_C_UPDATE_INTERVAL = 100000000L;
    /**
     * {@snippet lang=c :
     * #define IFQ_LL_C_UPDATE_INTERVAL 100000000
     * }
     */
    public static long IFQ_LL_C_UPDATE_INTERVAL() {
        return IFQ_LL_C_UPDATE_INTERVAL;
    }

    private static final long IFQ_LL_L4S_TARGET_DELAY = 2000000L;
    /**
     * {@snippet lang=c :
     * #define IFQ_LL_L4S_TARGET_DELAY 2000000
     * }
     */
    public static long IFQ_LL_L4S_TARGET_DELAY() {
        return IFQ_LL_L4S_TARGET_DELAY;
    }

    private static final long IFQ_LL_L4S_WIRELESS_TARGET_DELAY = 15000000L;
    /**
     * {@snippet lang=c :
     * #define IFQ_LL_L4S_WIRELESS_TARGET_DELAY 15000000
     * }
     */
    public static long IFQ_LL_L4S_WIRELESS_TARGET_DELAY() {
        return IFQ_LL_L4S_WIRELESS_TARGET_DELAY;
    }

    private static final long IFQ_LL_L4S_UPDATE_INTERVAL = 100000000L;
    /**
     * {@snippet lang=c :
     * #define IFQ_LL_L4S_UPDATE_INTERVAL 100000000
     * }
     */
    public static long IFQ_LL_L4S_UPDATE_INTERVAL() {
        return IFQ_LL_L4S_UPDATE_INTERVAL;
    }

    private static final int RTPRF_OURS = (int) 262144L;
    /**
     * {@snippet lang=c :
     * #define RTPRF_OURS 262144
     * }
     */
    public static int RTPRF_OURS() {
        return RTPRF_OURS;
    }

    private static final int IPPROTO_IPIP = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define IPPROTO_IPIP 4
     * }
     */
    public static int IPPROTO_IPIP() {
        return IPPROTO_IPIP;
    }

    private static final int IPPORT_RESERVED = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define IPPORT_RESERVED 1024
     * }
     */
    public static int IPPORT_RESERVED() {
        return IPPORT_RESERVED;
    }

    private static final int INADDR_ANY = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define INADDR_ANY 0
     * }
     */
    public static int INADDR_ANY() {
        return INADDR_ANY;
    }

    private static final int INADDR_BROADCAST = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define INADDR_BROADCAST 4294967295
     * }
     */
    public static int INADDR_BROADCAST() {
        return INADDR_BROADCAST;
    }

    private static final int IN_CLASSA_NET = (int) 4278190080L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSA_NET 4278190080
     * }
     */
    public static int IN_CLASSA_NET() {
        return IN_CLASSA_NET;
    }

    private static final int IN_CLASSB_NET = (int) 4294901760L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSB_NET 4294901760
     * }
     */
    public static int IN_CLASSB_NET() {
        return IN_CLASSB_NET;
    }

    private static final int IN_CLASSC_NET = (int) 4294967040L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSC_NET 4294967040
     * }
     */
    public static int IN_CLASSC_NET() {
        return IN_CLASSC_NET;
    }

    private static final int IN_CLASSD_NET = (int) 4026531840L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSD_NET 4026531840
     * }
     */
    public static int IN_CLASSD_NET() {
        return IN_CLASSD_NET;
    }

    private static final int INADDR_LOOPBACK = (int) 2130706433L;
    /**
     * {@snippet lang=c :
     * #define INADDR_LOOPBACK 2130706433
     * }
     */
    public static int INADDR_LOOPBACK() {
        return INADDR_LOOPBACK;
    }

    private static final int INADDR_NONE = (int) 4294967295L;
    /**
     * {@snippet lang=c :
     * #define INADDR_NONE 4294967295
     * }
     */
    public static int INADDR_NONE() {
        return INADDR_NONE;
    }

    private static final int INADDR_UNSPEC_GROUP = (int) 3758096384L;
    /**
     * {@snippet lang=c :
     * #define INADDR_UNSPEC_GROUP 3758096384
     * }
     */
    public static int INADDR_UNSPEC_GROUP() {
        return INADDR_UNSPEC_GROUP;
    }

    private static final int INADDR_ALLHOSTS_GROUP = (int) 3758096385L;
    /**
     * {@snippet lang=c :
     * #define INADDR_ALLHOSTS_GROUP 3758096385
     * }
     */
    public static int INADDR_ALLHOSTS_GROUP() {
        return INADDR_ALLHOSTS_GROUP;
    }

    private static final int INADDR_ALLRTRS_GROUP = (int) 3758096386L;
    /**
     * {@snippet lang=c :
     * #define INADDR_ALLRTRS_GROUP 3758096386
     * }
     */
    public static int INADDR_ALLRTRS_GROUP() {
        return INADDR_ALLRTRS_GROUP;
    }

    private static final int INADDR_ALLRPTS_GROUP = (int) 3758096406L;
    /**
     * {@snippet lang=c :
     * #define INADDR_ALLRPTS_GROUP 3758096406
     * }
     */
    public static int INADDR_ALLRPTS_GROUP() {
        return INADDR_ALLRPTS_GROUP;
    }

    private static final int INADDR_CARP_GROUP = (int) 3758096402L;
    /**
     * {@snippet lang=c :
     * #define INADDR_CARP_GROUP 3758096402
     * }
     */
    public static int INADDR_CARP_GROUP() {
        return INADDR_CARP_GROUP;
    }

    private static final int INADDR_PFSYNC_GROUP = (int) 3758096624L;
    /**
     * {@snippet lang=c :
     * #define INADDR_PFSYNC_GROUP 3758096624
     * }
     */
    public static int INADDR_PFSYNC_GROUP() {
        return INADDR_PFSYNC_GROUP;
    }

    private static final int INADDR_ALLMDNS_GROUP = (int) 3758096635L;
    /**
     * {@snippet lang=c :
     * #define INADDR_ALLMDNS_GROUP 3758096635
     * }
     */
    public static int INADDR_ALLMDNS_GROUP() {
        return INADDR_ALLMDNS_GROUP;
    }

    private static final int INADDR_MAX_LOCAL_GROUP = (int) 3758096639L;
    /**
     * {@snippet lang=c :
     * #define INADDR_MAX_LOCAL_GROUP 3758096639
     * }
     */
    public static int INADDR_MAX_LOCAL_GROUP() {
        return INADDR_MAX_LOCAL_GROUP;
    }

    private static final int IN_LINKLOCALNETNUM = (int) 2851995648L;
    /**
     * {@snippet lang=c :
     * #define IN_LINKLOCALNETNUM 2851995648
     * }
     */
    public static int IN_LINKLOCALNETNUM() {
        return IN_LINKLOCALNETNUM;
    }

    private static final int IP_RECVPKTINFO = (int) 26L;
    /**
     * {@snippet lang=c :
     * #define IP_RECVPKTINFO 26
     * }
     */
    public static int IP_RECVPKTINFO() {
        return IP_RECVPKTINFO;
    }

    private static final int IPPROTO_MAXID = (int) 52L;
    /**
     * {@snippet lang=c :
     * #define IPPROTO_MAXID 52
     * }
     */
    public static int IPPROTO_MAXID() {
        return IPPROTO_MAXID;
    }
    /**
     * {@snippet lang=c :
     * #define __KAME_VERSION "2009/apple-darwin"
     * }
     */
    public static MemorySegment __KAME_VERSION() {
        class Holder {
            static final MemorySegment __KAME_VERSION = proc_info_h.LIBRARY_ARENA.allocateFrom("2009/apple-darwin");
        }
        return Holder.__KAME_VERSION;
    }

    private static final int IPV6PORT_RESERVEDMAX = (int) 1023L;
    /**
     * {@snippet lang=c :
     * #define IPV6PORT_RESERVEDMAX 1023
     * }
     */
    public static int IPV6PORT_RESERVEDMAX() {
        return IPV6PORT_RESERVEDMAX;
    }

    private static final int IPV6_ADDR_MC_FLAGS_UNICAST_BASED = (int) 48L;
    /**
     * {@snippet lang=c :
     * #define IPV6_ADDR_MC_FLAGS_UNICAST_BASED 48
     * }
     */
    public static int IPV6_ADDR_MC_FLAGS_UNICAST_BASED() {
        return IPV6_ADDR_MC_FLAGS_UNICAST_BASED;
    }

    private static final int IPV6_BINDV6ONLY = (int) 27L;
    /**
     * {@snippet lang=c :
     * #define IPV6_BINDV6ONLY 27
     * }
     */
    public static int IPV6_BINDV6ONLY() {
        return IPV6_BINDV6ONLY;
    }

    private static final int IPV6PROTO_MAXID = (int) 104L;
    /**
     * {@snippet lang=c :
     * #define IPV6PROTO_MAXID 104
     * }
     */
    public static int IPV6PROTO_MAXID() {
        return IPV6PROTO_MAXID;
    }

    private static final int TH_FLAGS = (int) 247L;
    /**
     * {@snippet lang=c :
     * #define TH_FLAGS 247
     * }
     */
    public static int TH_FLAGS() {
        return TH_FLAGS;
    }

    private static final int TH_FLAGS_ALL = (int) 255L;
    /**
     * {@snippet lang=c :
     * #define TH_FLAGS_ALL 255
     * }
     */
    public static int TH_FLAGS_ALL() {
        return TH_FLAGS_ALL;
    }

    private static final int TH_ACCEPT = (int) 23L;
    /**
     * {@snippet lang=c :
     * #define TH_ACCEPT 23
     * }
     */
    public static int TH_ACCEPT() {
        return TH_ACCEPT;
    }

    private static final int TH_ACE = (int) 448L;
    /**
     * {@snippet lang=c :
     * #define TH_ACE 448
     * }
     */
    public static int TH_ACE() {
        return TH_ACE;
    }

    private static final int TCPOLEN_TSTAMP_APPA = (int) 12L;
    /**
     * {@snippet lang=c :
     * #define TCPOLEN_TSTAMP_APPA 12
     * }
     */
    public static int TCPOLEN_TSTAMP_APPA() {
        return TCPOLEN_TSTAMP_APPA;
    }

    private static final int TCPOPT_TSTAMP_HDR = (int) 16844810L;
    /**
     * {@snippet lang=c :
     * #define TCPOPT_TSTAMP_HDR 16844810
     * }
     */
    public static int TCPOPT_TSTAMP_HDR() {
        return TCPOPT_TSTAMP_HDR;
    }

    private static final int TCPOLEN_CC_APPA = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define TCPOLEN_CC_APPA 8
     * }
     */
    public static int TCPOLEN_CC_APPA() {
        return TCPOLEN_CC_APPA;
    }

    private static final int TCPOPT_SACK_PERMIT_HDR = (int) 16843778L;
    /**
     * {@snippet lang=c :
     * #define TCPOPT_SACK_PERMIT_HDR 16843778
     * }
     */
    public static int TCPOPT_SACK_PERMIT_HDR() {
        return TCPOPT_SACK_PERMIT_HDR;
    }

    private static final int TCPOPT_SACK_HDR = (int) 16844032L;
    /**
     * {@snippet lang=c :
     * #define TCPOPT_SACK_HDR 16844032
     * }
     */
    public static int TCPOPT_SACK_HDR() {
        return TCPOPT_SACK_HDR;
    }

    private static final int TCP_MAXHLEN = (int) 60L;
    /**
     * {@snippet lang=c :
     * #define TCP_MAXHLEN 60
     * }
     */
    public static int TCP_MAXHLEN() {
        return TCP_MAXHLEN;
    }

    private static final long TCP_MAXOLEN = 40L;
    /**
     * {@snippet lang=c :
     * #define TCP_MAXOLEN 40
     * }
     */
    public static long TCP_MAXOLEN() {
        return TCP_MAXOLEN;
    }

    private static final int CPU_ARCH_MASK = (int) 4278190080L;
    /**
     * {@snippet lang=c :
     * #define CPU_ARCH_MASK 4278190080
     * }
     */
    public static int CPU_ARCH_MASK() {
        return CPU_ARCH_MASK;
    }

    private static final int CPU_TYPE_ANY = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_ANY -1
     * }
     */
    public static int CPU_TYPE_ANY() {
        return CPU_TYPE_ANY;
    }

    private static final int CPU_TYPE_VAX = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_VAX 1
     * }
     */
    public static int CPU_TYPE_VAX() {
        return CPU_TYPE_VAX;
    }

    private static final int CPU_TYPE_MC680x0 = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_MC680x0 6
     * }
     */
    public static int CPU_TYPE_MC680x0() {
        return CPU_TYPE_MC680x0;
    }

    private static final int CPU_TYPE_X86 = (int) 7L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_X86 7
     * }
     */
    public static int CPU_TYPE_X86() {
        return CPU_TYPE_X86;
    }

    private static final int CPU_TYPE_I386 = (int) 7L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_I386 7
     * }
     */
    public static int CPU_TYPE_I386() {
        return CPU_TYPE_I386;
    }

    private static final int CPU_TYPE_X86_64 = (int) 16777223L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_X86_64 16777223
     * }
     */
    public static int CPU_TYPE_X86_64() {
        return CPU_TYPE_X86_64;
    }

    private static final int CPU_TYPE_MC98000 = (int) 10L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_MC98000 10
     * }
     */
    public static int CPU_TYPE_MC98000() {
        return CPU_TYPE_MC98000;
    }

    private static final int CPU_TYPE_HPPA = (int) 11L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_HPPA 11
     * }
     */
    public static int CPU_TYPE_HPPA() {
        return CPU_TYPE_HPPA;
    }

    private static final int CPU_TYPE_ARM = (int) 12L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_ARM 12
     * }
     */
    public static int CPU_TYPE_ARM() {
        return CPU_TYPE_ARM;
    }

    private static final int CPU_TYPE_ARM64 = (int) 16777228L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_ARM64 16777228
     * }
     */
    public static int CPU_TYPE_ARM64() {
        return CPU_TYPE_ARM64;
    }

    private static final int CPU_TYPE_ARM64_32 = (int) 33554444L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_ARM64_32 33554444
     * }
     */
    public static int CPU_TYPE_ARM64_32() {
        return CPU_TYPE_ARM64_32;
    }

    private static final int CPU_TYPE_MC88000 = (int) 13L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_MC88000 13
     * }
     */
    public static int CPU_TYPE_MC88000() {
        return CPU_TYPE_MC88000;
    }

    private static final int CPU_TYPE_SPARC = (int) 14L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_SPARC 14
     * }
     */
    public static int CPU_TYPE_SPARC() {
        return CPU_TYPE_SPARC;
    }

    private static final int CPU_TYPE_I860 = (int) 15L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_I860 15
     * }
     */
    public static int CPU_TYPE_I860() {
        return CPU_TYPE_I860;
    }

    private static final int CPU_TYPE_POWERPC = (int) 18L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_POWERPC 18
     * }
     */
    public static int CPU_TYPE_POWERPC() {
        return CPU_TYPE_POWERPC;
    }

    private static final int CPU_TYPE_POWERPC64 = (int) 16777234L;
    /**
     * {@snippet lang=c :
     * #define CPU_TYPE_POWERPC64 16777234
     * }
     */
    public static int CPU_TYPE_POWERPC64() {
        return CPU_TYPE_POWERPC64;
    }

    private static final int CPU_SUBTYPE_MASK = (int) 4278190080L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MASK 4278190080
     * }
     */
    public static int CPU_SUBTYPE_MASK() {
        return CPU_SUBTYPE_MASK;
    }

    private static final int CPU_SUBTYPE_LIB64 = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_LIB64 2147483648
     * }
     */
    public static int CPU_SUBTYPE_LIB64() {
        return CPU_SUBTYPE_LIB64;
    }

    private static final int CPU_SUBTYPE_PTRAUTH_ABI = (int) 2147483648L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_PTRAUTH_ABI 2147483648
     * }
     */
    public static int CPU_SUBTYPE_PTRAUTH_ABI() {
        return CPU_SUBTYPE_PTRAUTH_ABI;
    }

    private static final int CPU_SUBTYPE_ANY = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ANY -1
     * }
     */
    public static int CPU_SUBTYPE_ANY() {
        return CPU_SUBTYPE_ANY;
    }

    private static final int CPU_SUBTYPE_MULTIPLE = (int) -1L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MULTIPLE -1
     * }
     */
    public static int CPU_SUBTYPE_MULTIPLE() {
        return CPU_SUBTYPE_MULTIPLE;
    }

    private static final int CPU_SUBTYPE_LITTLE_ENDIAN = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_LITTLE_ENDIAN 0
     * }
     */
    public static int CPU_SUBTYPE_LITTLE_ENDIAN() {
        return CPU_SUBTYPE_LITTLE_ENDIAN;
    }

    private static final int CPU_SUBTYPE_BIG_ENDIAN = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_BIG_ENDIAN 1
     * }
     */
    public static int CPU_SUBTYPE_BIG_ENDIAN() {
        return CPU_SUBTYPE_BIG_ENDIAN;
    }

    private static final int CPU_THREADTYPE_NONE = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_THREADTYPE_NONE 0
     * }
     */
    public static int CPU_THREADTYPE_NONE() {
        return CPU_THREADTYPE_NONE;
    }

    private static final int CPU_SUBTYPE_VAX_ALL = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_VAX_ALL 0
     * }
     */
    public static int CPU_SUBTYPE_VAX_ALL() {
        return CPU_SUBTYPE_VAX_ALL;
    }

    private static final int CPU_SUBTYPE_VAX780 = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_VAX780 1
     * }
     */
    public static int CPU_SUBTYPE_VAX780() {
        return CPU_SUBTYPE_VAX780;
    }

    private static final int CPU_SUBTYPE_VAX785 = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_VAX785 2
     * }
     */
    public static int CPU_SUBTYPE_VAX785() {
        return CPU_SUBTYPE_VAX785;
    }

    private static final int CPU_SUBTYPE_VAX750 = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_VAX750 3
     * }
     */
    public static int CPU_SUBTYPE_VAX750() {
        return CPU_SUBTYPE_VAX750;
    }

    private static final int CPU_SUBTYPE_VAX730 = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_VAX730 4
     * }
     */
    public static int CPU_SUBTYPE_VAX730() {
        return CPU_SUBTYPE_VAX730;
    }

    private static final int CPU_SUBTYPE_UVAXI = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_UVAXI 5
     * }
     */
    public static int CPU_SUBTYPE_UVAXI() {
        return CPU_SUBTYPE_UVAXI;
    }

    private static final int CPU_SUBTYPE_UVAXII = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_UVAXII 6
     * }
     */
    public static int CPU_SUBTYPE_UVAXII() {
        return CPU_SUBTYPE_UVAXII;
    }

    private static final int CPU_SUBTYPE_VAX8200 = (int) 7L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_VAX8200 7
     * }
     */
    public static int CPU_SUBTYPE_VAX8200() {
        return CPU_SUBTYPE_VAX8200;
    }

    private static final int CPU_SUBTYPE_VAX8500 = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_VAX8500 8
     * }
     */
    public static int CPU_SUBTYPE_VAX8500() {
        return CPU_SUBTYPE_VAX8500;
    }

    private static final int CPU_SUBTYPE_VAX8600 = (int) 9L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_VAX8600 9
     * }
     */
    public static int CPU_SUBTYPE_VAX8600() {
        return CPU_SUBTYPE_VAX8600;
    }

    private static final int CPU_SUBTYPE_VAX8650 = (int) 10L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_VAX8650 10
     * }
     */
    public static int CPU_SUBTYPE_VAX8650() {
        return CPU_SUBTYPE_VAX8650;
    }

    private static final int CPU_SUBTYPE_VAX8800 = (int) 11L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_VAX8800 11
     * }
     */
    public static int CPU_SUBTYPE_VAX8800() {
        return CPU_SUBTYPE_VAX8800;
    }

    private static final int CPU_SUBTYPE_UVAXIII = (int) 12L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_UVAXIII 12
     * }
     */
    public static int CPU_SUBTYPE_UVAXIII() {
        return CPU_SUBTYPE_UVAXIII;
    }

    private static final int CPU_SUBTYPE_MC680x0_ALL = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MC680x0_ALL 1
     * }
     */
    public static int CPU_SUBTYPE_MC680x0_ALL() {
        return CPU_SUBTYPE_MC680x0_ALL;
    }

    private static final int CPU_SUBTYPE_MC68030 = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MC68030 1
     * }
     */
    public static int CPU_SUBTYPE_MC68030() {
        return CPU_SUBTYPE_MC68030;
    }

    private static final int CPU_SUBTYPE_MC68040 = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MC68040 2
     * }
     */
    public static int CPU_SUBTYPE_MC68040() {
        return CPU_SUBTYPE_MC68040;
    }

    private static final int CPU_SUBTYPE_MC68030_ONLY = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MC68030_ONLY 3
     * }
     */
    public static int CPU_SUBTYPE_MC68030_ONLY() {
        return CPU_SUBTYPE_MC68030_ONLY;
    }

    private static final int CPU_SUBTYPE_I386_ALL = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_I386_ALL 3
     * }
     */
    public static int CPU_SUBTYPE_I386_ALL() {
        return CPU_SUBTYPE_I386_ALL;
    }

    private static final int CPU_SUBTYPE_386 = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_386 3
     * }
     */
    public static int CPU_SUBTYPE_386() {
        return CPU_SUBTYPE_386;
    }

    private static final int CPU_SUBTYPE_486 = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_486 4
     * }
     */
    public static int CPU_SUBTYPE_486() {
        return CPU_SUBTYPE_486;
    }

    private static final int CPU_SUBTYPE_486SX = (int) 132L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_486SX 132
     * }
     */
    public static int CPU_SUBTYPE_486SX() {
        return CPU_SUBTYPE_486SX;
    }

    private static final int CPU_SUBTYPE_586 = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_586 5
     * }
     */
    public static int CPU_SUBTYPE_586() {
        return CPU_SUBTYPE_586;
    }

    private static final int CPU_SUBTYPE_PENT = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_PENT 5
     * }
     */
    public static int CPU_SUBTYPE_PENT() {
        return CPU_SUBTYPE_PENT;
    }

    private static final int CPU_SUBTYPE_PENTPRO = (int) 22L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_PENTPRO 22
     * }
     */
    public static int CPU_SUBTYPE_PENTPRO() {
        return CPU_SUBTYPE_PENTPRO;
    }

    private static final int CPU_SUBTYPE_PENTII_M3 = (int) 54L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_PENTII_M3 54
     * }
     */
    public static int CPU_SUBTYPE_PENTII_M3() {
        return CPU_SUBTYPE_PENTII_M3;
    }

    private static final int CPU_SUBTYPE_PENTII_M5 = (int) 86L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_PENTII_M5 86
     * }
     */
    public static int CPU_SUBTYPE_PENTII_M5() {
        return CPU_SUBTYPE_PENTII_M5;
    }

    private static final int CPU_SUBTYPE_CELERON = (int) 103L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_CELERON 103
     * }
     */
    public static int CPU_SUBTYPE_CELERON() {
        return CPU_SUBTYPE_CELERON;
    }

    private static final int CPU_SUBTYPE_CELERON_MOBILE = (int) 119L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_CELERON_MOBILE 119
     * }
     */
    public static int CPU_SUBTYPE_CELERON_MOBILE() {
        return CPU_SUBTYPE_CELERON_MOBILE;
    }

    private static final int CPU_SUBTYPE_PENTIUM_3 = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_PENTIUM_3 8
     * }
     */
    public static int CPU_SUBTYPE_PENTIUM_3() {
        return CPU_SUBTYPE_PENTIUM_3;
    }

    private static final int CPU_SUBTYPE_PENTIUM_3_M = (int) 24L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_PENTIUM_3_M 24
     * }
     */
    public static int CPU_SUBTYPE_PENTIUM_3_M() {
        return CPU_SUBTYPE_PENTIUM_3_M;
    }

    private static final int CPU_SUBTYPE_PENTIUM_3_XEON = (int) 40L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_PENTIUM_3_XEON 40
     * }
     */
    public static int CPU_SUBTYPE_PENTIUM_3_XEON() {
        return CPU_SUBTYPE_PENTIUM_3_XEON;
    }

    private static final int CPU_SUBTYPE_PENTIUM_M = (int) 9L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_PENTIUM_M 9
     * }
     */
    public static int CPU_SUBTYPE_PENTIUM_M() {
        return CPU_SUBTYPE_PENTIUM_M;
    }

    private static final int CPU_SUBTYPE_PENTIUM_4 = (int) 10L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_PENTIUM_4 10
     * }
     */
    public static int CPU_SUBTYPE_PENTIUM_4() {
        return CPU_SUBTYPE_PENTIUM_4;
    }

    private static final int CPU_SUBTYPE_PENTIUM_4_M = (int) 26L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_PENTIUM_4_M 26
     * }
     */
    public static int CPU_SUBTYPE_PENTIUM_4_M() {
        return CPU_SUBTYPE_PENTIUM_4_M;
    }

    private static final int CPU_SUBTYPE_ITANIUM = (int) 11L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ITANIUM 11
     * }
     */
    public static int CPU_SUBTYPE_ITANIUM() {
        return CPU_SUBTYPE_ITANIUM;
    }

    private static final int CPU_SUBTYPE_ITANIUM_2 = (int) 27L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ITANIUM_2 27
     * }
     */
    public static int CPU_SUBTYPE_ITANIUM_2() {
        return CPU_SUBTYPE_ITANIUM_2;
    }

    private static final int CPU_SUBTYPE_XEON = (int) 12L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_XEON 12
     * }
     */
    public static int CPU_SUBTYPE_XEON() {
        return CPU_SUBTYPE_XEON;
    }

    private static final int CPU_SUBTYPE_XEON_MP = (int) 28L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_XEON_MP 28
     * }
     */
    public static int CPU_SUBTYPE_XEON_MP() {
        return CPU_SUBTYPE_XEON_MP;
    }

    private static final int CPU_SUBTYPE_X86_ALL = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_X86_ALL 3
     * }
     */
    public static int CPU_SUBTYPE_X86_ALL() {
        return CPU_SUBTYPE_X86_ALL;
    }

    private static final int CPU_SUBTYPE_X86_64_ALL = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_X86_64_ALL 3
     * }
     */
    public static int CPU_SUBTYPE_X86_64_ALL() {
        return CPU_SUBTYPE_X86_64_ALL;
    }

    private static final int CPU_SUBTYPE_X86_ARCH1 = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_X86_ARCH1 4
     * }
     */
    public static int CPU_SUBTYPE_X86_ARCH1() {
        return CPU_SUBTYPE_X86_ARCH1;
    }

    private static final int CPU_SUBTYPE_X86_64_H = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_X86_64_H 8
     * }
     */
    public static int CPU_SUBTYPE_X86_64_H() {
        return CPU_SUBTYPE_X86_64_H;
    }

    private static final int CPU_THREADTYPE_INTEL_HTT = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPU_THREADTYPE_INTEL_HTT 1
     * }
     */
    public static int CPU_THREADTYPE_INTEL_HTT() {
        return CPU_THREADTYPE_INTEL_HTT;
    }

    private static final int CPU_SUBTYPE_MIPS_ALL = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MIPS_ALL 0
     * }
     */
    public static int CPU_SUBTYPE_MIPS_ALL() {
        return CPU_SUBTYPE_MIPS_ALL;
    }

    private static final int CPU_SUBTYPE_MIPS_R2300 = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MIPS_R2300 1
     * }
     */
    public static int CPU_SUBTYPE_MIPS_R2300() {
        return CPU_SUBTYPE_MIPS_R2300;
    }

    private static final int CPU_SUBTYPE_MIPS_R2600 = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MIPS_R2600 2
     * }
     */
    public static int CPU_SUBTYPE_MIPS_R2600() {
        return CPU_SUBTYPE_MIPS_R2600;
    }

    private static final int CPU_SUBTYPE_MIPS_R2800 = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MIPS_R2800 3
     * }
     */
    public static int CPU_SUBTYPE_MIPS_R2800() {
        return CPU_SUBTYPE_MIPS_R2800;
    }

    private static final int CPU_SUBTYPE_MIPS_R2000a = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MIPS_R2000a 4
     * }
     */
    public static int CPU_SUBTYPE_MIPS_R2000a() {
        return CPU_SUBTYPE_MIPS_R2000a;
    }

    private static final int CPU_SUBTYPE_MIPS_R2000 = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MIPS_R2000 5
     * }
     */
    public static int CPU_SUBTYPE_MIPS_R2000() {
        return CPU_SUBTYPE_MIPS_R2000;
    }

    private static final int CPU_SUBTYPE_MIPS_R3000a = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MIPS_R3000a 6
     * }
     */
    public static int CPU_SUBTYPE_MIPS_R3000a() {
        return CPU_SUBTYPE_MIPS_R3000a;
    }

    private static final int CPU_SUBTYPE_MIPS_R3000 = (int) 7L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MIPS_R3000 7
     * }
     */
    public static int CPU_SUBTYPE_MIPS_R3000() {
        return CPU_SUBTYPE_MIPS_R3000;
    }

    private static final int CPU_SUBTYPE_MC98000_ALL = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MC98000_ALL 0
     * }
     */
    public static int CPU_SUBTYPE_MC98000_ALL() {
        return CPU_SUBTYPE_MC98000_ALL;
    }

    private static final int CPU_SUBTYPE_MC98601 = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MC98601 1
     * }
     */
    public static int CPU_SUBTYPE_MC98601() {
        return CPU_SUBTYPE_MC98601;
    }

    private static final int CPU_SUBTYPE_HPPA_ALL = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_HPPA_ALL 0
     * }
     */
    public static int CPU_SUBTYPE_HPPA_ALL() {
        return CPU_SUBTYPE_HPPA_ALL;
    }

    private static final int CPU_SUBTYPE_HPPA_7100 = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_HPPA_7100 0
     * }
     */
    public static int CPU_SUBTYPE_HPPA_7100() {
        return CPU_SUBTYPE_HPPA_7100;
    }

    private static final int CPU_SUBTYPE_HPPA_7100LC = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_HPPA_7100LC 1
     * }
     */
    public static int CPU_SUBTYPE_HPPA_7100LC() {
        return CPU_SUBTYPE_HPPA_7100LC;
    }

    private static final int CPU_SUBTYPE_MC88000_ALL = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MC88000_ALL 0
     * }
     */
    public static int CPU_SUBTYPE_MC88000_ALL() {
        return CPU_SUBTYPE_MC88000_ALL;
    }

    private static final int CPU_SUBTYPE_MC88100 = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MC88100 1
     * }
     */
    public static int CPU_SUBTYPE_MC88100() {
        return CPU_SUBTYPE_MC88100;
    }

    private static final int CPU_SUBTYPE_MC88110 = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_MC88110 2
     * }
     */
    public static int CPU_SUBTYPE_MC88110() {
        return CPU_SUBTYPE_MC88110;
    }

    private static final int CPU_SUBTYPE_SPARC_ALL = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_SPARC_ALL 0
     * }
     */
    public static int CPU_SUBTYPE_SPARC_ALL() {
        return CPU_SUBTYPE_SPARC_ALL;
    }

    private static final int CPU_SUBTYPE_I860_ALL = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_I860_ALL 0
     * }
     */
    public static int CPU_SUBTYPE_I860_ALL() {
        return CPU_SUBTYPE_I860_ALL;
    }

    private static final int CPU_SUBTYPE_I860_860 = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_I860_860 1
     * }
     */
    public static int CPU_SUBTYPE_I860_860() {
        return CPU_SUBTYPE_I860_860;
    }

    private static final int CPU_SUBTYPE_POWERPC_ALL = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_POWERPC_ALL 0
     * }
     */
    public static int CPU_SUBTYPE_POWERPC_ALL() {
        return CPU_SUBTYPE_POWERPC_ALL;
    }

    private static final int CPU_SUBTYPE_POWERPC_601 = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_POWERPC_601 1
     * }
     */
    public static int CPU_SUBTYPE_POWERPC_601() {
        return CPU_SUBTYPE_POWERPC_601;
    }

    private static final int CPU_SUBTYPE_POWERPC_602 = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_POWERPC_602 2
     * }
     */
    public static int CPU_SUBTYPE_POWERPC_602() {
        return CPU_SUBTYPE_POWERPC_602;
    }

    private static final int CPU_SUBTYPE_POWERPC_603 = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_POWERPC_603 3
     * }
     */
    public static int CPU_SUBTYPE_POWERPC_603() {
        return CPU_SUBTYPE_POWERPC_603;
    }

    private static final int CPU_SUBTYPE_POWERPC_603e = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_POWERPC_603e 4
     * }
     */
    public static int CPU_SUBTYPE_POWERPC_603e() {
        return CPU_SUBTYPE_POWERPC_603e;
    }

    private static final int CPU_SUBTYPE_POWERPC_603ev = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_POWERPC_603ev 5
     * }
     */
    public static int CPU_SUBTYPE_POWERPC_603ev() {
        return CPU_SUBTYPE_POWERPC_603ev;
    }

    private static final int CPU_SUBTYPE_POWERPC_604 = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_POWERPC_604 6
     * }
     */
    public static int CPU_SUBTYPE_POWERPC_604() {
        return CPU_SUBTYPE_POWERPC_604;
    }

    private static final int CPU_SUBTYPE_POWERPC_604e = (int) 7L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_POWERPC_604e 7
     * }
     */
    public static int CPU_SUBTYPE_POWERPC_604e() {
        return CPU_SUBTYPE_POWERPC_604e;
    }

    private static final int CPU_SUBTYPE_POWERPC_620 = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_POWERPC_620 8
     * }
     */
    public static int CPU_SUBTYPE_POWERPC_620() {
        return CPU_SUBTYPE_POWERPC_620;
    }

    private static final int CPU_SUBTYPE_POWERPC_750 = (int) 9L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_POWERPC_750 9
     * }
     */
    public static int CPU_SUBTYPE_POWERPC_750() {
        return CPU_SUBTYPE_POWERPC_750;
    }

    private static final int CPU_SUBTYPE_POWERPC_7400 = (int) 10L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_POWERPC_7400 10
     * }
     */
    public static int CPU_SUBTYPE_POWERPC_7400() {
        return CPU_SUBTYPE_POWERPC_7400;
    }

    private static final int CPU_SUBTYPE_POWERPC_7450 = (int) 11L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_POWERPC_7450 11
     * }
     */
    public static int CPU_SUBTYPE_POWERPC_7450() {
        return CPU_SUBTYPE_POWERPC_7450;
    }

    private static final int CPU_SUBTYPE_POWERPC_970 = (int) 100L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_POWERPC_970 100
     * }
     */
    public static int CPU_SUBTYPE_POWERPC_970() {
        return CPU_SUBTYPE_POWERPC_970;
    }

    private static final int CPU_SUBTYPE_ARM_ALL = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM_ALL 0
     * }
     */
    public static int CPU_SUBTYPE_ARM_ALL() {
        return CPU_SUBTYPE_ARM_ALL;
    }

    private static final int CPU_SUBTYPE_ARM_V4T = (int) 5L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM_V4T 5
     * }
     */
    public static int CPU_SUBTYPE_ARM_V4T() {
        return CPU_SUBTYPE_ARM_V4T;
    }

    private static final int CPU_SUBTYPE_ARM_V6 = (int) 6L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM_V6 6
     * }
     */
    public static int CPU_SUBTYPE_ARM_V6() {
        return CPU_SUBTYPE_ARM_V6;
    }

    private static final int CPU_SUBTYPE_ARM_V5TEJ = (int) 7L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM_V5TEJ 7
     * }
     */
    public static int CPU_SUBTYPE_ARM_V5TEJ() {
        return CPU_SUBTYPE_ARM_V5TEJ;
    }

    private static final int CPU_SUBTYPE_ARM_XSCALE = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM_XSCALE 8
     * }
     */
    public static int CPU_SUBTYPE_ARM_XSCALE() {
        return CPU_SUBTYPE_ARM_XSCALE;
    }

    private static final int CPU_SUBTYPE_ARM_V7 = (int) 9L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM_V7 9
     * }
     */
    public static int CPU_SUBTYPE_ARM_V7() {
        return CPU_SUBTYPE_ARM_V7;
    }

    private static final int CPU_SUBTYPE_ARM_V7F = (int) 10L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM_V7F 10
     * }
     */
    public static int CPU_SUBTYPE_ARM_V7F() {
        return CPU_SUBTYPE_ARM_V7F;
    }

    private static final int CPU_SUBTYPE_ARM_V7S = (int) 11L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM_V7S 11
     * }
     */
    public static int CPU_SUBTYPE_ARM_V7S() {
        return CPU_SUBTYPE_ARM_V7S;
    }

    private static final int CPU_SUBTYPE_ARM_V7K = (int) 12L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM_V7K 12
     * }
     */
    public static int CPU_SUBTYPE_ARM_V7K() {
        return CPU_SUBTYPE_ARM_V7K;
    }

    private static final int CPU_SUBTYPE_ARM_V8 = (int) 13L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM_V8 13
     * }
     */
    public static int CPU_SUBTYPE_ARM_V8() {
        return CPU_SUBTYPE_ARM_V8;
    }

    private static final int CPU_SUBTYPE_ARM_V6M = (int) 14L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM_V6M 14
     * }
     */
    public static int CPU_SUBTYPE_ARM_V6M() {
        return CPU_SUBTYPE_ARM_V6M;
    }

    private static final int CPU_SUBTYPE_ARM_V7M = (int) 15L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM_V7M 15
     * }
     */
    public static int CPU_SUBTYPE_ARM_V7M() {
        return CPU_SUBTYPE_ARM_V7M;
    }

    private static final int CPU_SUBTYPE_ARM_V7EM = (int) 16L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM_V7EM 16
     * }
     */
    public static int CPU_SUBTYPE_ARM_V7EM() {
        return CPU_SUBTYPE_ARM_V7EM;
    }

    private static final int CPU_SUBTYPE_ARM_V8M = (int) 17L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM_V8M 17
     * }
     */
    public static int CPU_SUBTYPE_ARM_V8M() {
        return CPU_SUBTYPE_ARM_V8M;
    }

    private static final int CPU_SUBTYPE_ARM64_ALL = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM64_ALL 0
     * }
     */
    public static int CPU_SUBTYPE_ARM64_ALL() {
        return CPU_SUBTYPE_ARM64_ALL;
    }

    private static final int CPU_SUBTYPE_ARM64_V8 = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM64_V8 1
     * }
     */
    public static int CPU_SUBTYPE_ARM64_V8() {
        return CPU_SUBTYPE_ARM64_V8;
    }

    private static final int CPU_SUBTYPE_ARM64E = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM64E 2
     * }
     */
    public static int CPU_SUBTYPE_ARM64E() {
        return CPU_SUBTYPE_ARM64E;
    }

    private static final int CPU_SUBTYPE_ARM64_32_ALL = (int) 0L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM64_32_ALL 0
     * }
     */
    public static int CPU_SUBTYPE_ARM64_32_ALL() {
        return CPU_SUBTYPE_ARM64_32_ALL;
    }

    private static final int CPU_SUBTYPE_ARM64_32_V8 = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define CPU_SUBTYPE_ARM64_32_V8 1
     * }
     */
    public static int CPU_SUBTYPE_ARM64_32_V8() {
        return CPU_SUBTYPE_ARM64_32_V8;
    }

    private static final int CPUFAMILY_POWERPC_G3 = (int) 3471054153L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_POWERPC_G3 3471054153
     * }
     */
    public static int CPUFAMILY_POWERPC_G3() {
        return CPUFAMILY_POWERPC_G3;
    }

    private static final int CPUFAMILY_POWERPC_G5 = (int) 3983988906L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_POWERPC_G5 3983988906
     * }
     */
    public static int CPUFAMILY_POWERPC_G5() {
        return CPUFAMILY_POWERPC_G5;
    }

    private static final int CPUFAMILY_INTEL_6_13 = (int) 2855483691L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_INTEL_6_13 2855483691
     * }
     */
    public static int CPUFAMILY_INTEL_6_13() {
        return CPUFAMILY_INTEL_6_13;
    }

    private static final int CPUFAMILY_ARM_9 = (int) 3878847406L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_9 3878847406
     * }
     */
    public static int CPUFAMILY_ARM_9() {
        return CPUFAMILY_ARM_9;
    }

    private static final int CPUFAMILY_ARM_11 = (int) 2415272152L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_11 2415272152
     * }
     */
    public static int CPUFAMILY_ARM_11() {
        return CPUFAMILY_ARM_11;
    }

    private static final int CPUFAMILY_ARM_12 = (int) 3172666089L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_12 3172666089
     * }
     */
    public static int CPUFAMILY_ARM_12() {
        return CPUFAMILY_ARM_12;
    }

    private static final int CPUFAMILY_ARM_14 = (int) 2517073649L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_14 2517073649
     * }
     */
    public static int CPUFAMILY_ARM_14() {
        return CPUFAMILY_ARM_14;
    }

    private static final int CPUFAMILY_ARM_15 = (int) 2823887818L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_15 2823887818
     * }
     */
    public static int CPUFAMILY_ARM_15() {
        return CPUFAMILY_ARM_15;
    }

    private static final int CPUFAMILY_ARM_TWISTER = (int) 2465937352L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_TWISTER 2465937352
     * }
     */
    public static int CPUFAMILY_ARM_TWISTER() {
        return CPUFAMILY_ARM_TWISTER;
    }

    private static final int CPUFAMILY_ARM_MONSOON_MISTRAL = (int) 3894312694L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_MONSOON_MISTRAL 3894312694
     * }
     */
    public static int CPUFAMILY_ARM_MONSOON_MISTRAL() {
        return CPUFAMILY_ARM_MONSOON_MISTRAL;
    }

    private static final int CPUFAMILY_ARM_BLIZZARD_AVALANCHE = (int) 3660830781L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_BLIZZARD_AVALANCHE 3660830781
     * }
     */
    public static int CPUFAMILY_ARM_BLIZZARD_AVALANCHE() {
        return CPUFAMILY_ARM_BLIZZARD_AVALANCHE;
    }

    private static final int CPUFAMILY_ARM_EVEREST_SAWTOOTH = (int) 2271604202L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_EVEREST_SAWTOOTH 2271604202
     * }
     */
    public static int CPUFAMILY_ARM_EVEREST_SAWTOOTH() {
        return CPUFAMILY_ARM_EVEREST_SAWTOOTH;
    }

    private static final int CPUFAMILY_ARM_IBIZA = (int) 4197663070L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_ARM_IBIZA 4197663070
     * }
     */
    public static int CPUFAMILY_ARM_IBIZA() {
        return CPUFAMILY_ARM_IBIZA;
    }

    private static final int CPUFAMILY_INTEL_6_23 = (int) 2028621756L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_INTEL_6_23 2028621756
     * }
     */
    public static int CPUFAMILY_INTEL_6_23() {
        return CPUFAMILY_INTEL_6_23;
    }

    private static final int CPUFAMILY_INTEL_6_26 = (int) 1801080018L;
    /**
     * {@snippet lang=c :
     * #define CPUFAMILY_INTEL_6_26 1801080018
     * }
     */
    public static int CPUFAMILY_INTEL_6_26() {
        return CPUFAMILY_INTEL_6_26;
    }

    private static final int PROC_FI_GUARD_CLOSE = (int) 1L;
    /**
     * {@snippet lang=c :
     * #define PROC_FI_GUARD_CLOSE 1
     * }
     */
    public static int PROC_FI_GUARD_CLOSE() {
        return PROC_FI_GUARD_CLOSE;
    }

    private static final int PROC_FI_GUARD_DUP = (int) 2L;
    /**
     * {@snippet lang=c :
     * #define PROC_FI_GUARD_DUP 2
     * }
     */
    public static int PROC_FI_GUARD_DUP() {
        return PROC_FI_GUARD_DUP;
    }

    private static final int PROC_FI_GUARD_SOCKET_IPC = (int) 4L;
    /**
     * {@snippet lang=c :
     * #define PROC_FI_GUARD_SOCKET_IPC 4
     * }
     */
    public static int PROC_FI_GUARD_SOCKET_IPC() {
        return PROC_FI_GUARD_SOCKET_IPC;
    }

    private static final int PROC_FI_GUARD_FILEPORT = (int) 8L;
    /**
     * {@snippet lang=c :
     * #define PROC_FI_GUARD_FILEPORT 8
     * }
     */
    public static int PROC_FI_GUARD_FILEPORT() {
        return PROC_FI_GUARD_FILEPORT;
    }

    private static final int PROC_CHANNEL_FLAGS_MONITOR = (int) 3L;
    /**
     * {@snippet lang=c :
     * #define PROC_CHANNEL_FLAGS_MONITOR 3
     * }
     */
    public static int PROC_CHANNEL_FLAGS_MONITOR() {
        return PROC_CHANNEL_FLAGS_MONITOR;
    }

    private static final long PROC_PIDLISTFD_SIZE = 8L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDLISTFD_SIZE 8
     * }
     */
    public static long PROC_PIDLISTFD_SIZE() {
        return PROC_PIDLISTFD_SIZE;
    }

    private static final long PROC_PIDTASKALLINFO_SIZE = 232L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDTASKALLINFO_SIZE 232
     * }
     */
    public static long PROC_PIDTASKALLINFO_SIZE() {
        return PROC_PIDTASKALLINFO_SIZE;
    }

    private static final long PROC_PIDTBSDINFO_SIZE = 136L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDTBSDINFO_SIZE 136
     * }
     */
    public static long PROC_PIDTBSDINFO_SIZE() {
        return PROC_PIDTBSDINFO_SIZE;
    }

    private static final long PROC_PIDTASKINFO_SIZE = 96L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDTASKINFO_SIZE 96
     * }
     */
    public static long PROC_PIDTASKINFO_SIZE() {
        return PROC_PIDTASKINFO_SIZE;
    }

    private static final long PROC_PIDTHREADINFO_SIZE = 112L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDTHREADINFO_SIZE 112
     * }
     */
    public static long PROC_PIDTHREADINFO_SIZE() {
        return PROC_PIDTHREADINFO_SIZE;
    }

    private static final long PROC_PIDLISTTHREADS_SIZE = 8L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDLISTTHREADS_SIZE 8
     * }
     */
    public static long PROC_PIDLISTTHREADS_SIZE() {
        return PROC_PIDLISTTHREADS_SIZE;
    }

    private static final long PROC_PIDREGIONINFO_SIZE = 96L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDREGIONINFO_SIZE 96
     * }
     */
    public static long PROC_PIDREGIONINFO_SIZE() {
        return PROC_PIDREGIONINFO_SIZE;
    }

    private static final long PROC_PIDREGIONPATHINFO_SIZE = 1272L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDREGIONPATHINFO_SIZE 1272
     * }
     */
    public static long PROC_PIDREGIONPATHINFO_SIZE() {
        return PROC_PIDREGIONPATHINFO_SIZE;
    }

    private static final long PROC_PIDVNODEPATHINFO_SIZE = 2352L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDVNODEPATHINFO_SIZE 2352
     * }
     */
    public static long PROC_PIDVNODEPATHINFO_SIZE() {
        return PROC_PIDVNODEPATHINFO_SIZE;
    }

    private static final long PROC_PIDTHREADPATHINFO_SIZE = 1288L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDTHREADPATHINFO_SIZE 1288
     * }
     */
    public static long PROC_PIDTHREADPATHINFO_SIZE() {
        return PROC_PIDTHREADPATHINFO_SIZE;
    }

    private static final int PROC_PIDPATHINFO_SIZE = (int) 1024L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDPATHINFO_SIZE 1024
     * }
     */
    public static int PROC_PIDPATHINFO_SIZE() {
        return PROC_PIDPATHINFO_SIZE;
    }

    private static final int PROC_PIDPATHINFO_MAXSIZE = (int) 4096L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDPATHINFO_MAXSIZE 4096
     * }
     */
    public static int PROC_PIDPATHINFO_MAXSIZE() {
        return PROC_PIDPATHINFO_MAXSIZE;
    }

    private static final long PROC_PIDWORKQUEUEINFO_SIZE = 16L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDWORKQUEUEINFO_SIZE 16
     * }
     */
    public static long PROC_PIDWORKQUEUEINFO_SIZE() {
        return PROC_PIDWORKQUEUEINFO_SIZE;
    }

    private static final long PROC_PIDT_SHORTBSDINFO_SIZE = 64L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDT_SHORTBSDINFO_SIZE 64
     * }
     */
    public static long PROC_PIDT_SHORTBSDINFO_SIZE() {
        return PROC_PIDT_SHORTBSDINFO_SIZE;
    }

    private static final long PROC_PIDLISTFILEPORTS_SIZE = 8L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDLISTFILEPORTS_SIZE 8
     * }
     */
    public static long PROC_PIDLISTFILEPORTS_SIZE() {
        return PROC_PIDLISTFILEPORTS_SIZE;
    }

    private static final long PROC_PIDTHREADID64INFO_SIZE = 112L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDTHREADID64INFO_SIZE 112
     * }
     */
    public static long PROC_PIDTHREADID64INFO_SIZE() {
        return PROC_PIDTHREADID64INFO_SIZE;
    }

    private static final long PROC_PIDFDVNODEINFO_SIZE = 176L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDVNODEINFO_SIZE 176
     * }
     */
    public static long PROC_PIDFDVNODEINFO_SIZE() {
        return PROC_PIDFDVNODEINFO_SIZE;
    }

    private static final long PROC_PIDFDVNODEPATHINFO_SIZE = 1200L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDVNODEPATHINFO_SIZE 1200
     * }
     */
    public static long PROC_PIDFDVNODEPATHINFO_SIZE() {
        return PROC_PIDFDVNODEPATHINFO_SIZE;
    }

    private static final long PROC_PIDFDSOCKETINFO_SIZE = 792L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDSOCKETINFO_SIZE 792
     * }
     */
    public static long PROC_PIDFDSOCKETINFO_SIZE() {
        return PROC_PIDFDSOCKETINFO_SIZE;
    }

    private static final long PROC_PIDFDPSEMINFO_SIZE = 1184L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDPSEMINFO_SIZE 1184
     * }
     */
    public static long PROC_PIDFDPSEMINFO_SIZE() {
        return PROC_PIDFDPSEMINFO_SIZE;
    }

    private static final long PROC_PIDFDPSHMINFO_SIZE = 1192L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDPSHMINFO_SIZE 1192
     * }
     */
    public static long PROC_PIDFDPSHMINFO_SIZE() {
        return PROC_PIDFDPSHMINFO_SIZE;
    }

    private static final long PROC_PIDFDPIPEINFO_SIZE = 184L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDPIPEINFO_SIZE 184
     * }
     */
    public static long PROC_PIDFDPIPEINFO_SIZE() {
        return PROC_PIDFDPIPEINFO_SIZE;
    }

    private static final long PROC_PIDFDKQUEUEINFO_SIZE = 168L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDKQUEUEINFO_SIZE 168
     * }
     */
    public static long PROC_PIDFDKQUEUEINFO_SIZE() {
        return PROC_PIDFDKQUEUEINFO_SIZE;
    }

    private static final long PROC_PIDFDATALKINFO_SIZE = 160L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDATALKINFO_SIZE 160
     * }
     */
    public static long PROC_PIDFDATALKINFO_SIZE() {
        return PROC_PIDFDATALKINFO_SIZE;
    }

    private static final long PROC_PIDFDCHANNELINFO_SIZE = 56L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFDCHANNELINFO_SIZE 56
     * }
     */
    public static long PROC_PIDFDCHANNELINFO_SIZE() {
        return PROC_PIDFDCHANNELINFO_SIZE;
    }

    private static final long PROC_PIDFILEPORTVNODEPATHINFO_SIZE = 1200L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFILEPORTVNODEPATHINFO_SIZE 1200
     * }
     */
    public static long PROC_PIDFILEPORTVNODEPATHINFO_SIZE() {
        return PROC_PIDFILEPORTVNODEPATHINFO_SIZE;
    }

    private static final long PROC_PIDFILEPORTSOCKETINFO_SIZE = 792L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFILEPORTSOCKETINFO_SIZE 792
     * }
     */
    public static long PROC_PIDFILEPORTSOCKETINFO_SIZE() {
        return PROC_PIDFILEPORTSOCKETINFO_SIZE;
    }

    private static final long PROC_PIDFILEPORTPSHMINFO_SIZE = 1192L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFILEPORTPSHMINFO_SIZE 1192
     * }
     */
    public static long PROC_PIDFILEPORTPSHMINFO_SIZE() {
        return PROC_PIDFILEPORTPSHMINFO_SIZE;
    }

    private static final long PROC_PIDFILEPORTPIPEINFO_SIZE = 184L;
    /**
     * {@snippet lang=c :
     * #define PROC_PIDFILEPORTPIPEINFO_SIZE 184
     * }
     */
    public static long PROC_PIDFILEPORTPIPEINFO_SIZE() {
        return PROC_PIDFILEPORTPIPEINFO_SIZE;
    }

    private static final int PROC_SELFSET_THREADNAME_SIZE = (int) 63L;
    /**
     * {@snippet lang=c :
     * #define PROC_SELFSET_THREADNAME_SIZE 63
     * }
     */
    public static int PROC_SELFSET_THREADNAME_SIZE() {
        return PROC_SELFSET_THREADNAME_SIZE;
    }
}
